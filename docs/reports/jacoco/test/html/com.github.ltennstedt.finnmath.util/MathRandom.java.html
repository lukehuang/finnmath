<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MathRandom.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">finnmath</a> &gt; <a href="index.source.html" class="el_package">com.github.ltennstedt.finnmath.util</a> &gt; <span class="el_source">MathRandom.java</span></div><h1>MathRandom.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017 Lars Tennstedt
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.ltennstedt.finnmath.util;

import static com.google.common.base.Preconditions.checkArgument;

import com.github.ltennstedt.finnmath.linear.BigIntMatrix;
import com.github.ltennstedt.finnmath.linear.BigIntMatrix.BigIntMatrixBuilder;
import com.github.ltennstedt.finnmath.linear.BigIntVector;
import com.github.ltennstedt.finnmath.linear.BigIntVector.BigIntVectorBuilder;
import com.github.ltennstedt.finnmath.linear.DecimalMatrix;
import com.github.ltennstedt.finnmath.linear.DecimalMatrix.DecimalMatrixBuilder;
import com.github.ltennstedt.finnmath.linear.DecimalVector;
import com.github.ltennstedt.finnmath.linear.DecimalVector.DecimalVectorBuilder;
import com.github.ltennstedt.finnmath.number.Fraction;
import com.github.ltennstedt.finnmath.number.RealComplexNumber;
import com.github.ltennstedt.finnmath.number.SimpleComplexNumber;
import com.google.common.annotations.Beta;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.apache.commons.lang3.RandomUtils;

/**
 * A pseudo random generator for {@code long}, {@link BigDecimal}, {@link Fraction},
 * {@link SimpleComplexNumber}, {@link RealComplexNumber}, {@link BigIntVector},
 * {@link DecimalVector}, {@link BigIntMatrix} and {@link DecimalMatrix}
 *
 * @author Lars Tennstedt
 * @since 1
 */
@Beta
public final class MathRandom {
    private final Random random;

    /**
     * Default constructor
     *
     * @author Lars Tennstedt
     * @since 1
     */
<span class="fc" id="L62">    public MathRandom() {</span>
<span class="fc" id="L63">        random = new Random();</span>
<span class="fc" id="L64">    }</span>

    /**
     * Constructor which has the seed value as parameter
     *
     * @param seed The seed
     * @author Lars Tennstedt
     * @since 1
     */
<span class="fc" id="L73">    public MathRandom(final long seed) {</span>
<span class="fc" id="L74">        random = new Random(seed);</span>
<span class="fc" id="L75">    }</span>

    /**
     * Returns a positive {@code long} bounded below by {@code 0} (inclusive) and above by
     * {@code bound} (exclusive)
     *
     * @param bound the bound
     * @return A pseudo random {@code long}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @since 1
     */
    public long nextPositiveLong(final long bound) {
<span class="fc bfc" id="L88" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L89">        return RandomUtils.nextLong(0, bound);</span>
    }

    /**
     * Returns a negative {@code long} bounded below by {@code -bound} (exclusive) and above by
     * {@code 0} (inclusive)
     *
     * @param bound the bound
     * @return A pseudo random {@code long}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @since 1
     */
    public long nextNegativeLong(final long bound) {
<span class="fc bfc" id="L103" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L104">        return (-1) * RandomUtils.nextLong(0, bound);</span>
    }

    /**
     * Returns a {@code long} bounded below by {@code -bound} (exclusive) and above by {@code bound}
     * (exclusive)
     *
     * @param bound the bound
     * @return A pseudo random {@code long}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @since 1
     */
    public long nextLong(final long bound) {
<span class="fc bfc" id="L118" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L120">            return nextNegativeLong(bound);</span>
        }
<span class="fc" id="L122">        return nextPositiveLong(bound);</span>
    }

    /**
     * Returns an array of the length of {@code howMany} containing positive {@code long longs}
     *
     * @param bound   the bound
     * @param howMany the length of the resulting array
     * @return An array of pseudo random {@code long longs}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextPositiveLong
     * @since 1
     */
    public long[] nextPositiveLongs(final long bound, final int howMany) {
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L140">        final long[] ints = new long[howMany];</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L142">            ints[i] = nextPositiveLong(bound);</span>
        }
<span class="fc" id="L144">        return ints;</span>
    }

    /**
     * Returns an array of the length of {@code howMany} containing negative {@code long longs}
     *
     * @param bound   {@code long}
     * @param howMany {@code int}
     * @return An array of pseudo random {@code long longs}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextNegativeLong
     * @since 1
     */
    public long[] nextNegativeLongs(final long bound, final int howMany) {
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L162">        final long[] ints = new long[howMany];</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L164">            ints[i] = nextNegativeLong(bound);</span>
        }
<span class="fc" id="L166">        return ints;</span>
    }

    /**
     * Returns an array of the length of {@code howMany} containing {@code long longs}
     *
     * @param bound   the bound
     * @param howMany the length of the resulting array
     * @return An array of pseudo random {@code long longs}
     * @throws IllegalArgumentException if {@code  bound &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextLong
     * @since 1
     */
    public long[] nextLongs(final long bound, final int howMany) {
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L184">        final long[] ints = new long[howMany];</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L186">            ints[i] = nextLong(bound);</span>
        }
<span class="fc" id="L188">        return ints;</span>
    }

    /**
     * Returns a positive {@link BigDecimal} of a given {@code scale} bounded below by {@code 0}
     * (inclusive) and above by {@code bound} (exclusive)
     *
     * @param bound the bound
     * @param scale the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @since 1
     */
    public BigDecimal nextPositiveDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L204" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L206">        final BigDecimal decimal = nextDecimal(bound, scale);</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &lt; 0) {</span>
<span class="nc" id="L208">            return decimal.negate();</span>
        }
<span class="fc" id="L210">        return decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} of a given {@code scale} bounded below by
     * {@code -bound} (exclusive) and above by {@code 0} (inclusive)
     *
     * @param bound the bound
     * @param scale the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @since 1
     */
    public BigDecimal nextNegativeDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L226" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L228">        final BigDecimal decimal = nextDecimal(bound, scale);</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &gt; 0) {</span>
<span class="fc" id="L230">            return decimal.negate();</span>
        }
<span class="nc" id="L232">        return decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} of a given {@code scale} bounded below by {@code -bound}
     * (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound the bound
     * @param scale the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @since 1
     */
    public BigDecimal nextDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L250">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L251">        return keepDecimalInBound(decimal, bound).setScale(scale, BigDecimal.ROUND_HALF_UP);</span>
    }

    /**
     * Returns a positive {@link BigDecimal} which is invertible
     *
     * @param bound the bound
     * @param scale the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException if {@code bound &lt; 2}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @see #nextPositiveDecimal
     * @since 1
     */
    public BigDecimal nextInvertiblePositiveDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L267" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L269">        final BigDecimal decimal = nextInvertibleDecimal(bound, scale);</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &lt; 0) {</span>
<span class="nc" id="L271">            return decimal.negate();</span>
        }
<span class="fc" id="L273">        return decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} which is invertible
     *
     * @param bound the bound
     * @param scale the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException if {@code bound &lt; 2}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @see #nextNegativeDecimal
     * @see #nextInvertibleDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleNegativeDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L290" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L292">        final BigDecimal decimal = nextInvertibleDecimal(bound, scale);</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &gt; 0) {</span>
<span class="fc" id="L294">            return decimal.negate();</span>
        }
<span class="nc" id="L296">        return decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} which is invertible
     *
     * @param bound the bound
     * @param scale the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException if {@code bound &lt; 2}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L312" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L314">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L315">        return keepDecimalInBound(decimal, bound).setScale(scale, BigDecimal.ROUND_HALF_UP);</span>
    }

    @VisibleForTesting
    BigDecimal keepDecimalInBound(final BigDecimal decimal, final long bound) {
<span class="fc" id="L320">        BigDecimal result = decimal;</span>
<span class="fc" id="L321">        final BigDecimal decimalBound = BigDecimal.valueOf(bound);</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        if (result.compareTo(BigDecimal.ZERO) &gt; -1) {</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">            while (result.compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L324">                result = result.subtract(decimalBound);</span>
            }
        } else {
<span class="fc bfc" id="L327" title="All 2 branches covered.">            while (result.abs().compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L328">                result = result.add(decimalBound);</span>
            }
        }
<span class="fc" id="L331">        return result;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link BigDecimal
     * BigDecimals}
     *
     * @param bound   the bound
     * @param scale   the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextPositiveDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextPositiveDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L350" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L353">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L355">            decimals.add(nextPositiveDecimal(bound, scale));</span>
        }
<span class="fc" id="L357">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link BigDecimal
     * BigDecimals}
     *
     * @param bound   the bound
     * @param scale   the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextNegativeDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextNegativeDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L376" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L379">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L381">            decimals.add(nextNegativeDecimal(bound, scale));</span>
        }
<span class="fc" id="L383">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigDecimal
     * BigDecimals}
     *
     * @param bound   the bound
     * @param scale   the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L402" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L405">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L407">            decimals.add(nextDecimal(bound, scale));</span>
        }
<span class="fc" id="L409">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link BigDecimal
     * BigDecimals} which are invertible
     *
     * @param bound   the bound
     * @param scale   the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertiblePositiveDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertiblePositiveDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L428" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L431">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L433">            decimals.add(nextInvertiblePositiveDecimal(bound, scale));</span>
        }
<span class="fc" id="L435">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link BigDecimal
     * BigDecimals} which are invertible
     *
     * @param bound   the bound
     * @param scale   the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleNegativeDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleNegativeDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L454" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L457">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L459">            decimals.add(nextInvertibleNegativeDecimal(bound, scale));</span>
        }
<span class="fc" id="L461">        return decimals;</span>
    }

    /**
     * Returns a {@code List} of the size of {@code howMany} containing {@link BigDecimal
     * BigDecimals} which are invertible
     *
     * @param bound   the bound
     * @param scale   the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L480" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L483">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L485">            decimals.add(nextInvertibleDecimal(bound, scale));</span>
        }
<span class="fc" id="L487">        return decimals;</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by {@code 0} (inclusive)
     * and above by {@code bound} (exclusive) and whose {@code denominator} is bounded below
     * {@code 1} (inclusive) and {@code bound} (exclusive)
     *
     * @param bound the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @since 1
     */
    public Fraction nextPositiveFraction(final long bound) {
<span class="fc bfc" id="L502" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L503">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L504">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L505">        return new Fraction(numerator, denominator);</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by {@code -bound}
     * (exclusive) and above by {@code 0} (inclusive) and whose {@code denominator} is bounded below
     * {@code 1} (inclusive) and {@code bound} (exclusive)
     *
     * @param bound the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @since 1
     */
    public Fraction nextNegativeFraction(final long bound) {
<span class="fc bfc" id="L520" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L521">        return nextPositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by {@code -bound}
     * (exclusive) and above by {@code bound} (exclusive) and whose {@code denominator} is bounded
     * below {@code -bound} (exclusive) and {@code bound} (exclusive)
     *
     * @param bound the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @since 1
     */
    public Fraction nextFraction(final long bound) {
<span class="fc bfc" id="L536" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L538">            return nextNegativeFraction(bound);</span>
        }
<span class="fc" id="L540">        return nextPositiveFraction(bound);</span>
    }

    /**
     * Returns a positive {@link Fraction} which is invertible
     *
     * @param bound the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @see #nextPositiveFraction
     * @since 1
     */
    public Fraction nextInvertiblePositiveFraction(final long bound) {
<span class="fc bfc" id="L554" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L555">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L556">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L557">        return new Fraction(numerator, denominator);</span>
    }

    /**
     * Returns a negative {@link Fraction} which is invertible
     *
     * @param bound the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @see #nextNegativeFraction
     * @since 1
     */
    public Fraction nextInvertibleNegativeFraction(final long bound) {
<span class="fc bfc" id="L571" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L572">        return nextInvertiblePositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} which is invertible
     *
     * @param bound the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @see #nextFraction
     * @since 1
     */
    public Fraction nextInvertibleFraction(final long bound) {
<span class="fc bfc" id="L586" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L588">            return nextInvertibleNegativeFraction(bound);</span>
        }
<span class="fc" id="L590">        return nextInvertiblePositiveFraction(bound);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link Fraction
     * Fractions}
     *
     * @param bound   the bound
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException if {@code  bound &lt; 2}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextPositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextPositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L607" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L609">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L611">            fractions.add(nextPositiveFraction(bound));</span>
        }
<span class="fc" id="L613">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link Fraction
     * Fractions}
     *
     * @param bound   the bound
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException if {@code  bound &lt; 2}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L630" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L632">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L634">            fractions.add(nextNegativeFraction(bound));</span>
        }
<span class="fc" id="L636">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link Fraction Fractions}
     *
     * @param bound   the bound
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException if {@code  bound &lt; 2}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L652" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L654">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L656">            fractions.add(nextFraction(bound));</span>
        }
<span class="fc" id="L658">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link Fraction
     * Fractions} which are invertible
     *
     * @param bound   the bound
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException if {@code  bound &lt; 2}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertiblePositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertiblePositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L675" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L677">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L679">            fractions.add(nextInvertiblePositiveFraction(bound));</span>
        }
<span class="fc" id="L681">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link Fraction
     * Fractions} which are invertible
     *
     * @param bound   the bound
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException if {@code  bound &lt; 2}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L698" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L700">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L702">            fractions.add(nextInvertibleNegativeFraction(bound));</span>
        }
<span class="fc" id="L704">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link Fraction Fractions}
     * which are invertible
     *
     * @param bound   the bound
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException if {@code  bound &lt; 2}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L721" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L723">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L725">            fractions.add(nextInvertibleFraction(bound));</span>
        }
<span class="fc" id="L727">        return fractions;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} whose {@code real} and {@code imaginary} part are
     * bounded below by {@code -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound the bound
     * @return A pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @since 1
     */
    public SimpleComplexNumber nextSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L741" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L742">        final BigInteger real = BigInteger.valueOf(nextLong(bound));</span>
<span class="fc" id="L743">        final BigInteger imaginary = BigInteger.valueOf(nextLong(bound));</span>
<span class="fc" id="L744">        return new SimpleComplexNumber(real, imaginary);</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} which is invertible
     *
     * @param bound the bound
     * @return A pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSimpleComplexNumber
     * @since 1
     */
    public SimpleComplexNumber nextInvertibleSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L758" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L759">        final BigInteger nonZeroPart = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">        final long possibleZeroPart = random.nextBoolean() ? RandomUtils.nextLong(1, bound) : nextLong(bound);</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L762">            return new SimpleComplexNumber(BigInteger.valueOf(possibleZeroPart), nonZeroPart);</span>
        }
<span class="fc" id="L764">        return new SimpleComplexNumber(nonZeroPart, BigInteger.valueOf(possibleZeroPart));</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumber
     * SimpleComplexNumbers}
     *
     * @param bound   the bound
     * @param howMany the size of the resulting {@link List}
     * @return A List {@link List} of pseudo random {@link SimpleComplexNumber SimpleComplexNumbers}
     * @throws IllegalArgumentException if {@code  bound &lt; 2}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L781" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L783">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L785">            complexNumbers.add(nextSimpleComplexNumber(bound));</span>
        }
<span class="fc" id="L787">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumber
     * SimpleComplexNumbers} which are invertible
     *
     * @param bound   the bound
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumber SimpleComplexNumbers}
     * @throws IllegalArgumentException if {@code  bound &lt; 2}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextInvertibleSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L804" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L805" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L806">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L808">            complexNumbers.add(nextInvertibleSimpleComplexNumber(bound));</span>
        }
<span class="fc" id="L810">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link RealComplexNumber} whose {@code real} and {@code imaginary} part are bounded
     * below by {@code -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound the bound
     * @param scale the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @since 1
     */
    public RealComplexNumber nextRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L825" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L827">        final BigDecimal real = nextDecimal(bound, scale);</span>
<span class="fc" id="L828">        final BigDecimal imaginary = nextDecimal(bound, scale);</span>
<span class="fc" id="L829">        return new RealComplexNumber(real, imaginary);</span>
    }

    /**
     * Returns a {@link RealComplexNumber} which is invertible
     *
     * @param bound the bound
     * @param scale the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @see #nextRealComplexNumber
     * @since 1
     */
    public RealComplexNumber nextInvertibleRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L844" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L845" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L846">        final BigDecimal nonZeroPart = nextInvertibleDecimal(bound, scale);</span>
        final BigDecimal possibleZeroPart =
<span class="fc bfc" id="L848" title="All 2 branches covered.">                random.nextBoolean() ? nextInvertibleDecimal(bound, scale) : nextDecimal(bound, scale);</span>
<span class="fc bfc" id="L849" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L850">            return new RealComplexNumber(possibleZeroPart, nonZeroPart);</span>
        }
<span class="fc" id="L852">        return new RealComplexNumber(nonZeroPart, possibleZeroPart);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumber
     * RealComplexNumbers}
     *
     * @param bound   the bound
     * @param scale   the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber RealComplexNumbers}
     * @throws IllegalArgumentException if {@code  bound &lt; 2}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextRealComplexNumbers(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L870" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L871" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L873">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L875">            complexNumbers.add(nextRealComplexNumber(bound, scale));</span>
        }
<span class="fc" id="L877">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumber
     * RealComplexNumbers} which are invertible
     *
     * @param bound   the bound
     * @param scale   the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber RealComplexNumbers}
     * @throws IllegalArgumentException if {@code  bound &lt; 2}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextInvertibleRealComplexNumbers(final long bound, final int scale,
                                                                    final int howMany) {
<span class="fc bfc" id="L896" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L899">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L900" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L901">            complexNumbers.add(nextInvertibleRealComplexNumber(bound, scale));</span>
        }
<span class="fc" id="L903">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link BigIntVector}
     *
     * @param bound the bound
     * @param size  the size of the resulting {@link BigIntVector}
     * @return A pseudo random {@link BigIntVector}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @since 1
     */
    public BigIntVector nextBigIntVector(final long bound, final int size) {
<span class="fc bfc" id="L919" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L920" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L921">        final BigIntVectorBuilder builder = BigIntVector.builder(size);</span>
<span class="fc bfc" id="L922" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L923">            builder.put(BigInteger.valueOf(nextLong(bound)));</span>
        }
<span class="fc" id="L925">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigIntVector
     * BigIntVectors}
     *
     * @param bound   the bound
     * @param size    the sizes of the resulting {@link BigIntVector BigIntVectors}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigIntVector BigIntVectors}
     * @throws IllegalArgumentException if {@code  bound &lt; 2}
     * @throws IllegalArgumentException if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextBigIntVector
     * @since 1
     */
    public List&lt;BigIntVector&gt; nextBigIntVectors(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L943" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L944" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L945" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L946">        final List&lt;BigIntVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L947" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L948">            vectors.add(nextBigIntVector(bound, size));</span>
        }
<span class="fc" id="L950">        return vectors;</span>
    }

    /**
     * Returns a {@link BigIntMatrix}
     *
     * @param bound      the bound
     * @param rowSize    the row size of the resulting {@link BigIntMatrix}
     * @param columnSize the column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random {@link BigIntMatrix}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException if {@code columnSize &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @since 1
     */
    public BigIntMatrix nextBigIntMatrix(final long bound, final int rowSize, final int columnSize) {
<span class="fc bfc" id="L968" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L969" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L970" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L971">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L972">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L973">            IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L974">                builder.put(rowIndex, columnIndex, BigInteger.valueOf(nextLong(bound)));</span>
<span class="fc" id="L975">            });</span>
<span class="fc" id="L976">        });</span>
<span class="fc" id="L977">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link BigIntMatrix}
     *
     * @param bound the bound
     * @param size  the row and column size of resulting {@link BigIntMatrix}
     * @return A pseudo random upper triangular {@link BigIntMatrix}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @see BigIntMatrix#upperTriangular
     * @since 1
     */
    public BigIntMatrix nextUpperTriangularBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L994" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L996">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(size, size);</span>
<span class="fc" id="L997">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L998">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L999" title="All 2 branches covered.">                if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L1000">                    builder.put(rowIndex, columnIndex, BigInteger.valueOf(nextLong(bound)));</span>
                } else {
<span class="fc" id="L1002">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1004">            });</span>
<span class="fc" id="L1005">        });</span>
<span class="fc" id="L1006">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link BigIntMatrix}
     *
     * @param bound the bound
     * @param size  the row and column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random lower triangular {@link BigIntMatrix}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @see BigIntMatrix#lowerTriangular
     * @since 1
     */
    public BigIntMatrix nextLowerTriangularBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1023" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1024" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1025">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(size, size);</span>
<span class="fc" id="L1026">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1027">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1028" title="All 2 branches covered.">                if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L1029">                    builder.put(rowIndex, columnIndex, BigInteger.valueOf(nextLong(bound)));</span>
                } else {
<span class="fc" id="L1031">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1033">            });</span>
<span class="fc" id="L1034">        });</span>
<span class="fc" id="L1035">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link BigIntMatrix}
     *
     * @param bound the bound
     * @param size  the row and column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random triangular {@link BigIntMatrix}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularBigIntMatrix
     * @see #nextLowerTriangularBigIntMatrix
     * @see BigIntMatrix#triangular
     * @since 1
     */
    public BigIntMatrix nextTriangularBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1053" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1054" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1055" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L1056">            return nextLowerTriangularBigIntMatrix(bound, size);</span>
        }
<span class="fc" id="L1058">        return nextUpperTriangularBigIntMatrix(bound, size);</span>
    }

    /**
     * Returns a diagonal {@link BigIntMatrix}
     *
     * @param bound the bound
     * @param size  the row and column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random diagonal {@link BigIntMatrix}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see BigIntMatrix#diagonal
     * @since 1
     */
    public BigIntMatrix nextDiagonalBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1074" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1075" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1076">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(size, size);</span>
<span class="fc" id="L1077">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1078">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1080">                    builder.put(rowIndex, columnIndex, BigInteger.valueOf(nextLong(bound)));</span>
                } else {
<span class="fc" id="L1082">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1084">            });</span>
<span class="fc" id="L1085">        });</span>
<span class="fc" id="L1086">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link BigIntMatrix}
     *
     * @param bound the bound
     * @param size  the row and column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random symmetric {@link BigIntMatrix}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see BigIntMatrix#symmetric
     * @since 1
     */
    public BigIntMatrix nextSymmetricBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1102" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1103" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1104">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(size, size);</span>
<span class="fc" id="L1105">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1106">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1107">                final BigInteger element = BigInteger.valueOf(nextLong(bound));</span>
<span class="fc bfc" id="L1108" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1109">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1110">                    builder.put(columnIndex, rowIndex, element);</span>
                }
<span class="fc bfc" id="L1112" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1113">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L1115">            });</span>
<span class="fc" id="L1116">        });</span>
<span class="fc" id="L1117">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link BigIntMatrix}
     *
     * @param bound the bound
     * @param size  the row and column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random skew-symmetric {@link BigIntMatrix}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see BigIntMatrix#skewSymmetric
     * @since 1
     */
    public BigIntMatrix nextSkewSymmetricBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1133" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1134" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1135">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(size, size);</span>
<span class="fc" id="L1136">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1137">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1138" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1139">                    final BigInteger element = BigInteger.valueOf(nextLong(bound));</span>
<span class="fc" id="L1140">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1141">                    builder.put(columnIndex, rowIndex, element.negate());</span>
                }
<span class="fc bfc" id="L1143" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1144">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1146">            });</span>
<span class="fc" id="L1147">        });</span>
<span class="fc" id="L1148">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigIntMatrix
     * BigIntMatrices}
     *
     * @param bound      the bound
     * @param rowSize    the row size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param columnSize the column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany    the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextBigIntMatrices(final long bound, final int rowSize, final int columnSize,
                                                 final int howMany) {
<span class="fc bfc" id="L1170" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1172" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1173" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1174">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1175" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1176">            matrices.add(nextBigIntMatrix(bound, rowSize, columnSize));</span>
        }
<span class="fc" id="L1178">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular
     * {@link BigIntMatrix BigIntMatrices}
     *
     * @param bound   the bound
     * @param size    the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextUpperTriangularBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1197" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1198" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1199" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1200">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1201" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1202">            matrices.add(nextUpperTriangularBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1204">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular
     * {@link BigIntMatrix BigIntMatrices}
     *
     * @param bound   the bound
     * @param size    the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLowerTriangularBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextLowerTriangularBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1223" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1224" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1225" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1226">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1227" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1228">            matrices.add(nextLowerTriangularBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1230">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular
     * {@link BigIntMatrix BigIntMatrices}
     *
     * @param bound   the bound
     * @param size    the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextTriangularBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextTriangularBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1249" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1250" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1251" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1252">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1253" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1254">            matrices.add(nextTriangularBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1256">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal {@link BigIntMatrix
     * BigIntMatrices}
     *
     * @param bound   the bound
     * @param size    the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDiagonalBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextDiagonalBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1275" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1276" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1277" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1278">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1279" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1280">            matrices.add(nextDiagonalBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1282">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric
     * {@link BigIntMatrix BigIntMatrices}
     *
     * @param bound   the bound
     * @param size    the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSymmetricBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextSymmetricBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1301" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1302" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1303" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1304">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1305" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1306">            matrices.add(nextSymmetricBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1308">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric
     * {@link BigIntMatrix BigIntMatrices}
     *
     * @param bound   the bound
     * @param size    the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSkewSymmetricBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextSkewSymmetricBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1327" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1328" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1329" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1330">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1331" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1332">            matrices.add(nextSkewSymmetricBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1334">        return matrices;</span>
    }

    /**
     * Returns a {@link DecimalVector}
     *
     * @param bound the bound
     * @param scale the scale to be set on the {@link BigDecimal BigDecimals}
     * @param size  the size of the resulting {@link DecimalVector}
     * @return A speudo random {@link DecimalVector}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @since 1
     */
    public DecimalVector nextDecimalVector(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1352" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1353" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1354" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1355">        final DecimalVectorBuilder builder = DecimalVector.builder(size);</span>
<span class="fc bfc" id="L1356" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1357">            builder.put(nextDecimal(bound, scale));</span>
        }
<span class="fc" id="L1359">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link DecimalVector
     * DecimalVectors}
     *
     * @param bound   the bound
     * @param scale   the scale to be set on the {@link BigDecimal BigDecimals}
     * @param size    the size of the resulting {@link DecimalVector DecimalVectors}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link DecimalVector DecimalVectors}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimalVector
     * @since 1
     */
    public List&lt;DecimalVector&gt; nextDecimalVectors(final long bound, final int scale, final int size,
                                                  final int howMany) {
<span class="fc bfc" id="L1382" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1383" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1384" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1385" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1386">        final List&lt;DecimalVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1387" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1388">            vectors.add(nextDecimalVector(bound, scale, size));</span>
        }
<span class="fc" id="L1390">        return vectors;</span>
    }

    /**
     * Returns a {@link DecimalMatrix}
     *
     * @param bound      the bound
     * @param scale      the scale to be set on the {@link BigDecimal BigDecimals}
     * @param rowSize    the row size of the resulting {@link DecimalMatrix}
     * @param columnSize the column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random {@link DecimalMatrix}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException if {@code columnSize &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @since 1
     */
    public DecimalMatrix nextDecimalMatrix(final long bound, final int scale, final int rowSize, final int columnSize) {
<span class="fc bfc" id="L1410" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1411" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1412" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1413" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L1414">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L1415">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1416">            IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1417">                builder.put(rowIndex, columnIndex, nextDecimal(bound, scale));</span>
<span class="fc" id="L1418">            });</span>
<span class="fc" id="L1419">        });</span>
<span class="fc" id="L1420">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link DecimalMatrix}
     *
     * @param bound the bound
     * @param scale the scale
     * @param size  the row and column size of resulting {@link DecimalMatrix}
     * @return A pseudo random upper triangular {@link DecimalMatrix}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @see DecimalMatrix#upperTriangular
     * @since 1
     */
    public DecimalMatrix nextUpperTriangularDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1439" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1440" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1441">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1442">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1443">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1444" title="All 2 branches covered.">                if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L1445">                    builder.put(rowIndex, columnIndex, nextDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1447">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1449">            });</span>
<span class="fc" id="L1450">        });</span>
<span class="fc" id="L1451">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link DecimalMatrix}
     *
     * @param bound the bound
     * @param scale the scale
     * @param size  the row and column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random lower triangular {@link DecimalMatrix}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @see DecimalMatrix#lowerTriangular
     * @since 1
     */
    public DecimalMatrix nextLowerTriangularDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1470" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1471" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1472">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1473">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1474">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1475" title="All 2 branches covered.">                if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L1476">                    builder.put(rowIndex, columnIndex, nextDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1478">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1480">            });</span>
<span class="fc" id="L1481">        });</span>
<span class="fc" id="L1482">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link DecimalMatrix}
     *
     * @param bound the bound
     * @param scale the scale
     * @param size  the row and column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random triangular {@link DecimalMatrix}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularDecimalMatrix
     * @see #nextLowerTriangularDecimalMatrix
     * @see DecimalMatrix#triangular
     * @since 1
     */
    public DecimalMatrix nextTriangularDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1502" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1503" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1504" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L1505">            return nextLowerTriangularDecimalMatrix(bound, scale, size);</span>
        }
<span class="fc" id="L1507">        return nextUpperTriangularDecimalMatrix(bound, scale, size);</span>
    }

    /**
     * Returns a diagonal {@link DecimalMatrix}
     *
     * @param bound the bound
     * @param scale the scale
     * @param size  the row and column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random diagonal {@link DecimalMatrix}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see DecimalMatrix#diagonal
     * @since 1
     */
    public DecimalMatrix nextDiagonalDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1525" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1526" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1527">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1528">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1529">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1530" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1531">                    builder.put(rowIndex, columnIndex, nextDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1533">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1535">            });</span>
<span class="fc" id="L1536">        });</span>
<span class="fc" id="L1537">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link DecimalMatrix}
     *
     * @param bound the bound
     * @param scale the scale
     * @param size  the row and column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random symmetric {@link DecimalMatrix}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see DecimalMatrix#symmetric
     * @since 1
     */
    public DecimalMatrix nextSymmetricDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1555" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1556" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1557">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1558">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1559">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1560">                final BigDecimal element = nextDecimal(bound, scale);</span>
<span class="fc bfc" id="L1561" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1562">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1563">                    builder.put(columnIndex, rowIndex, element);</span>
                }
<span class="fc bfc" id="L1565" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1566">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L1568">            });</span>
<span class="fc" id="L1569">        });</span>
<span class="fc" id="L1570">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link DecimalMatrix}
     *
     * @param bound the bound
     * @param scale the scale
     * @param size  the row and column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random skew-symmetric {@link DecimalMatrix}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see DecimalMatrix#skewSymmetric
     * @since 1
     */
    public DecimalMatrix nextSkewSymmetricDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1588" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1589" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1590">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1591">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1592">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1593" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1594">                    final BigDecimal element = nextDecimal(bound, scale);</span>
<span class="fc" id="L1595">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1596">                    builder.put(columnIndex, rowIndex, element.negate());</span>
                }
<span class="fc bfc" id="L1598" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1599">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1601">            });</span>

<span class="fc" id="L1603">        });</span>
<span class="fc" id="L1604">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link DecimalMatrix
     * DecimalMatrices}
     *
     * @param bound      the bound
     * @param scale      the scale to be set on the {@link BigDecimal BigDecimals}
     * @param rowSize    the row size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param columnSize the column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany    the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextDecimalMatrices(final long bound, final int scale, final int rowSize,
                                                   final int columnSize, final int howMany) {
<span class="fc bfc" id="L1628" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1629" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1630" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1631" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1632" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1633">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1634" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1635">            matrices.add(nextDecimalMatrix(bound, scale, rowSize, columnSize));</span>
        }
<span class="fc" id="L1637">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular
     * {@link DecimalMatrix DecimalMatrices}
     *
     * @param bound   the bound
     * @param scale   the scale
     * @param size    the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link DecimalMatrix
     * DecimalMatrices}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextUpperTriangularDecimalMatrices(final long bound, final int scale, final int size,
                                                                  final int howMany) {
<span class="fc bfc" id="L1660" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1661" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1662" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1663" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1664">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1665" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1666">            matrices.add(nextUpperTriangularDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L1668">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular
     * {@link DecimalMatrix DecimalMatrices}
     *
     * @param bound   the bound
     * @param scale   the scale
     * @param size    the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link DecimalMatrix
     * DecimalMatrices}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLowerTriangularDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextLowerTriangularDecimalMatrices(final long bound, final int scale, final int size,
                                                                  final int howMany) {
<span class="fc bfc" id="L1691" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1692" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1693" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1694" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1695">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1696" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1697">            matrices.add(nextLowerTriangularDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L1699">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular
     * {@link DecimalMatrix DecimalMatrices}
     *
     * @param bound   the bound
     * @param scale   the scale
     * @param size    the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextTriangularDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextTriangularDecimalMatrices(final long bound, final int scale, final int size,
                                                             final int howMany) {
<span class="fc bfc" id="L1721" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1722" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1723" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1724" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1725">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1726" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1727">            matrices.add(nextTriangularDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L1729">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal
     * {@link DecimalMatrix DecimalMatrices}
     *
     * @param bound   the bound
     * @param scale   the scale
     * @param size    the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDiagonalDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextDiagonalDecimalMatrices(final long bound, final int scale, final int size,
                                                           final int howMany) {
<span class="fc bfc" id="L1751" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1752" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1753" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1754" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1755">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1756" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1757">            matrices.add(nextDiagonalDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L1759">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric
     * {@link DecimalMatrix DecimalMatrices}
     *
     * @param bound   the bound
     * @param scale   the scale
     * @param size    the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSymmetricDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextSymmetricDecimalMatrices(final long bound, final int scale, final int size,
                                                            final int howMany) {
<span class="fc bfc" id="L1781" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1782" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1783" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1784" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1785">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1786" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1787">            matrices.add(nextSymmetricDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L1789">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric
     * {@link DecimalMatrix DecimalMatrices}
     *
     * @param bound   the bound
     * @param scale   the scale
     * @param size    the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException if {@code bound &lt; 1}
     * @throws IllegalArgumentException if {@code scale &lt; 0}
     * @throws IllegalArgumentException if {@code size &lt; 1}
     * @throws IllegalArgumentException if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSkewSymmetricDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextSkewSymmetricDecimalMatrices(final long bound, final int scale, final int size,
                                                                final int howMany) {
<span class="fc bfc" id="L1811" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1812" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1813" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1814" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1815">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1816" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1817">            matrices.add(nextSkewSymmetricDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L1819">        return matrices;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L1824">        return MoreObjects.toStringHelper(this).add(&quot;random&quot;, random).toString();</span>
    }

    @VisibleForTesting
    Random getRandom() {
<span class="fc" id="L1829">        return random;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>