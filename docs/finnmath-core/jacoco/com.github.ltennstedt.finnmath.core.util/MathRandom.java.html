<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MathRandom.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">finnMath Core</a> &gt; <a href="index.source.html" class="el_package">com.github.ltennstedt.finnmath.core.util</a> &gt; <span class="el_source">MathRandom.java</span></div><h1>MathRandom.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017 Lars Tennstedt
 *
 * Licensed under Apache License, Version 2.0 (&quot;License&quot;);
 * you may not use this file except in compliance with License.
 * You may obtain a copy of License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See License for specific language governing permissions and
 * limitations under License.
 */

package com.github.ltennstedt.finnmath.core.util;

import static com.google.common.base.Preconditions.checkArgument;

import com.github.ltennstedt.finnmath.core.linear.BigDecimalMatrix;
import com.github.ltennstedt.finnmath.core.linear.BigDecimalMatrix.BigDecimalMatrixBuilder;
import com.github.ltennstedt.finnmath.core.linear.BigDecimalVector;
import com.github.ltennstedt.finnmath.core.linear.BigDecimalVector.BigDecimalVectorBuilder;
import com.github.ltennstedt.finnmath.core.linear.BigIntegerMatrix;
import com.github.ltennstedt.finnmath.core.linear.BigIntegerVector;
import com.github.ltennstedt.finnmath.core.linear.BigIntegerVector.BigIntegerVectorBuilder;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberMatrix;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberMatrix.RealComplexNumberMatrixBuilder;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberVector;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberVector.RealComplexNumberVectorBuilder;
import com.github.ltennstedt.finnmath.core.linear.SimpleComplexNumberMatrix;
import com.github.ltennstedt.finnmath.core.linear.SimpleComplexNumberMatrix.SimpleComplexNumberMatrixBuilder;
import com.github.ltennstedt.finnmath.core.linear.SimpleComplexNumberVector;
import com.github.ltennstedt.finnmath.core.number.Fraction;
import com.github.ltennstedt.finnmath.core.number.PolarForm;
import com.github.ltennstedt.finnmath.core.number.RealComplexNumber;
import com.github.ltennstedt.finnmath.core.number.SimpleComplexNumber;
import com.google.common.annotations.Beta;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.apache.commons.lang3.RandomUtils;

/**
 * A pseudo random generator for {@code long}, {@link BigDecimal},
 * {@link Fraction}, {@link SimpleComplexNumber}, {@link RealComplexNumber},
 * {@link BigIntegerVector}, {@link BigDecimalVector}, {@link BigIntegerMatrix}
 * and {@link BigDecimalMatrix}
 *
 * @author Lars Tennstedt
 * @since 1
 */
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">@Beta</span>
public final class MathRandom {
    private final Random random;

    /**
     * Default constructor
     *
     * @since 1
     */
<span class="fc" id="L70">    public MathRandom() {</span>
<span class="fc" id="L71">        random = new Random();</span>
<span class="fc" id="L72">    }</span>

    /**
     * Constructor which has seed value as parameter
     *
     * @param seed
     *            seed
     * @since 1
     */
<span class="fc" id="L81">    public MathRandom(final long seed) {</span>
<span class="fc" id="L82">        random = new Random(seed);</span>
<span class="fc" id="L83">    }</span>

    /**
     * Returns a positive {@link BigInteger} bounded below by {@code 0} (inclusive)
     * and above by {@code bound} (exclusive)
     *
     * @param bound
     *            bound
     * @return pseudo random {@link BigInteger}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @since 1
     */
    public BigInteger nextPositiveBigInteger(final long bound) {
<span class="fc bfc" id="L97" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L98">        return BigInteger.valueOf(RandomUtils.nextLong(0, bound));</span>
    }

    /**
     * Returns a negative {@link BigInteger} bounded below by {@code -bound}
     * (exclusive) and above by {@code 0} (inclusive)
     *
     * @param bound
     *            bound
     * @return pseudo random {@link BigInteger}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @see #nextPositiveBigInteger(long)
     * @since 1
     */
    public BigInteger nextNegativeBigInteger(final long bound) {
<span class="fc bfc" id="L114" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L115">        return nextPositiveBigInteger(bound).negate();</span>
    }

    /**
     * Returns a {@link BigInteger} bounded below by {@code -bound} (exclusive) and
     * above by {@code bound} (exclusive)
     *
     * @param bound
     *            bound
     * @return pseudo random {@link BigInteger}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @see #nextPositiveBigInteger(long)
     * @see #nextNegativeBigInteger(long)
     * @since 1
     */
    public BigInteger nextBigInteger(final long bound) {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        return random.nextBoolean() ? nextNegativeBigInteger(bound) : nextPositiveBigInteger(bound);</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing positive
     * {@link BigInteger BigIntegers}
     *
     * @param bound
     *            bound
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link BigInteger BigIntegers}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextPositiveBigInteger(long)
     * @since 1
     */
    public List&lt;BigInteger&gt; nextPositiveBigIntegers(final long bound, final int howMany) {
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L155">        final List&lt;BigInteger&gt; integers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L156">        IntStream.range(0, howMany).forEach(i -&gt; integers.add(nextPositiveBigInteger(bound)));</span>
<span class="fc" id="L157">        return integers;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing negative
     * {@link BigInteger BigIntegers}
     *
     * @param bound
     *            bound
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link BigInteger BigIntegers}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextNegativeBigInteger(long)
     * @since 1
     */
    public List&lt;BigInteger&gt; nextNegativeBigIntegers(final long bound, final int howMany) {
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L179">        final List&lt;BigInteger&gt; integers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L180">        IntStream.range(0, howMany).forEach(i -&gt; integers.add(nextNegativeBigInteger(bound)));</span>
<span class="fc" id="L181">        return integers;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing
     * {@link BigInteger BigIntegers}
     *
     * @param bound
     *            bound
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link BigInteger BigIntegers}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public List&lt;BigInteger&gt; nextBigIntegers(final long bound, final int howMany) {
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L203">        final List&lt;BigInteger&gt; integers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L204">        IntStream.range(0, howMany).forEach(i -&gt; integers.add(nextBigInteger(bound)));</span>
<span class="fc" id="L205">        return integers;</span>
    }

    /**
     * Returns a positive {@link BigDecimal} of a given {@code scale} bounded below
     * by {@code 0} (inclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @return pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @since 1
     */
    public BigDecimal nextPositiveBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L224" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L226">        final BigDecimal decimal = nextBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">        return decimal.compareTo(BigDecimal.ZERO) &lt; 0 ? decimal.negate() : decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} of a given {@code scale} bounded below
     * by {@code -bound} (exclusive) and above by {@code 0} (inclusive)
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @return pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @since 1
     */
    public BigDecimal nextNegativeBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L246" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L248">        final BigDecimal decimal = nextBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">        return decimal.compareTo(BigDecimal.ZERO) &gt; 0 ? decimal.negate() : decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} of a given {@code scale} bounded below by
     * {@code -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @return pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @since 1
     */
    public BigDecimal nextBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L268" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L270">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L271">        return keepBigDecimalInBound(decimal, bound).setScale(scale, RoundingMode.HALF_UP);</span>
    }

    /**
     * Returns a positive {@link BigDecimal} which is invertible
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @return pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @see #nextPositiveBigDecimal
     * @since 1
     */
    public BigDecimal nextInvertiblePositiveBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L290" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L292">        final BigDecimal decimal = nextInvertibleBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        return decimal.compareTo(BigDecimal.ZERO) &lt; 0 ? decimal.negate() : decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} which is invertible
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @return pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @see #nextNegativeBigDecimal
     * @see #nextInvertibleBigDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleNegativeBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L313" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L315">        final BigDecimal decimal = nextInvertibleBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        return decimal.compareTo(BigDecimal.ZERO) &gt; 0 ? decimal.negate() : decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} which is invertible
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @return pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @see #nextBigDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L335" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L337">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L338">        return keepBigDecimalInBound(decimal, bound).setScale(scale, RoundingMode.HALF_UP);</span>
    }

    @VisibleForTesting
    BigDecimal keepBigDecimalInBound(final BigDecimal decimal, final long bound) {
<span class="pc bpc" id="L343" title="2 of 4 branches missed.">        assert decimal != null;</span>
<span class="pc bpc" id="L344" title="2 of 4 branches missed.">        assert bound &gt; 1;</span>
<span class="fc" id="L345">        BigDecimal result = decimal;</span>
<span class="fc" id="L346">        final BigDecimal decimalBound = BigDecimal.valueOf(bound);</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if (result.compareTo(BigDecimal.ZERO) &gt; -1) {</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">            while (result.compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L349">                result = result.subtract(decimalBound);</span>
            }
        } else {
<span class="fc bfc" id="L352" title="All 2 branches covered.">            while (result.abs().compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L353">                result = result.add(decimalBound);</span>
            }
        }
<span class="fc" id="L356">        return result;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing positive
     * {@link BigDecimal BigDecimals}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextPositiveBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextPositiveBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L380" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L383">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L384">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextPositiveBigDecimal(bound, scale)));</span>
<span class="fc" id="L385">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing negative
     * {@link BigDecimal BigDecimals}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextNegativeBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextNegativeBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L409" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L412">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L413">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextNegativeBigDecimal(bound, scale)));</span>
<span class="fc" id="L414">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing
     * {@link BigDecimal BigDecimals}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L438" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L441">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L442">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextBigDecimal(bound, scale)));</span>
<span class="fc" id="L443">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing positive
     * {@link BigDecimal BigDecimals} which are invertible
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertiblePositiveBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertiblePositiveBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L467" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L470">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L471">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextInvertiblePositiveBigDecimal(bound, scale)));</span>
<span class="fc" id="L472">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing negative
     * {@link BigDecimal BigDecimals} which are invertible
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleNegativeBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleNegativeBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L496" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L499">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L500">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextInvertibleNegativeBigDecimal(bound, scale)));</span>
<span class="fc" id="L501">        return decimals;</span>
    }

    /**
     * Returns a {@code List} of size of {@code howMany} containing
     * {@link BigDecimal BigDecimals} which are invertible
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L525" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L528">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L529">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextInvertibleBigDecimal(bound, scale)));</span>
<span class="fc" id="L530">        return decimals;</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by
     * {@code 0} (inclusive) and above by {@code
     * bound} (exclusive) and whose {@code denominator} is bounded below {@code 1}
     * (inclusive) and {@code bound} (exclusive)
     *
     * @param bound
     *            bound
     * @return pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @since 1
     */
    public Fraction nextPositiveFraction(final long bound) {
<span class="fc bfc" id="L547" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L548">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L549">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L550">        return Fraction.of(numerator, denominator);</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by
     * {@code -bound} (exclusive) and above by {@code 0} (inclusive) and whose
     * {@code denominator} is bounded below {@code 1} (inclusive) and {@code bound}
     * (exclusive)
     *
     * @param bound
     *            bound
     * @return pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @since 1
     */
    public Fraction nextNegativeFraction(final long bound) {
<span class="fc bfc" id="L567" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L568">        return nextPositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by
     * {@code -bound} (exclusive) and above by {@code bound} (exclusive) and whose
     * {@code denominator} is bounded below {@code -bound} (exclusive) and {@code
     * bound} (exclusive)
     *
     * @param bound
     *            bound
     * @return pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @since 1
     */
    public Fraction nextFraction(final long bound) {
<span class="fc bfc" id="L585" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">        return random.nextBoolean() ? nextNegativeFraction(bound) : nextPositiveFraction(bound);</span>
    }

    /**
     * Returns a positive {@link Fraction} which is invertible
     *
     * @param bound
     *            bound
     * @return pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @see #nextPositiveFraction
     * @since 1
     */
    public Fraction nextInvertiblePositiveFraction(final long bound) {
<span class="fc bfc" id="L601" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L602">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L603">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L604">        return Fraction.of(numerator, denominator);</span>
    }

    /**
     * Returns a negative {@link Fraction} which is invertible
     *
     * @param bound
     *            bound
     * @return pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @see #nextNegativeFraction
     * @since 1
     */
    public Fraction nextInvertibleNegativeFraction(final long bound) {
<span class="fc bfc" id="L619" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L620">        return nextInvertiblePositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} which is invertible
     *
     * @param bound
     *            bound
     * @return pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @see #nextFraction
     * @since 1
     */
    public Fraction nextInvertibleFraction(final long bound) {
<span class="fc bfc" id="L635" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">        return random.nextBoolean() ? nextInvertibleNegativeFraction(bound) : nextInvertiblePositiveFraction(bound);</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing positive
     * {@link Fraction Fractions}
     *
     * @param bound
     *            bound
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextPositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextPositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L656" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L658">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L659">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextPositiveFraction(bound)));</span>
<span class="fc" id="L660">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing negative
     * {@link Fraction Fractions}
     *
     * @param bound
     *            bound
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L680" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L682">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L683">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextNegativeFraction(bound)));</span>
<span class="fc" id="L684">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing {@link Fraction
     * Fractions}
     *
     * @param bound
     *            bound
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L704" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L706">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L707">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextFraction(bound)));</span>
<span class="fc" id="L708">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing positive
     * {@link Fraction Fractions} which are invertible
     *
     * @param bound
     *            bound
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertiblePositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertiblePositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L728" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L730">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L731">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextInvertiblePositiveFraction(bound)));</span>
<span class="fc" id="L732">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing negative
     * {@link Fraction Fractions} which are invertible
     *
     * @param bound
     *            bound
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L752" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L754">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L755">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextInvertibleNegativeFraction(bound)));</span>
<span class="fc" id="L756">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing {@link Fraction
     * Fractions} which are invertible
     *
     * @param bound
     *            bound
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L776" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L778">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L779">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextInvertibleFraction(bound)));</span>
<span class="fc" id="L780">        return fractions;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} whose {@code real} and
     * {@code imaginary} part are bounded below by {@code
     * -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            bound
     * @return pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public SimpleComplexNumber nextSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L797" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L798">        return SimpleComplexNumber.of(nextBigInteger(bound), nextBigInteger(bound));</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} which is invertible
     *
     * @param bound
     *            bound
     * @return pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public SimpleComplexNumber nextInvertibleSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L813" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L814">        final BigInteger nonZeroPart = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L815">        final BigInteger possibleZeroPart = nextBigInteger(bound);</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">        return random.nextBoolean() ? SimpleComplexNumber.of(possibleZeroPart, nonZeroPart)</span>
<span class="fc" id="L817">            : SimpleComplexNumber.of(nonZeroPart, possibleZeroPart);</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing
     * {@link SimpleComplexNumber SimpleComplexNumbers}
     *
     * @param bound
     *            bound
     * @param howMany
     *            size of resulting {@link List}
     * @return List {@link List} of pseudo random {@link SimpleComplexNumber
     *         SimpleComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L838" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L840">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L841">        IntStream.range(0, howMany).forEach(i -&gt; complexNumbers.add(nextSimpleComplexNumber(bound)));</span>
<span class="fc" id="L842">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing
     * {@link SimpleComplexNumber SimpleComplexNumbers} which are invertible
     *
     * @param bound
     *            bound
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link SimpleComplexNumber
     *         SimpleComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextInvertibleSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L863" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L865">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L866">        IntStream.range(0, howMany).forEach(i -&gt; complexNumbers.add(nextInvertibleSimpleComplexNumber(bound)));</span>
<span class="fc" id="L867">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link RealComplexNumber} whose {@code real} and {@code imaginary}
     * part are bounded below by {@code
     * -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @return pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @since 1
     */
    public RealComplexNumber nextRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L885" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L887">        final BigDecimal real = nextBigDecimal(bound, scale);</span>
<span class="fc" id="L888">        final BigDecimal imaginary = nextBigDecimal(bound, scale);</span>
<span class="fc" id="L889">        return RealComplexNumber.of(real, imaginary);</span>
    }

    /**
     * Returns a {@link RealComplexNumber} which is invertible
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @return pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @see #nextRealComplexNumber
     * @since 1
     */
    public RealComplexNumber nextInvertibleRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L906" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L907" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L908">        final BigDecimal nonZeroPart = nextInvertibleBigDecimal(bound, scale);</span>
        final BigDecimal possibleZeroPart =
<span class="fc bfc" id="L910" title="All 2 branches covered.">            random.nextBoolean() ? nextInvertibleBigDecimal(bound, scale) : nextBigDecimal(bound, scale);</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">        return random.nextBoolean() ? RealComplexNumber.of(possibleZeroPart, nonZeroPart)</span>
<span class="fc" id="L912">            : RealComplexNumber.of(nonZeroPart, possibleZeroPart);</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing
     * {@link RealComplexNumber RealComplexNumbers}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link RealComplexNumber
     *         RealComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextRealComplexNumbers(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L937" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L940">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L941">        IntStream.range(0, howMany).forEach(i -&gt; complexNumbers.add(nextRealComplexNumber(bound, scale)));</span>
<span class="fc" id="L942">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing
     * {@link RealComplexNumber RealComplexNumbers} which are invertible
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link RealComplexNumber
     *         RealComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextInvertibleRealComplexNumbers(final long bound, final int scale,
        final int howMany) {
<span class="fc bfc" id="L968" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L969" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L970" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L971">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L972">        IntStream.range(0, howMany).forEach(i -&gt; complexNumbers.add(nextInvertibleRealComplexNumber(bound, scale)));</span>
<span class="fc" id="L973">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link PolarForm}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @return {@link PolarForm}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public PolarForm nextPolarForm(final long bound, final int scale) {
<span class="fc bfc" id="L992" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L994">        return new PolarForm(nextBigDecimal(bound, scale), nextBigDecimal(bound, scale));</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing {@link PolarForm
     * PolarForms}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link RealComplexNumber
     *         RealComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public List&lt;PolarForm&gt; nextPolarForms(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L1019" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1021" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1022">        final List&lt;PolarForm&gt; polarForms = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1023">        IntStream.range(0, howMany).forEach(i -&gt; polarForms.add(nextPolarForm(bound, scale)));</span>
<span class="fc" id="L1024">        return polarForms;</span>
    }

    /**
     * Returns a {@link BigIntegerVector}
     *
     * @param bound
     *            bound
     * @param size
     *            size of resulting {@link BigIntegerVector}
     * @return pseudo random {@link BigIntegerVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public BigIntegerVector nextBigIntegerVector(final long bound, final int size) {
<span class="fc bfc" id="L1043" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1044" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1045">        final BigIntegerVectorBuilder builder = BigIntegerVector.builder(size);</span>
<span class="fc" id="L1046">        IntStream.rangeClosed(1, size).forEach(i -&gt; builder.put(nextBigInteger(bound)));</span>
<span class="fc" id="L1047">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing
     * {@link BigIntegerVector BigIntegerVectors}
     *
     * @param bound
     *            bound
     * @param size
     *            sizes of resulting {@link BigIntegerVector BigIntegerVectors}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link BigIntegerVector
     *         BigIntegerVectors}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextBigIntegerVector
     * @since 1
     */
    public List&lt;BigIntegerVector&gt; nextBigIntegerVectors(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1070" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1071" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1073">        final List&lt;BigIntegerVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1074">        IntStream.range(0, howMany).forEach(i -&gt; vectors.add(nextBigIntegerVector(bound, size)));</span>
<span class="fc" id="L1075">        return vectors;</span>
    }

    /**
     * Returns a {@link BigIntegerMatrix}
     *
     * @param bound
     *            bound
     * @param rowSize
     *            row size of resulting {@link BigIntegerMatrix}
     * @param columnSize
     *            column size of resulting {@link BigIntegerMatrix}
     * @return pseudo random {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public BigIntegerMatrix nextBigIntegerMatrix(final long bound, final int rowSize, final int columnSize) {
<span class="fc bfc" id="L1098" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1099" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1100" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L1101">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L1102">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L1103">            .forEach(rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L1104">                .forEach(columnIndex -&gt; builder.put(rowIndex, columnIndex, nextBigInteger(bound))));</span>
<span class="fc" id="L1105">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link BigIntegerMatrix}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link BigIntegerMatrix}
     * @return pseudo random upper triangular {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigInteger(long)
     * @see BigIntegerMatrix#upperTriangular
     * @since 1
     */
    public BigIntegerMatrix nextUpperTriangularBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1125" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1126" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1127">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1128">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1129">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1130" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 1) {</span>
<span class="fc" id="L1131">                    builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
                } else {
<span class="fc" id="L1133">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1135">            }));</span>
<span class="fc" id="L1136">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link BigIntegerMatrix}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link BigIntegerMatrix}
     * @return pseudo random lower triangular {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigInteger(long)
     * @see BigIntegerMatrix#lowerTriangular
     * @since 1
     */
    public BigIntegerMatrix nextLowerTriangularBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1156" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1157" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1158">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1159">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1160">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1161" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &gt; -1) {</span>
<span class="fc" id="L1162">                    builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
                } else {
<span class="fc" id="L1164">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1166">            }));</span>
<span class="fc" id="L1167">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link BigIntegerMatrix}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link BigIntegerMatrix}
     * @return pseudo random triangular {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextUpperTriangularBigIntegerMatrix
     * @see #nextLowerTriangularBigIntegerMatrix
     * @see BigIntegerMatrix#triangular
     * @since 1
     */
    public BigIntegerMatrix nextTriangularBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1188" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1189" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1190" title="All 2 branches covered.">        return random.nextBoolean() ? nextLowerTriangularBigIntegerMatrix(bound, size)</span>
<span class="fc" id="L1191">            : nextUpperTriangularBigIntegerMatrix(bound, size);</span>
    }

    /**
     * Returns a diagonal {@link BigIntegerMatrix}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link BigIntegerMatrix}
     * @return pseudo random diagonal {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigIntegerMatrix#diagonal
     * @since 1
     */
    public BigIntegerMatrix nextDiagonalBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1210" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1211" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1212">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1213">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1214">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1215" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1216">                    builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
                } else {
<span class="fc" id="L1218">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1220">            }));</span>
<span class="fc" id="L1221">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link BigIntegerMatrix}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link BigIntegerMatrix}
     * @return pseudo random symmetric {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigIntegerMatrix#symmetric
     * @since 1
     */
    public BigIntegerMatrix nextSymmetricBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1240" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1241" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1242">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1243">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1244">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1245">                final BigInteger element = nextBigInteger(bound);</span>
<span class="fc bfc" id="L1246" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L1247">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1248">                    builder.put(columnIndex, rowIndex, element);</span>
<span class="fc bfc" id="L1249" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1250">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L1252">            }));</span>
<span class="fc" id="L1253">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link BigIntegerMatrix}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link BigIntegerMatrix}
     * @return pseudo random skew-symmetric {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigIntegerMatrix#skewSymmetric
     * @since 1
     */
    public BigIntegerMatrix nextSkewSymmetricBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1272" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1273" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1274">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1275">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1276">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1277" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L1278">                    final BigInteger element = nextBigInteger(bound);</span>
<span class="fc" id="L1279">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1280">                    builder.put(columnIndex, rowIndex, element.negate());</span>
<span class="fc bfc" id="L1281" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1282">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1284">            }));</span>
<span class="fc" id="L1285">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing
     * {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            bound
     * @param rowSize
     *            row size of resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param columnSize
     *            column size of resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link BigIntegerMatrix
     *         BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextBigIntegerMatrices(final long bound, final int rowSize, final int columnSize,
        final int howMany) {
<span class="fc bfc" id="L1316" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1317" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1318" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1319" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1320">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1321">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextBigIntegerMatrix(bound, rowSize, columnSize)));</span>
<span class="fc" id="L1322">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing upper triangular
     * {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random upper triangular
     *         {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextUpperTriangularBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextUpperTriangularBigIntegerMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L1349" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1350" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1351" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1352">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1353">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextUpperTriangularBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1354">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing lower triangular
     * {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random lower triangular
     *         {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextLowerTriangularBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextLowerTriangularBigIntegerMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L1381" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1382" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1383" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1384">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1385">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextLowerTriangularBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1386">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing triangular
     * {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random triangular {@link BigIntegerMatrix
     *         BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextTriangularBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextTriangularBigIntegerMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L1413" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1414" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1415" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1416">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1417">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextTriangularBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1418">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing diagonal
     * {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random diagonal {@link BigIntegerMatrix
     *         BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextDiagonalBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextDiagonalBigIntegerMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1444" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1445" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1446" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1447">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1448">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextDiagonalBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1449">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing symmetric
     * {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random symmetric {@link BigIntegerMatrix
     *         BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSymmetricBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextSymmetricBigIntegerMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1475" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1476" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1477" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1478">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1479">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSymmetricBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1480">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing skew-symmetric
     * {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random skew-symmetric {@link BigIntegerMatrix
     *         BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextSkewSymmetricBigIntegerMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L1507" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1508" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1509" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1510">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1511">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSkewSymmetricBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1512">        return matrices;</span>
    }

    /**
     * Returns a {@link BigDecimalVector}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @param size
     *            size of resulting {@link BigDecimalVector}
     * @return speudo random {@link BigDecimalVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigDecimal
     * @since 1
     */
    public BigDecimalVector nextBigDecimalVector(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1535" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1536" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1537" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1538">        final BigDecimalVectorBuilder builder = BigDecimalVector.builder(size);</span>
<span class="fc" id="L1539">        IntStream.rangeClosed(1, size).forEach(i -&gt; builder.put(nextBigDecimal(bound, scale)));</span>
<span class="fc" id="L1540">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing
     * {@link BigDecimalVector BigDecimalVectors}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @param size
     *            size of resulting {@link BigDecimalVector BigDecimalVectors}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link BigDecimalVector
     *         BigDecimalVectors}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextBigDecimalVector
     * @since 1
     */
    public List&lt;BigDecimalVector&gt; nextBigDecimalVectors(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L1572" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1573" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1574" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1575" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1576">        final List&lt;BigDecimalVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1577">        IntStream.range(0, howMany).forEach(i -&gt; vectors.add(nextBigDecimalVector(bound, scale, size)));</span>
<span class="fc" id="L1578">        return vectors;</span>
    }

    /**
     * Returns a {@link BigDecimalMatrix}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @param rowSize
     *            row size of resulting {@link BigDecimalMatrix}
     * @param columnSize
     *            column size of resulting {@link BigDecimalMatrix}
     * @return pseudo random {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @see #nextBigDecimal
     * @since 1
     */
    public BigDecimalMatrix nextBigDecimalMatrix(final long bound, final int scale, final int rowSize,
        final int columnSize) {
<span class="fc bfc" id="L1606" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1607" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1608" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1609" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L1610">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L1611">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L1612">            .forEach(rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L1613">                .forEach(columnIndex -&gt; builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale))));</span>
<span class="fc" id="L1614">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link BigDecimalMatrix}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link BigDecimalMatrix}
     * @return pseudo random upper triangular {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigDecimal
     * @see BigDecimalMatrix#upperTriangular
     * @since 1
     */
    public BigDecimalMatrix nextUpperTriangularBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1638" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1639" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1640">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1641">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1642">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1643" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 1) {</span>
<span class="fc" id="L1644">                    builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1646">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1648">            }));</span>
<span class="fc" id="L1649">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link BigDecimalMatrix}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link BigDecimalMatrix}
     * @return pseudo random lower triangular {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigDecimal
     * @see BigDecimalMatrix#lowerTriangular
     * @since 1
     */
    public BigDecimalMatrix nextLowerTriangularBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1673" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1674" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1675">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1676">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1677">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1678" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &gt; -1) {</span>
<span class="fc" id="L1679">                    builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1681">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1683">            }));</span>
<span class="fc" id="L1684">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link BigDecimalMatrix}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link BigDecimalMatrix}
     * @return pseudo random triangular {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextUpperTriangularBigDecimalMatrix
     * @see #nextLowerTriangularBigDecimalMatrix
     * @see BigDecimalMatrix#triangular
     * @since 1
     */
    public BigDecimalMatrix nextTriangularBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1709" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1710" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1711" title="All 2 branches covered.">        return random.nextBoolean() ? nextLowerTriangularBigDecimalMatrix(bound, scale, size)</span>
<span class="fc" id="L1712">            : nextUpperTriangularBigDecimalMatrix(bound, scale, size);</span>
    }

    /**
     * Returns a diagonal {@link BigDecimalMatrix}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link BigDecimalMatrix}
     * @return pseudo random diagonal {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigDecimalMatrix#diagonal
     * @since 1
     */
    public BigDecimalMatrix nextDiagonalBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1735" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1736" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1737">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1738">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1739">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1740" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1741">                    builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1743">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1745">            }));</span>
<span class="fc" id="L1746">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link BigDecimalMatrix}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link BigDecimalMatrix}
     * @return pseudo random symmetric {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigDecimalMatrix#symmetric
     * @since 1
     */
    public BigDecimalMatrix nextSymmetricBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1769" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1770" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1771">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1772">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1773">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1774">                final BigDecimal element = nextBigDecimal(bound, scale);</span>
<span class="fc bfc" id="L1775" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L1776">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1777">                    builder.put(columnIndex, rowIndex, element);</span>
<span class="fc bfc" id="L1778" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1779">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L1781">            }));</span>
<span class="fc" id="L1782">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link BigDecimalMatrix}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link BigDecimalMatrix}
     * @return pseudo random skew-symmetric {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigDecimalMatrix#skewSymmetric
     * @since 1
     */
    public BigDecimalMatrix nextSkewSymmetricBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1805" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1806" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1807">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1808">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1809">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1810" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L1811">                    final BigDecimal element = nextBigDecimal(bound, scale);</span>
<span class="fc" id="L1812">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1813">                    builder.put(columnIndex, rowIndex, element.negate());</span>
<span class="fc bfc" id="L1814" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1815">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1817">            }));</span>
<span class="fc" id="L1818">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing
     * {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale to be set on {@link BigDecimal BigDecimals}
     * @param rowSize
     *            row size of resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param columnSize
     *            column size of resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link BigDecimalMatrix
     *         BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextBigDecimalMatrices(final long bound, final int scale, final int rowSize,
        final int columnSize, final int howMany) {
<span class="fc bfc" id="L1853" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1854" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1855" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1856" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1857" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1858">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1859">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextBigDecimalMatrix(bound, scale, rowSize, columnSize)));</span>
<span class="fc" id="L1860">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing upper triangular
     * {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random upper triangular
     *         {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextUpperTriangularBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextUpperTriangularBigDecimalMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L1891" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1892" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1893" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1894" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1895">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1896">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextUpperTriangularBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L1897">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing lower triangular
     * {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random lower triangular
     *         {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextLowerTriangularBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextLowerTriangularBigDecimalMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L1928" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1929" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1930" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1931" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1932">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1933">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextLowerTriangularBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L1934">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing triangular
     * {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random triangular {@link BigDecimalMatrix
     *         BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextTriangularBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextTriangularBigDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L1965" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1966" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1967" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1968" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1969">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1970">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextTriangularBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L1971">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing diagonal
     * {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random diagonal {@link BigDecimalMatrix
     *         BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextDiagonalBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextDiagonalBigDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2002" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2003" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2004" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2005" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2006">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2007">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextDiagonalBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L2008">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing symmetric
     * {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random symmetric {@link BigDecimalMatrix
     *         BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSymmetricBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextSymmetricBigDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2039" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2040" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2041" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2042" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2043">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2044">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSymmetricBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L2045">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing skew-symmetric
     * {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random skew-symmetric {@link BigDecimalMatrix
     *         BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextSkewSymmetricBigDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2076" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2077" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2078" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2079" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2080">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2081">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSkewSymmetricBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L2082">        return matrices;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumberVector}
     *
     * @param bound
     *            bound
     * @param size
     *            size of resulting {@link SimpleComplexNumberVector}
     * @return pseudo random {@link SimpleComplexNumberVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextSimpleComplexNumber(long)
     * @since 1
     */
    public SimpleComplexNumberVector nextSimpleComplexNumberVector(final long bound, final int size) {
<span class="fc bfc" id="L2101" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2102" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2103">        final SimpleComplexNumberVector.SimpleComplexNumberVectorBuilder builder =</span>
<span class="fc" id="L2104">            SimpleComplexNumberVector.builder(size);</span>
<span class="fc" id="L2105">        IntStream.rangeClosed(1, size).forEach(i -&gt; builder.put(nextSimpleComplexNumber(bound)));</span>
<span class="fc" id="L2106">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing
     * {@link SimpleComplexNumberVector SimpleComplexNumberVectors}
     *
     * @param bound
     *            bound
     * @param size
     *            sizes of resulting {@link SimpleComplexNumberVector
     *            SimpleComplexNumberVectors}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link SimpleComplexNumberVector
     *         SimpleComplexNumberVectors}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextSimpleComplexNumberVector
     * @since 1
     */
    public List&lt;SimpleComplexNumberVector&gt; nextSimpleComplexNumberVectors(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L2131" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2132" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2133" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2134">        final List&lt;SimpleComplexNumberVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2135">        IntStream.range(0, howMany).forEach(i -&gt; vectors.add(nextSimpleComplexNumberVector(bound, size)));</span>
<span class="fc" id="L2136">        return vectors;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            bound
     * @param rowSize
     *            row size of resulting {@link SimpleComplexNumberMatrix}
     * @param columnSize
     *            column size of resulting {@link SimpleComplexNumberMatrix}
     * @return pseudo random {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @see #nextSimpleComplexNumber(long)
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSimpleComplexNumberMatrix(final long bound, final int rowSize,
        final int columnSize) {
<span class="fc bfc" id="L2160" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2161" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2162" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L2163">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L2164">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L2165">            .forEach(rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L2166">                .forEach(columnIndex -&gt; builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound))));</span>
<span class="fc" id="L2167">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link SimpleComplexNumberMatrix}
     * @return pseudo random upper triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#upperTriangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextUpperTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2186" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2187" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2188">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2189">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2190">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2191" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 1) {</span>
<span class="fc" id="L2192">                    builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                } else {
<span class="fc" id="L2194">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2196">            }));</span>
<span class="fc" id="L2197">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link SimpleComplexNumberMatrix}
     * @return pseudo random lower triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#lowerTriangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextLowerTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2216" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2217" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2218">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2219">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2220">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2221" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &gt; -1) {</span>
<span class="fc" id="L2222">                    builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                } else {
<span class="fc" id="L2224">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2226">            }));</span>
<span class="fc" id="L2227">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link SimpleComplexNumberMatrix}
     * @return pseudo random triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextUpperTriangularSimpleComplexNumberMatrix
     * @see #nextLowerTriangularSimpleComplexNumberMatrix
     * @see SimpleComplexNumberMatrix#triangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2248" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2249" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2250" title="All 2 branches covered.">        return random.nextBoolean() ? nextLowerTriangularSimpleComplexNumberMatrix(bound, size)</span>
<span class="fc" id="L2251">            : nextUpperTriangularSimpleComplexNumberMatrix(bound, size);</span>
    }

    /**
     * Returns a diagonal {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link SimpleComplexNumberMatrix}
     * @return pseudo random diagonal {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#diagonal
     * @since 1
     */
    public SimpleComplexNumberMatrix nextDiagonalSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2270" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2271" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2272">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2273">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2274">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2275" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2276">                    builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                } else {
<span class="fc" id="L2278">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2280">            }));</span>
<span class="fc" id="L2281">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link SimpleComplexNumberMatrix}
     * @return pseudo random symmetric {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#symmetric
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSymmetricSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2300" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2301" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2302">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2303">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2304">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L2305">                final SimpleComplexNumber element = nextSimpleComplexNumber(bound);</span>
<span class="fc bfc" id="L2306" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L2307">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2308">                    builder.put(columnIndex, rowIndex, element);</span>
<span class="fc bfc" id="L2309" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2310">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L2312">            }));</span>
<span class="fc" id="L2313">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link SimpleComplexNumberMatrix}
     * @return pseudo random skew-symmetric {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#skewSymmetric
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSkewSymmetricSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2332" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2333" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2334">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2335">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2336">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2337" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L2338">                    final SimpleComplexNumber element = nextSimpleComplexNumber(bound);</span>
<span class="fc" id="L2339">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2340">                    builder.put(columnIndex, rowIndex, element.negate());</span>
<span class="fc bfc" id="L2341" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2342">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2344">            }));</span>
<span class="fc" id="L2345">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            bound
     * @param rowSize
     *            row size of resulting {@link SimpleComplexNumberMatrix
     *            SimpleComplexNumberMatrices}
     * @param columnSize
     *            column size of resulting {@link SimpleComplexNumberMatrix
     *            SimpleComplexNumberMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link SimpleComplexNumberMatrix
     *         SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSimpleComplexNumberMatrices(final long bound, final int rowSize,
        final int columnSize, final int howMany) {
<span class="fc bfc" id="L2377" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2378" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2379" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L2380" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2381">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2382">        IntStream.range(0, howMany)</span>
<span class="fc" id="L2383">            .forEach(i -&gt; matrices.add(nextSimpleComplexNumberMatrix(bound, rowSize, columnSize)));</span>
<span class="fc" id="L2384">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing upper triangular
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link SimpleComplexNumberMatrix
     *            SimpleComplexNumberMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random upper triangular
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextUpperTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextUpperTriangularSimpleComplexNumberMatrices(final long bound,
        final int size, final int howMany) {
<span class="fc bfc" id="L2411" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2412" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2413" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2414">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2415">        IntStream.range(0, howMany)</span>
<span class="fc" id="L2416">            .forEach(i -&gt; matrices.add(nextUpperTriangularSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2417">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing lower triangular
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link SimpleComplexNumberMatrix
     *            SimpleComplexNumberMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random lower triangular
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextLowerTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextLowerTriangularSimpleComplexNumberMatrices(final long bound,
        final int size, final int howMany) {
<span class="fc bfc" id="L2444" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2445" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2446" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2447">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2448">        IntStream.range(0, howMany)</span>
<span class="fc" id="L2449">            .forEach(i -&gt; matrices.add(nextLowerTriangularSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2450">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing triangular
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link SimpleComplexNumberMatrix
     *            SimpleComplexNumberMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random triangular
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextTriangularSimpleComplexNumberMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L2477" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2478" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2479" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2480">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2481">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextTriangularSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2482">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing diagonal
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link SimpleComplexNumberMatrix
     *            SimpleComplexNumberMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random diagonal
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextDiagonalSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextDiagonalSimpleComplexNumberMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L2509" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2510" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2511" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2512">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2513">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextDiagonalSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2514">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing symmetric
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link SimpleComplexNumberMatrix
     *            SimpleComplexNumberMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random symmetric
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSymmetricSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSymmetricSimpleComplexNumberMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L2541" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2542" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2543" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2544">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2545">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSymmetricSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2546">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing skew-symmetric
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            bound
     * @param size
     *            row and column size of resulting {@link SimpleComplexNumberMatrix
     *            SimpleComplexNumberMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random skew-symmetric
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSkewSymmetricSimpleComplexNumberMatrices(final long bound,
        final int size, final int howMany) {
<span class="fc bfc" id="L2573" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2574" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2575" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2576">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2577">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSkewSymmetricSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2578">        return matrices;</span>
    }

    /**
     * Returns a {@link RealComplexNumberVector}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            size of resulting {@link RealComplexNumberVector}
     * @return pseudo random {@link RealComplexNumberVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @since 1
     */
    public RealComplexNumberVector nextRealComplexNumberVector(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L2601" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2602" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2603" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2604">        final RealComplexNumberVectorBuilder builder = RealComplexNumberVector.builder(size);</span>
<span class="fc" id="L2605">        IntStream.rangeClosed(1, size).forEach(i -&gt; builder.put(nextRealComplexNumber(bound, scale)));</span>
<span class="fc" id="L2606">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing
     * {@link RealComplexNumberVector RealComplexNumberVectors}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            sizes of resulting {@link RealComplexNumberVector
     *            RealComplexNumberVectors}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link RealComplexNumberVector
     *         RealComplexNumberVectors}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextRealComplexNumberVector
     * @since 1
     */
    public List&lt;RealComplexNumberVector&gt; nextRealComplexNumberVectors(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2635" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2636" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2637" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2638" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2639">        final List&lt;RealComplexNumberVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2640">        IntStream.range(0, howMany).forEach(i -&gt; vectors.add(nextRealComplexNumberVector(bound, scale, size)));</span>
<span class="fc" id="L2641">        return vectors;</span>
    }

    /**
     * Returns a {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param rowSize
     *            row size of resulting {@link RealComplexNumberMatrix}
     * @param columnSize
     *            column size of resulting {@link RealComplexNumberMatrix}
     * @return pseudo random {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @since 1
     */
    public RealComplexNumberMatrix nextRealComplexNumberMatrix(final long bound, final int scale, final int rowSize,
        final int columnSize) {
<span class="fc bfc" id="L2669" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2670" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2671" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2672" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L2673">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L2674">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L2675">            .forEach(rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L2676">                .forEach(columnIndex -&gt; builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale))));</span>
<span class="fc" id="L2677">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link RealComplexNumberMatrix}
     * @return pseudo random upper triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @see RealComplexNumberMatrix#upperTriangular
     * @since 1
     */
    public RealComplexNumberMatrix nextUpperTriangularRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2702" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2703" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2704" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2705">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2706">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2707">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2708" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 1) {</span>
<span class="fc" id="L2709">                    builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                } else {
<span class="fc" id="L2711">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2713">            }));</span>
<span class="fc" id="L2714">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link RealComplexNumberMatrix}
     * @return pseudo random lower triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @see RealComplexNumberMatrix#lowerTriangular
     * @since 1
     */
    public RealComplexNumberMatrix nextLowerTriangularRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2739" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2740" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2741" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2742">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2743">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2744">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2745" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &gt; -1) {</span>
<span class="fc" id="L2746">                    builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                } else {
<span class="fc" id="L2748">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2750">            }));</span>
<span class="fc" id="L2751">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link RealComplexNumberMatrix}
     * @return pseudo random triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextUpperTriangularRealComplexNumberMatrix
     * @see #nextLowerTriangularRealComplexNumberMatrix
     * @see RealComplexNumberMatrix#triangular
     * @since 1
     */
    public RealComplexNumberMatrix nextTriangularRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2777" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2778" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2779" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2780" title="All 2 branches covered.">        return random.nextBoolean() ? nextLowerTriangularRealComplexNumberMatrix(bound, scale, size)</span>
<span class="fc" id="L2781">            : nextUpperTriangularRealComplexNumberMatrix(bound, scale, size);</span>
    }

    /**
     * Returns a diagonal {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link RealComplexNumberMatrix}
     * @return pseudo random diagonal {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see RealComplexNumberMatrix#diagonal
     * @since 1
     */
    public RealComplexNumberMatrix nextDiagonalRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2805" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2806" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2807" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2808">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2809">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2810">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2811" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2812">                    builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                } else {
<span class="fc" id="L2814">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2816">            }));</span>
<span class="fc" id="L2817">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link RealComplexNumberMatrix}
     * @return pseudo random symmetric {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see RealComplexNumberMatrix#symmetric
     * @since 1
     */
    public RealComplexNumberMatrix nextSymmetricRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2841" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2842" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2843" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2844">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2845">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2846">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L2847">                final RealComplexNumber element = nextRealComplexNumber(bound, scale);</span>
<span class="fc bfc" id="L2848" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L2849">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2850">                    builder.put(columnIndex, rowIndex, element);</span>
<span class="fc bfc" id="L2851" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2852">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L2854">            }));</span>
<span class="fc" id="L2855">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link RealComplexNumberMatrix}
     * @return pseudo random skew-symmetric {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see RealComplexNumberMatrix#skewSymmetric
     * @since 1
     */
    public RealComplexNumberMatrix nextSkewSymmetricRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2879" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2880" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2881" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2882">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2883">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2884">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2885" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L2886">                    final RealComplexNumber element = nextRealComplexNumber(bound, scale);</span>
<span class="fc" id="L2887">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2888">                    builder.put(columnIndex, rowIndex, element.negate());</span>
<span class="fc bfc" id="L2889" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2890">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2892">            }));</span>
<span class="fc" id="L2893">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing
     * {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param rowSize
     *            row size of resulting {@link RealComplexNumberMatrix
     *            RealComplexNumberMatrices}
     * @param columnSize
     *            column size of resulting {@link RealComplexNumberMatrix
     *            RealComplexNumberMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random {@link RealComplexNumberMatrix
     *         RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextRealComplexNumberMatrices(final long bound, final int scale,
        final int rowSize, final int columnSize, final int howMany) {
<span class="fc bfc" id="L2929" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2930" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2931" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2932" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L2933" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2934">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2935">        IntStream.range(0, howMany)</span>
<span class="fc" id="L2936">            .forEach(i -&gt; matrices.add(nextRealComplexNumberMatrix(bound, scale, rowSize, columnSize)));</span>
<span class="fc" id="L2937">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing upper triangular
     * {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link RealComplexNumberMatrix
     *            RealComplexNumberMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random upper triangular
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextUpperTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextUpperTriangularRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L2968" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2969" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2970" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2971" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2972">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2973">        IntStream.range(0, howMany)</span>
<span class="fc" id="L2974">            .forEach(i -&gt; matrices.add(nextUpperTriangularRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L2975">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing lower triangular
     * {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link RealComplexNumberMatrix
     *            RealComplexNumberMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random lower triangular
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextLowerTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextLowerTriangularRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L3006" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3007" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3008" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3009" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3010">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L3011">        IntStream.range(0, howMany)</span>
<span class="fc" id="L3012">            .forEach(i -&gt; matrices.add(nextLowerTriangularRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L3013">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing triangular
     * {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link RealComplexNumberMatrix
     *            RealComplexNumberMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random triangular
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextTriangularRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L3044" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3045" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3046" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3047" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3048">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L3049">        IntStream.range(0, howMany)</span>
<span class="fc" id="L3050">            .forEach(i -&gt; matrices.add(nextTriangularRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L3051">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing diagonal
     * {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link RealComplexNumberMatrix
     *            RealComplexNumberMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random diagonal {@link RealComplexNumberMatrix
     *         RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextDiagonalRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextDiagonalRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L3082" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3083" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3084" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3085" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3086">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L3087">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextDiagonalRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L3088">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing symmetric
     * {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link RealComplexNumberMatrix
     *            RealComplexNumberMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random symmetric
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSymmetricRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextSymmetricRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L3119" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3120" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3121" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3122" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3123">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L3124">        IntStream.range(0, howMany)</span>
<span class="fc" id="L3125">            .forEach(i -&gt; matrices.add(nextSymmetricRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L3126">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of size of {@code howMany} containing skew-symmetric
     * {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            bound
     * @param scale
     *            scale
     * @param size
     *            row and column size of resulting {@link RealComplexNumberMatrix
     *            RealComplexNumberMatrices}
     * @param howMany
     *            size of resulting {@link List}
     * @return {@link List} of pseudo random skew-symmetric
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextSkewSymmetricRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L3157" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3158" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3159" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3160" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3161">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L3162">        IntStream.range(0, howMany)</span>
<span class="fc" id="L3163">            .forEach(i -&gt; matrices.add(nextSkewSymmetricRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L3164">        return matrices;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L3169">        return MoreObjects.toStringHelper(this).add(&quot;random&quot;, random).toString();</span>
    }

    @VisibleForTesting
    Random getRandom() {
<span class="fc" id="L3174">        return random;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>