<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MathRandom.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">finnMath Core</a> &gt; <a href="index.source.html" class="el_package">com.github.ltennstedt.finnmath.core.util</a> &gt; <span class="el_source">MathRandom.java</span></div><h1>MathRandom.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017 Lars Tennstedt
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.ltennstedt.finnmath.core.util;

import static com.google.common.base.Preconditions.checkArgument;

import com.github.ltennstedt.finnmath.core.linear.BigDecimalMatrix;
import com.github.ltennstedt.finnmath.core.linear.BigDecimalMatrix.BigDecimalMatrixBuilder;
import com.github.ltennstedt.finnmath.core.linear.BigDecimalVector;
import com.github.ltennstedt.finnmath.core.linear.BigDecimalVector.BigDecimalVectorBuilder;
import com.github.ltennstedt.finnmath.core.linear.BigIntegerMatrix;
import com.github.ltennstedt.finnmath.core.linear.BigIntegerVector;
import com.github.ltennstedt.finnmath.core.linear.BigIntegerVector.BigIntegerVectorBuilder;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberMatrix;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberMatrix.RealComplexNumberMatrixBuilder;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberVector;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberVector.RealComplexNumberVectorBuilder;
import com.github.ltennstedt.finnmath.core.linear.SimpleComplexNumberMatrix;
import com.github.ltennstedt.finnmath.core.linear.SimpleComplexNumberMatrix.SimpleComplexNumberMatrixBuilder;
import com.github.ltennstedt.finnmath.core.linear.SimpleComplexNumberVector;
import com.github.ltennstedt.finnmath.core.number.Fraction;
import com.github.ltennstedt.finnmath.core.number.PolarForm;
import com.github.ltennstedt.finnmath.core.number.RealComplexNumber;
import com.github.ltennstedt.finnmath.core.number.SimpleComplexNumber;
import com.google.common.annotations.Beta;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.apache.commons.lang3.RandomUtils;

/**
 * A pseudo random generator for {@code long}, {@link BigDecimal},
 * {@link Fraction}, {@link SimpleComplexNumber}, {@link RealComplexNumber},
 * {@link BigIntegerVector}, {@link BigDecimalVector}, {@link BigIntegerMatrix}
 * and {@link BigDecimalMatrix}
 *
 * @author Lars Tennstedt
 * @since 1
 */
@Beta
public final class MathRandom {
    private final Random random;

    /**
     * Default constructor
     *
     * @since 1
     */
<span class="fc" id="L70">    public MathRandom() {</span>
<span class="fc" id="L71">        random = new Random();</span>
<span class="fc" id="L72">    }</span>

    /**
     * Constructor which has the seed value as parameter
     *
     * @param seed
     *            The seed
     * @since 1
     */
<span class="fc" id="L81">    public MathRandom(final long seed) {</span>
<span class="fc" id="L82">        random = new Random(seed);</span>
<span class="fc" id="L83">    }</span>

    /**
     * Returns a positive {@link BigInteger} bounded below by {@code 0} (inclusive)
     * and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link BigInteger}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @since 1
     */
    public BigInteger nextPositiveBigInteger(final long bound) {
<span class="fc bfc" id="L97" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L98">        return BigInteger.valueOf(RandomUtils.nextLong(0, bound));</span>
    }

    /**
     * Returns a negative {@link BigInteger} bounded below by {@code -bound}
     * (exclusive) and above by {@code 0} (inclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link BigInteger}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @see #nextPositiveBigInteger(long)
     * @since 1
     */
    public BigInteger nextNegativeBigInteger(final long bound) {
<span class="fc bfc" id="L114" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L115">        return nextPositiveBigInteger(bound).negate();</span>
    }

    /**
     * Returns a {@link BigInteger} bounded below by {@code -bound} (exclusive) and
     * above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link BigInteger}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @see #nextPositiveBigInteger(long)
     * @see #nextNegativeBigInteger(long)
     * @since 1
     */
    public BigInteger nextBigInteger(final long bound) {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        return random.nextBoolean() ? nextNegativeBigInteger(bound) : nextPositiveBigInteger(bound);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive
     * {@link BigInteger BigIntegers}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigInteger BigIntegers}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextPositiveBigInteger(long)
     * @since 1
     */
    public List&lt;BigInteger&gt; nextPositiveBigIntegers(final long bound, final int howMany) {
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L155">        final List&lt;BigInteger&gt; integers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L156">        IntStream.range(0, howMany).forEach(i -&gt; integers.add(nextPositiveBigInteger(bound)));</span>
<span class="fc" id="L157">        return integers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative
     * {@link BigInteger BigIntegers}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigInteger BigIntegers}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextNegativeBigInteger(long)
     * @since 1
     */
    public List&lt;BigInteger&gt; nextNegativeBigIntegers(final long bound, final int howMany) {
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L179">        final List&lt;BigInteger&gt; integers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L180">        IntStream.range(0, howMany).forEach(i -&gt; integers.add(nextNegativeBigInteger(bound)));</span>
<span class="fc" id="L181">        return integers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link BigInteger BigIntegers}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigInteger BigIntegers}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public List&lt;BigInteger&gt; nextBigIntegers(final long bound, final int howMany) {
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L203">        final List&lt;BigInteger&gt; integers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L204">        IntStream.range(0, howMany).forEach(i -&gt; integers.add(nextBigInteger(bound)));</span>
<span class="fc" id="L205">        return integers;</span>
    }

    /**
     * Returns a positive {@link BigDecimal} of a given {@code scale} bounded below
     * by {@code 0} (inclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @since 1
     */
    public BigDecimal nextPositiveBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L224" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L226">        final BigDecimal decimal = nextBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">        return decimal.compareTo(BigDecimal.ZERO) &lt; 0 ? decimal.negate() : decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} of a given {@code scale} bounded below
     * by {@code -bound} (exclusive) and above by {@code 0} (inclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @since 1
     */
    public BigDecimal nextNegativeBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L246" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L248">        final BigDecimal decimal = nextBigDecimal(bound, scale);</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        return decimal.compareTo(BigDecimal.ZERO) &gt; 0 ? decimal.negate() : decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} of a given {@code scale} bounded below by
     * {@code -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @since 1
     */
    public BigDecimal nextBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L268" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L270">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L271">        return keepBigDecimalInBound(decimal, bound).setScale(scale, RoundingMode.HALF_UP);</span>
    }

    /**
     * Returns a positive {@link BigDecimal} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @see #nextPositiveBigDecimal
     * @since 1
     */
    public BigDecimal nextInvertiblePositiveBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L290" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L292">        final BigDecimal decimal = nextInvertibleBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        return decimal.compareTo(BigDecimal.ZERO) &lt; 0 ? decimal.negate() : decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @see #nextNegativeBigDecimal
     * @see #nextInvertibleBigDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleNegativeBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L313" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L315">        final BigDecimal decimal = nextInvertibleBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        return decimal.compareTo(BigDecimal.ZERO) &gt; 0 ? decimal.negate() : decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @see #nextBigDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L335" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L337">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L338">        return keepBigDecimalInBound(decimal, bound).setScale(scale, RoundingMode.HALF_UP);</span>
    }

    @VisibleForTesting
    BigDecimal keepBigDecimalInBound(final BigDecimal decimal, final long bound) {
<span class="fc" id="L343">        BigDecimal result = decimal;</span>
<span class="fc" id="L344">        final BigDecimal decimalBound = BigDecimal.valueOf(bound);</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">        if (result.compareTo(BigDecimal.ZERO) &gt; -1) {</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">            while (result.compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L347">                result = result.subtract(decimalBound);</span>
            }
        } else {
<span class="fc bfc" id="L350" title="All 2 branches covered.">            while (result.abs().compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L351">                result = result.add(decimalBound);</span>
            }
        }
<span class="fc" id="L354">        return result;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive
     * {@link BigDecimal BigDecimals}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextPositiveBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextPositiveBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L378" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L381">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L382">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextPositiveBigDecimal(bound, scale)));</span>
<span class="fc" id="L383">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative
     * {@link BigDecimal BigDecimals}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextNegativeBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextNegativeBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L407" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L410">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L411">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextNegativeBigDecimal(bound, scale)));</span>
<span class="fc" id="L412">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link BigDecimal BigDecimals}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L436" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L439">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L440">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextBigDecimal(bound, scale)));</span>
<span class="fc" id="L441">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive
     * {@link BigDecimal BigDecimals} which are invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertiblePositiveBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertiblePositiveBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L465" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L468">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L469">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextInvertiblePositiveBigDecimal(bound, scale)));</span>
<span class="fc" id="L470">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative
     * {@link BigDecimal BigDecimals} which are invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleNegativeBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleNegativeBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L494" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L497">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L498">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextInvertibleNegativeBigDecimal(bound, scale)));</span>
<span class="fc" id="L499">        return decimals;</span>
    }

    /**
     * Returns a {@code List} of the size of {@code howMany} containing
     * {@link BigDecimal BigDecimals} which are invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L523" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L526">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L527">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextInvertibleBigDecimal(bound, scale)));</span>
<span class="fc" id="L528">        return decimals;</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by
     * {@code 0} (inclusive) and above by {@code
     * bound} (exclusive) and whose {@code denominator} is bounded below {@code 1}
     * (inclusive) and {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @since 1
     */
    public Fraction nextPositiveFraction(final long bound) {
<span class="fc bfc" id="L545" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L546">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L547">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L548">        return Fraction.of(numerator, denominator);</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by
     * {@code -bound} (exclusive) and above by {@code 0} (inclusive) and whose
     * {@code denominator} is bounded below {@code 1} (inclusive) and {@code bound}
     * (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @since 1
     */
    public Fraction nextNegativeFraction(final long bound) {
<span class="fc bfc" id="L565" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L566">        return nextPositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by
     * {@code -bound} (exclusive) and above by {@code bound} (exclusive) and whose
     * {@code denominator} is bounded below {@code -bound} (exclusive) and {@code
     * bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @since 1
     */
    public Fraction nextFraction(final long bound) {
<span class="fc bfc" id="L583" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">        return random.nextBoolean() ? nextNegativeFraction(bound) : nextPositiveFraction(bound);</span>
    }

    /**
     * Returns a positive {@link Fraction} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @see #nextPositiveFraction
     * @since 1
     */
    public Fraction nextInvertiblePositiveFraction(final long bound) {
<span class="fc bfc" id="L599" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L600">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L601">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L602">        return Fraction.of(numerator, denominator);</span>
    }

    /**
     * Returns a negative {@link Fraction} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @see #nextNegativeFraction
     * @since 1
     */
    public Fraction nextInvertibleNegativeFraction(final long bound) {
<span class="fc bfc" id="L617" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L618">        return nextInvertiblePositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @see #nextFraction
     * @since 1
     */
    public Fraction nextInvertibleFraction(final long bound) {
<span class="fc bfc" id="L633" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">        return random.nextBoolean() ? nextInvertibleNegativeFraction(bound) : nextInvertiblePositiveFraction(bound);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive
     * {@link Fraction Fractions}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextPositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextPositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L654" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L656">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L657">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextPositiveFraction(bound)));</span>
<span class="fc" id="L658">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative
     * {@link Fraction Fractions}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L678" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L680">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L681">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextNegativeFraction(bound)));</span>
<span class="fc" id="L682">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link Fraction Fractions}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L702" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L704">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L705">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextFraction(bound)));</span>
<span class="fc" id="L706">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive
     * {@link Fraction Fractions} which are invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertiblePositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertiblePositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L726" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L728">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L729">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextInvertiblePositiveFraction(bound)));</span>
<span class="fc" id="L730">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative
     * {@link Fraction Fractions} which are invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L750" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L752">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L753">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextInvertibleNegativeFraction(bound)));</span>
<span class="fc" id="L754">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link Fraction Fractions} which are invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L774" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L776">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L777">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextInvertibleFraction(bound)));</span>
<span class="fc" id="L778">        return fractions;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} whose {@code real} and
     * {@code imaginary} part are bounded below by {@code
     * -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public SimpleComplexNumber nextSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L795" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L796">        return SimpleComplexNumber.of(nextBigInteger(bound), nextBigInteger(bound));</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public SimpleComplexNumber nextInvertibleSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L811" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L812">        final BigInteger nonZeroPart = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L813">        final BigInteger possibleZeroPart = nextBigInteger(bound);</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">        return random.nextBoolean() ? SimpleComplexNumber.of(possibleZeroPart, nonZeroPart)</span>
<span class="fc" id="L815">            : SimpleComplexNumber.of(nonZeroPart, possibleZeroPart);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link SimpleComplexNumber SimpleComplexNumbers}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A List {@link List} of pseudo random {@link SimpleComplexNumber
     *         SimpleComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L836" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L838">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L839">        IntStream.range(0, howMany).forEach(i -&gt; complexNumbers.add(nextSimpleComplexNumber(bound)));</span>
<span class="fc" id="L840">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link SimpleComplexNumber SimpleComplexNumbers} which are invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumber
     *         SimpleComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextInvertibleSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L861" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L863">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L864">        IntStream.range(0, howMany).forEach(i -&gt; complexNumbers.add(nextInvertibleSimpleComplexNumber(bound)));</span>
<span class="fc" id="L865">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link RealComplexNumber} whose {@code real} and {@code imaginary}
     * part are bounded below by {@code
     * -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @since 1
     */
    public RealComplexNumber nextRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L883" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L885">        final BigDecimal real = nextBigDecimal(bound, scale);</span>
<span class="fc" id="L886">        final BigDecimal imaginary = nextBigDecimal(bound, scale);</span>
<span class="fc" id="L887">        return RealComplexNumber.of(real, imaginary);</span>
    }

    /**
     * Returns a {@link RealComplexNumber} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @see #nextRealComplexNumber
     * @since 1
     */
    public RealComplexNumber nextInvertibleRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L904" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L906">        final BigDecimal nonZeroPart = nextInvertibleBigDecimal(bound, scale);</span>
        final BigDecimal possibleZeroPart =
<span class="fc bfc" id="L908" title="All 2 branches covered.">            random.nextBoolean() ? nextInvertibleBigDecimal(bound, scale) : nextBigDecimal(bound, scale);</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">        return random.nextBoolean() ? RealComplexNumber.of(possibleZeroPart, nonZeroPart)</span>
<span class="fc" id="L910">            : RealComplexNumber.of(nonZeroPart, possibleZeroPart);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link RealComplexNumber RealComplexNumbers}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber
     *         RealComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextRealComplexNumbers(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L935" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L936" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L938">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L939">        IntStream.range(0, howMany).forEach(i -&gt; complexNumbers.add(nextRealComplexNumber(bound, scale)));</span>
<span class="fc" id="L940">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link RealComplexNumber RealComplexNumbers} which are invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber
     *         RealComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextInvertibleRealComplexNumbers(final long bound, final int scale,
        final int howMany) {
<span class="fc bfc" id="L966" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L968" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L969">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L970">        IntStream.range(0, howMany).forEach(i -&gt; complexNumbers.add(nextInvertibleRealComplexNumber(bound, scale)));</span>
<span class="fc" id="L971">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link PolarForm}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A {@link PolarForm}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public PolarForm nextPolarForm(final long bound, final int scale) {
<span class="fc bfc" id="L990" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L992">        return new PolarForm(nextBigDecimal(bound, scale), nextBigDecimal(bound, scale));</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link PolarForm PolarForms}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber
     *         RealComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public List&lt;PolarForm&gt; nextPolarForms(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L1017" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1019" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1020">        final List&lt;PolarForm&gt; polarForms = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1021">        IntStream.range(0, howMany).forEach(i -&gt; polarForms.add(nextPolarForm(bound, scale)));</span>
<span class="fc" id="L1022">        return polarForms;</span>
    }

    /**
     * Returns a {@link BigIntegerVector}
     *
     * @param bound
     *            the bound
     * @param size
     *            the size of the resulting {@link BigIntegerVector}
     * @return A pseudo random {@link BigIntegerVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public BigIntegerVector nextBigIntegerVector(final long bound, final int size) {
<span class="fc bfc" id="L1041" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1042" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1043">        final BigIntegerVectorBuilder builder = BigIntegerVector.builder(size);</span>
<span class="fc" id="L1044">        IntStream.rangeClosed(1, size).forEach(i -&gt; builder.put(nextBigInteger(bound)));</span>
<span class="fc" id="L1045">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link BigIntegerVector BigIntegerVectors}
     *
     * @param bound
     *            the bound
     * @param size
     *            the sizes of the resulting {@link BigIntegerVector
     *            BigIntegerVectors}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigIntegerVector
     *         BigIntegerVectors}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextBigIntegerVector
     * @since 1
     */
    public List&lt;BigIntegerVector&gt; nextBigIntegerVectors(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1070" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1071" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1072">        final List&lt;BigIntegerVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1073">        IntStream.range(0, howMany).forEach(i -&gt; vectors.add(nextBigIntegerVector(bound, size)));</span>
<span class="fc" id="L1074">        return vectors;</span>
    }

    /**
     * Returns a {@link BigIntegerMatrix}
     *
     * @param bound
     *            the bound
     * @param rowSize
     *            the row size of the resulting {@link BigIntegerMatrix}
     * @param columnSize
     *            the column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public BigIntegerMatrix nextBigIntegerMatrix(final long bound, final int rowSize, final int columnSize) {
<span class="fc bfc" id="L1097" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1098" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1099" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L1100">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L1101">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L1102">            .forEach(rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L1103">                .forEach(columnIndex -&gt; builder.put(rowIndex, columnIndex, nextBigInteger(bound))));</span>
<span class="fc" id="L1104">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link BigIntegerMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of resulting {@link BigIntegerMatrix}
     * @return A pseudo random upper triangular {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigInteger(long)
     * @see BigIntegerMatrix#upperTriangular
     * @since 1
     */
    public BigIntegerMatrix nextUpperTriangularBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1124" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1125" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1126">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1127">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1128">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1129" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 1) {</span>
<span class="fc" id="L1130">                    builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
                } else {
<span class="fc" id="L1132">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1134">            }));</span>
<span class="fc" id="L1135">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link BigIntegerMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random lower triangular {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigInteger(long)
     * @see BigIntegerMatrix#lowerTriangular
     * @since 1
     */
    public BigIntegerMatrix nextLowerTriangularBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1155" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1156" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1157">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1158">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1159">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1160" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &gt; -1) {</span>
<span class="fc" id="L1161">                    builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
                } else {
<span class="fc" id="L1163">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1165">            }));</span>
<span class="fc" id="L1166">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link BigIntegerMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random triangular {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextUpperTriangularBigIntegerMatrix
     * @see #nextLowerTriangularBigIntegerMatrix
     * @see BigIntegerMatrix#triangular
     * @since 1
     */
    public BigIntegerMatrix nextTriangularBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1187" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1188" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1189" title="All 2 branches covered.">        return random.nextBoolean() ? nextLowerTriangularBigIntegerMatrix(bound, size)</span>
<span class="fc" id="L1190">            : nextUpperTriangularBigIntegerMatrix(bound, size);</span>
    }

    /**
     * Returns a diagonal {@link BigIntegerMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random diagonal {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigIntegerMatrix#diagonal
     * @since 1
     */
    public BigIntegerMatrix nextDiagonalBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1209" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1210" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1211">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1212">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1213">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1214" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1215">                    builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
                } else {
<span class="fc" id="L1217">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1219">            }));</span>
<span class="fc" id="L1220">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link BigIntegerMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random symmetric {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigIntegerMatrix#symmetric
     * @since 1
     */
    public BigIntegerMatrix nextSymmetricBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1239" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1240" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1241">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1242">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1243">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1244">                final BigInteger element = nextBigInteger(bound);</span>
<span class="fc bfc" id="L1245" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L1246">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1247">                    builder.put(columnIndex, rowIndex, element);</span>
<span class="fc bfc" id="L1248" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1249">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L1251">            }));</span>
<span class="fc" id="L1252">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link BigIntegerMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random skew-symmetric {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigIntegerMatrix#skewSymmetric
     * @since 1
     */
    public BigIntegerMatrix nextSkewSymmetricBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1271" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1272" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1273">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1274">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1275">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1276" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L1277">                    final BigInteger element = nextBigInteger(bound);</span>
<span class="fc" id="L1278">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1279">                    builder.put(columnIndex, rowIndex, element.negate());</span>
<span class="fc bfc" id="L1280" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1281">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1283">            }));</span>
<span class="fc" id="L1284">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            the bound
     * @param rowSize
     *            the row size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param columnSize
     *            the column size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigIntegerMatrix
     *         BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextBigIntegerMatrices(final long bound, final int rowSize, final int columnSize,
        final int howMany) {
<span class="fc bfc" id="L1316" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1317" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1318" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1319" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1320">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1321">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextBigIntegerMatrix(bound, rowSize, columnSize)));</span>
<span class="fc" id="L1322">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper
     * triangular {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular
     *         {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextUpperTriangularBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextUpperTriangularBigIntegerMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L1349" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1350" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1351" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1352">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1353">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextUpperTriangularBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1354">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower
     * triangular {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular
     *         {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextLowerTriangularBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextLowerTriangularBigIntegerMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L1381" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1382" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1383" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1384">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1385">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextLowerTriangularBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1386">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular
     * {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link BigIntegerMatrix
     *         BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextTriangularBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextTriangularBigIntegerMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L1413" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1414" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1415" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1416">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1417">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextTriangularBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1418">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal
     * {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link BigIntegerMatrix
     *         BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextDiagonalBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextDiagonalBigIntegerMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1444" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1445" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1446" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1447">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1448">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextDiagonalBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1449">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric
     * {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link BigIntegerMatrix
     *         BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSymmetricBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextSymmetricBigIntegerMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1475" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1476" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1477" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1478">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1479">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSymmetricBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1480">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * skew-symmetric {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric
     *         {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextSkewSymmetricBigIntegerMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L1507" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1508" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1509" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1510">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1511">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSkewSymmetricBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1512">        return matrices;</span>
    }

    /**
     * Returns a {@link BigDecimalVector}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param size
     *            the size of the resulting {@link BigDecimalVector}
     * @return A speudo random {@link BigDecimalVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigDecimal
     * @since 1
     */
    public BigDecimalVector nextBigDecimalVector(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1535" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1536" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1537" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1538">        final BigDecimalVectorBuilder builder = BigDecimalVector.builder(size);</span>
<span class="fc" id="L1539">        IntStream.rangeClosed(1, size).forEach(i -&gt; builder.put(nextBigDecimal(bound, scale)));</span>
<span class="fc" id="L1540">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link BigDecimalVector BigDecimalVectors}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param size
     *            the size of the resulting {@link BigDecimalVector
     *            BigDecimalVectors}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimalVector
     *         BigDecimalVectors}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextBigDecimalVector
     * @since 1
     */
    public List&lt;BigDecimalVector&gt; nextBigDecimalVectors(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L1573" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1574" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1575" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1576" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1577">        final List&lt;BigDecimalVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1578">        IntStream.range(0, howMany).forEach(i -&gt; vectors.add(nextBigDecimalVector(bound, scale, size)));</span>
<span class="fc" id="L1579">        return vectors;</span>
    }

    /**
     * Returns a {@link BigDecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param rowSize
     *            the row size of the resulting {@link BigDecimalMatrix}
     * @param columnSize
     *            the column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @see #nextBigDecimal
     * @since 1
     */
    public BigDecimalMatrix nextBigDecimalMatrix(final long bound, final int scale, final int rowSize,
        final int columnSize) {
<span class="fc bfc" id="L1607" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1608" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1609" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1610" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L1611">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L1612">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L1613">            .forEach(rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L1614">                .forEach(columnIndex -&gt; builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale))));</span>
<span class="fc" id="L1615">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link BigDecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of resulting {@link BigDecimalMatrix}
     * @return A pseudo random upper triangular {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigDecimal
     * @see BigDecimalMatrix#upperTriangular
     * @since 1
     */
    public BigDecimalMatrix nextUpperTriangularBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1639" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1640" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1641">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1642">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1643">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1644" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 1) {</span>
<span class="fc" id="L1645">                    builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1647">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1649">            }));</span>
<span class="fc" id="L1650">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link BigDecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random lower triangular {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigDecimal
     * @see BigDecimalMatrix#lowerTriangular
     * @since 1
     */
    public BigDecimalMatrix nextLowerTriangularBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1674" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1675" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1676">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1677">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1678">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1679" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &gt; -1) {</span>
<span class="fc" id="L1680">                    builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1682">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1684">            }));</span>
<span class="fc" id="L1685">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link BigDecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random triangular {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextUpperTriangularBigDecimalMatrix
     * @see #nextLowerTriangularBigDecimalMatrix
     * @see BigDecimalMatrix#triangular
     * @since 1
     */
    public BigDecimalMatrix nextTriangularBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1710" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1711" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1712" title="All 2 branches covered.">        return random.nextBoolean() ? nextLowerTriangularBigDecimalMatrix(bound, scale, size)</span>
<span class="fc" id="L1713">            : nextUpperTriangularBigDecimalMatrix(bound, scale, size);</span>
    }

    /**
     * Returns a diagonal {@link BigDecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random diagonal {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigDecimalMatrix#diagonal
     * @since 1
     */
    public BigDecimalMatrix nextDiagonalBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1736" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1737" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1738">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1739">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1740">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1741" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1742">                    builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1744">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1746">            }));</span>
<span class="fc" id="L1747">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link BigDecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random symmetric {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigDecimalMatrix#symmetric
     * @since 1
     */
    public BigDecimalMatrix nextSymmetricBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1770" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1771" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1772">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1773">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1774">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1775">                final BigDecimal element = nextBigDecimal(bound, scale);</span>
<span class="fc bfc" id="L1776" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L1777">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1778">                    builder.put(columnIndex, rowIndex, element);</span>
<span class="fc bfc" id="L1779" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1780">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L1782">            }));</span>
<span class="fc" id="L1783">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link BigDecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random skew-symmetric {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigDecimalMatrix#skewSymmetric
     * @since 1
     */
    public BigDecimalMatrix nextSkewSymmetricBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1806" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1807" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1808">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1809">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1810">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1811" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L1812">                    final BigDecimal element = nextBigDecimal(bound, scale);</span>
<span class="fc" id="L1813">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1814">                    builder.put(columnIndex, rowIndex, element.negate());</span>
<span class="fc bfc" id="L1815" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1816">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1818">            }));</span>
<span class="fc" id="L1819">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param rowSize
     *            the row size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param columnSize
     *            the column size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimalMatrix
     *         BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextBigDecimalMatrices(final long bound, final int scale, final int rowSize,
        final int columnSize, final int howMany) {
<span class="fc bfc" id="L1855" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1856" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1857" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1858" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1859" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1860">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1861">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextBigDecimalMatrix(bound, scale, rowSize, columnSize)));</span>
<span class="fc" id="L1862">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper
     * triangular {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular
     *         {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextUpperTriangularBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextUpperTriangularBigDecimalMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L1893" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1894" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1895" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1896" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1897">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1898">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextUpperTriangularBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L1899">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower
     * triangular {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular
     *         {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextLowerTriangularBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextLowerTriangularBigDecimalMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L1930" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1931" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1932" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1933" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1934">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1935">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextLowerTriangularBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L1936">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular
     * {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link BigDecimalMatrix
     *         BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextTriangularBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextTriangularBigDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L1967" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1968" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1969" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1970" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1971">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1972">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextTriangularBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L1973">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal
     * {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link BigDecimalMatrix
     *         BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextDiagonalBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextDiagonalBigDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2004" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2005" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2006" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2007" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2008">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2009">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextDiagonalBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L2010">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric
     * {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link BigDecimalMatrix
     *         BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSymmetricBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextSymmetricBigDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2041" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2042" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2043" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2044" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2045">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2046">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSymmetricBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L2047">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * skew-symmetric {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric
     *         {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextSkewSymmetricBigDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2078" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2079" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2080" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2081" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2082">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2083">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSkewSymmetricBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L2084">        return matrices;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumberVector}
     *
     * @param bound
     *            the bound
     * @param size
     *            the size of the resulting {@link SimpleComplexNumberVector}
     * @return A pseudo random {@link SimpleComplexNumberVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextSimpleComplexNumber(long)
     * @since 1
     */
    public SimpleComplexNumberVector nextSimpleComplexNumberVector(final long bound, final int size) {
<span class="fc bfc" id="L2103" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2104" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2105">        final SimpleComplexNumberVector.SimpleComplexNumberVectorBuilder builder =</span>
<span class="fc" id="L2106">            SimpleComplexNumberVector.builder(size);</span>
<span class="fc" id="L2107">        IntStream.rangeClosed(1, size).forEach(i -&gt; builder.put(nextSimpleComplexNumber(bound)));</span>
<span class="fc" id="L2108">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link SimpleComplexNumberVector SimpleComplexNumberVectors}
     *
     * @param bound
     *            the bound
     * @param size
     *            the sizes of the resulting {@link SimpleComplexNumberVector
     *            SimpleComplexNumberVectors}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumberVector
     *         SimpleComplexNumberVectors}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextSimpleComplexNumberVector
     * @since 1
     */
    public List&lt;SimpleComplexNumberVector&gt; nextSimpleComplexNumberVectors(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L2133" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2134" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2135" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2136">        final List&lt;SimpleComplexNumberVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2137">        IntStream.range(0, howMany).forEach(i -&gt; vectors.add(nextSimpleComplexNumberVector(bound, size)));</span>
<span class="fc" id="L2138">        return vectors;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param rowSize
     *            the row size of the resulting {@link SimpleComplexNumberMatrix}
     * @param columnSize
     *            the column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @see #nextSimpleComplexNumber(long)
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSimpleComplexNumberMatrix(final long bound, final int rowSize,
        final int columnSize) {
<span class="fc bfc" id="L2162" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2163" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2164" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L2165">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L2166">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L2167">            .forEach(rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L2168">                .forEach(columnIndex -&gt; builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound))));</span>
<span class="fc" id="L2169">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of resulting
     *            {@link SimpleComplexNumberMatrix}
     * @return A pseudo random upper triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#upperTriangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextUpperTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2189" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2190" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2191">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2192">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2193">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2194" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 1) {</span>
<span class="fc" id="L2195">                    builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                } else {
<span class="fc" id="L2197">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2199">            }));</span>
<span class="fc" id="L2200">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix}
     * @return A pseudo random lower triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#lowerTriangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextLowerTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2220" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2221" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2222">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2223">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2224">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2225" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &gt; -1) {</span>
<span class="fc" id="L2226">                    builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                } else {
<span class="fc" id="L2228">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2230">            }));</span>
<span class="fc" id="L2231">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix}
     * @return A pseudo random triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextUpperTriangularSimpleComplexNumberMatrix
     * @see #nextLowerTriangularSimpleComplexNumberMatrix
     * @see SimpleComplexNumberMatrix#triangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2253" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2254" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2255" title="All 2 branches covered.">        return random.nextBoolean() ? nextLowerTriangularSimpleComplexNumberMatrix(bound, size)</span>
<span class="fc" id="L2256">            : nextUpperTriangularSimpleComplexNumberMatrix(bound, size);</span>
    }

    /**
     * Returns a diagonal {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix}
     * @return A pseudo random diagonal {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#diagonal
     * @since 1
     */
    public SimpleComplexNumberMatrix nextDiagonalSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2276" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2277" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2278">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2279">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2280">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2281" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2282">                    builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                } else {
<span class="fc" id="L2284">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2286">            }));</span>
<span class="fc" id="L2287">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix}
     * @return A pseudo random symmetric {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#symmetric
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSymmetricSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2307" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2308" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2309">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2310">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2311">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L2312">                final SimpleComplexNumber element = nextSimpleComplexNumber(bound);</span>
<span class="fc bfc" id="L2313" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L2314">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2315">                    builder.put(columnIndex, rowIndex, element);</span>
<span class="fc bfc" id="L2316" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2317">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L2319">            }));</span>
<span class="fc" id="L2320">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix}
     * @return A pseudo random skew-symmetric {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#skewSymmetric
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSkewSymmetricSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2340" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2341" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2342">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2343">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2344">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2345" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L2346">                    final SimpleComplexNumber element = nextSimpleComplexNumber(bound);</span>
<span class="fc" id="L2347">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2348">                    builder.put(columnIndex, rowIndex, element.negate());</span>
<span class="fc bfc" id="L2349" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2350">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2352">            }));</span>
<span class="fc" id="L2353">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param rowSize
     *            the row size of the resulting {@link SimpleComplexNumberMatrix
     *            SimpleComplexNumberMatrices}
     * @param columnSize
     *            the column size of the resulting {@link SimpleComplexNumberMatrix
     *            SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumberMatrix
     *         SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSimpleComplexNumberMatrices(final long bound, final int rowSize,
        final int columnSize, final int howMany) {
<span class="fc bfc" id="L2385" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2386" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2387" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L2388" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2389">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2390">        IntStream.range(0, howMany)</span>
<span class="fc" id="L2391">            .forEach(i -&gt; matrices.add(nextSimpleComplexNumberMatrix(bound, rowSize, columnSize)));</span>
<span class="fc" id="L2392">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper
     * triangular {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextUpperTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextUpperTriangularSimpleComplexNumberMatrices(final long bound,
        final int size, final int howMany) {
<span class="fc bfc" id="L2419" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2420" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2421" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2422">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2423">        IntStream.range(0, howMany)</span>
<span class="fc" id="L2424">            .forEach(i -&gt; matrices.add(nextUpperTriangularSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2425">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower
     * triangular {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextLowerTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextLowerTriangularSimpleComplexNumberMatrices(final long bound,
        final int size, final int howMany) {
<span class="fc bfc" id="L2452" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2453" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2454" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2455">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2456">        IntStream.range(0, howMany)</span>
<span class="fc" id="L2457">            .forEach(i -&gt; matrices.add(nextLowerTriangularSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2458">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextTriangularSimpleComplexNumberMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L2485" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2486" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2487" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2488">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2489">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextTriangularSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2490">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextDiagonalSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextDiagonalSimpleComplexNumberMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L2517" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2518" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2519" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2520">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2521">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextDiagonalSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2522">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSymmetricSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSymmetricSimpleComplexNumberMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L2549" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2550" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2551" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2552">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2553">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSymmetricSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2554">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * skew-symmetric {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSkewSymmetricSimpleComplexNumberMatrices(final long bound,
        final int size, final int howMany) {
<span class="fc bfc" id="L2581" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2582" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2583" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2584">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2585">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSkewSymmetricSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2586">        return matrices;</span>
    }

    /**
     * Returns a {@link RealComplexNumberVector}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the size of the resulting {@link RealComplexNumberVector}
     * @return A pseudo random {@link RealComplexNumberVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @since 1
     */
    public RealComplexNumberVector nextRealComplexNumberVector(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L2609" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2610" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2611" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2612">        final RealComplexNumberVectorBuilder builder = RealComplexNumberVector.builder(size);</span>
<span class="fc" id="L2613">        IntStream.rangeClosed(1, size).forEach(i -&gt; builder.put(nextRealComplexNumber(bound, scale)));</span>
<span class="fc" id="L2614">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link RealComplexNumberVector RealComplexNumberVectors}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the sizes of the resulting {@link RealComplexNumberVector
     *            RealComplexNumberVectors}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumberVector
     *         RealComplexNumberVectors}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextRealComplexNumberVector
     * @since 1
     */
    public List&lt;RealComplexNumberVector&gt; nextRealComplexNumberVectors(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2643" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2644" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2645" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2646" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2647">        final List&lt;RealComplexNumberVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2648">        IntStream.range(0, howMany).forEach(i -&gt; vectors.add(nextRealComplexNumberVector(bound, scale, size)));</span>
<span class="fc" id="L2649">        return vectors;</span>
    }

    /**
     * Returns a {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param rowSize
     *            the row size of the resulting {@link RealComplexNumberMatrix}
     * @param columnSize
     *            the column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @since 1
     */
    public RealComplexNumberMatrix nextRealComplexNumberMatrix(final long bound, final int scale, final int rowSize,
        final int columnSize) {
<span class="fc bfc" id="L2677" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2678" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2679" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2680" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L2681">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L2682">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L2683">            .forEach(rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L2684">                .forEach(columnIndex -&gt; builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale))));</span>
<span class="fc" id="L2685">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of resulting
     *            {@link RealComplexNumberMatrix}
     * @return A pseudo random upper triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @see RealComplexNumberMatrix#upperTriangular
     * @since 1
     */
    public RealComplexNumberMatrix nextUpperTriangularRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2711" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2712" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2713" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2714">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2715">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2716">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2717" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 1) {</span>
<span class="fc" id="L2718">                    builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                } else {
<span class="fc" id="L2720">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2722">            }));</span>
<span class="fc" id="L2723">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix}
     * @return A pseudo random lower triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @see RealComplexNumberMatrix#lowerTriangular
     * @since 1
     */
    public RealComplexNumberMatrix nextLowerTriangularRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2749" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2750" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2751" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2752">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2753">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2754">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2755" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &gt; -1) {</span>
<span class="fc" id="L2756">                    builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                } else {
<span class="fc" id="L2758">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2760">            }));</span>
<span class="fc" id="L2761">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix}
     * @return A pseudo random triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextUpperTriangularRealComplexNumberMatrix
     * @see #nextLowerTriangularRealComplexNumberMatrix
     * @see RealComplexNumberMatrix#triangular
     * @since 1
     */
    public RealComplexNumberMatrix nextTriangularRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2788" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2789" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2790" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2791" title="All 2 branches covered.">        return random.nextBoolean() ? nextLowerTriangularRealComplexNumberMatrix(bound, scale, size)</span>
<span class="fc" id="L2792">            : nextUpperTriangularRealComplexNumberMatrix(bound, scale, size);</span>
    }

    /**
     * Returns a diagonal {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix}
     * @return A pseudo random diagonal {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see RealComplexNumberMatrix#diagonal
     * @since 1
     */
    public RealComplexNumberMatrix nextDiagonalRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2817" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2818" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2819" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2820">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2821">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2822">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2823" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2824">                    builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                } else {
<span class="fc" id="L2826">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2828">            }));</span>
<span class="fc" id="L2829">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix}
     * @return A pseudo random symmetric {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see RealComplexNumberMatrix#symmetric
     * @since 1
     */
    public RealComplexNumberMatrix nextSymmetricRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2854" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2855" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2856" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2857">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2858">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2859">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L2860">                final RealComplexNumber element = nextRealComplexNumber(bound, scale);</span>
<span class="fc bfc" id="L2861" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L2862">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2863">                    builder.put(columnIndex, rowIndex, element);</span>
<span class="fc bfc" id="L2864" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2865">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L2867">            }));</span>
<span class="fc" id="L2868">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix}
     * @return A pseudo random skew-symmetric {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see RealComplexNumberMatrix#skewSymmetric
     * @since 1
     */
    public RealComplexNumberMatrix nextSkewSymmetricRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2893" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2894" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2895" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2896">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2897">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2898">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2899" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L2900">                    final RealComplexNumber element = nextRealComplexNumber(bound, scale);</span>
<span class="fc" id="L2901">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2902">                    builder.put(columnIndex, rowIndex, element.negate());</span>
<span class="fc bfc" id="L2903" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2904">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2906">            }));</span>
<span class="fc" id="L2907">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param rowSize
     *            the row size of the resulting {@link RealComplexNumberMatrix
     *            RealComplexNumberMatrices}
     * @param columnSize
     *            the column size of the resulting {@link RealComplexNumberMatrix
     *            RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumberMatrix
     *         RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextRealComplexNumberMatrices(final long bound, final int scale,
        final int rowSize, final int columnSize, final int howMany) {
<span class="fc bfc" id="L2943" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2944" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2945" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2946" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L2947" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2948">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2949">        IntStream.range(0, howMany)</span>
<span class="fc" id="L2950">            .forEach(i -&gt; matrices.add(nextRealComplexNumberMatrix(bound, scale, rowSize, columnSize)));</span>
<span class="fc" id="L2951">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper
     * triangular {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextUpperTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextUpperTriangularRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L2982" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2983" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2984" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2985" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2986">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2987">        IntStream.range(0, howMany)</span>
<span class="fc" id="L2988">            .forEach(i -&gt; matrices.add(nextUpperTriangularRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L2989">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower
     * triangular {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextLowerTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextLowerTriangularRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L3020" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3021" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3022" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3023" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3024">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L3025">        IntStream.range(0, howMany)</span>
<span class="fc" id="L3026">            .forEach(i -&gt; matrices.add(nextLowerTriangularRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L3027">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular
     * {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextTriangularRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L3058" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3059" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3060" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3061" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3062">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L3063">        IntStream.range(0, howMany)</span>
<span class="fc" id="L3064">            .forEach(i -&gt; matrices.add(nextTriangularRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L3065">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal
     * {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextDiagonalRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextDiagonalRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L3096" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3097" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3098" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3099" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3100">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L3101">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextDiagonalRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L3102">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric
     * {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSymmetricRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextSymmetricRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L3133" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3134" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3135" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3136" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3137">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L3138">        IntStream.range(0, howMany)</span>
<span class="fc" id="L3139">            .forEach(i -&gt; matrices.add(nextSymmetricRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L3140">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * skew-symmetric {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextSkewSymmetricRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L3171" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3172" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3173" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3174" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3175">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L3176">        IntStream.range(0, howMany)</span>
<span class="fc" id="L3177">            .forEach(i -&gt; matrices.add(nextSkewSymmetricRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L3178">        return matrices;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L3183">        return MoreObjects.toStringHelper(this).add(&quot;random&quot;, random).toString();</span>
    }

    @VisibleForTesting
    Random getRandom() {
<span class="fc" id="L3188">        return random;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>