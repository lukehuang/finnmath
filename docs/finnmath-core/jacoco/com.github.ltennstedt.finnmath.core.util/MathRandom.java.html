<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MathRandom.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">finnMath Core</a> &gt; <a href="index.source.html" class="el_package">com.github.ltennstedt.finnmath.core.util</a> &gt; <span class="el_source">MathRandom.java</span></div><h1>MathRandom.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017 Lars Tennstedt
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.ltennstedt.finnmath.core.util;

import static com.google.common.base.Preconditions.checkArgument;

import com.github.ltennstedt.finnmath.core.linear.BigDecimalMatrix;
import com.github.ltennstedt.finnmath.core.linear.BigDecimalMatrix.BigDecimalMatrixBuilder;
import com.github.ltennstedt.finnmath.core.linear.BigDecimalVector;
import com.github.ltennstedt.finnmath.core.linear.BigDecimalVector.BigDecimalVectorBuilder;
import com.github.ltennstedt.finnmath.core.linear.BigIntegerMatrix;
import com.github.ltennstedt.finnmath.core.linear.BigIntegerVector;
import com.github.ltennstedt.finnmath.core.linear.BigIntegerVector.BigIntegerVectorBuilder;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberMatrix;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberMatrix.RealComplexNumberMatrixBuilder;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberVector;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberVector.RealComplexNumberVectorBuilder;
import com.github.ltennstedt.finnmath.core.linear.SimpleComplexNumberMatrix;
import com.github.ltennstedt.finnmath.core.linear.SimpleComplexNumberMatrix.SimpleComplexNumberMatrixBuilder;
import com.github.ltennstedt.finnmath.core.linear.SimpleComplexNumberVector;
import com.github.ltennstedt.finnmath.core.number.Fraction;
import com.github.ltennstedt.finnmath.core.number.PolarForm;
import com.github.ltennstedt.finnmath.core.number.RealComplexNumber;
import com.github.ltennstedt.finnmath.core.number.SimpleComplexNumber;
import com.google.common.annotations.Beta;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.apache.commons.lang3.RandomUtils;

/**
 * A pseudo random generator for {@code long}, {@link BigDecimal}, {@link Fraction}, {@link SimpleComplexNumber}, {@link
 * RealComplexNumber}, {@link BigIntegerVector}, {@link BigDecimalVector}, {@link BigIntegerMatrix} and {@link
 * BigDecimalMatrix}
 *
 * @author Lars Tennstedt
 * @since 1
 */
@Beta
public final class MathRandom {
    private final Random random;

    /**
     * Default constructor
     *
     * @since 1
     */
<span class="fc" id="L69">    public MathRandom() {</span>
<span class="fc" id="L70">        random = new Random();</span>
<span class="fc" id="L71">    }</span>

    /**
     * Constructor which has the seed value as parameter
     *
     * @param seed
     *         The seed
     * @since 1
     */
<span class="fc" id="L80">    public MathRandom(final long seed) {</span>
<span class="fc" id="L81">        random = new Random(seed);</span>
<span class="fc" id="L82">    }</span>

    /**
     * Returns a positive {@link BigInteger} bounded below by {@code 0} (inclusive) and above by {@code bound}
     * (exclusive)
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link BigInteger}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @since 1
     */
    public BigInteger nextPositiveBigInteger(final long bound) {
<span class="fc bfc" id="L96" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L97">        return BigInteger.valueOf(RandomUtils.nextLong(0, bound));</span>
    }

    /**
     * Returns a negative {@link BigInteger} bounded below by {@code -bound} (exclusive) and above by {@code 0}
     * (inclusive)
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link BigInteger}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @see #nextPositiveBigInteger(long)
     * @since 1
     */
    public BigInteger nextNegativeBigInteger(final long bound) {
<span class="fc bfc" id="L113" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L114">        return nextPositiveBigInteger(bound).negate();</span>
    }

    /**
     * Returns a {@link BigInteger} bounded below by {@code -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link BigInteger}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @see #nextPositiveBigInteger(long)
     * @see #nextNegativeBigInteger(long)
     * @since 1
     */
    public BigInteger nextBigInteger(final long bound) {
<span class="fc bfc" id="L130" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L132">            return nextNegativeBigInteger(bound);</span>
        }
<span class="fc" id="L134">        return nextPositiveBigInteger(bound);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link BigInteger BigIntegers}
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigInteger BigIntegers}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextPositiveBigInteger(long)
     * @since 1
     */
    public List&lt;BigInteger&gt; nextPositiveBigIntegers(final long bound, final int howMany) {
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L155">        final List&lt;BigInteger&gt; integers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L157">            integers.add(nextPositiveBigInteger(bound));</span>
        }
<span class="fc" id="L159">        return integers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link BigInteger BigIntegers}
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigInteger BigIntegers}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextNegativeBigInteger(long)
     * @since 1
     */
    public List&lt;BigInteger&gt; nextNegativeBigIntegers(final long bound, final int howMany) {
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L180">        final List&lt;BigInteger&gt; integers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L182">            integers.add(nextNegativeBigInteger(bound));</span>
        }
<span class="fc" id="L184">        return integers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigInteger BigIntegers}
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigInteger BigIntegers}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public List&lt;BigInteger&gt; nextBigIntegers(final long bound, final int howMany) {
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L205">        final List&lt;BigInteger&gt; integers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L207">            integers.add(nextBigInteger(bound));</span>
        }
<span class="fc" id="L209">        return integers;</span>
    }

    /**
     * Returns a positive {@link BigDecimal} of a given {@code scale} bounded below by {@code 0} (inclusive) and above
     * by {@code bound} (exclusive)
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @since 1
     */
    public BigDecimal nextPositiveBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L228" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L230">        final BigDecimal decimal = nextBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &lt; 0) {</span>
<span class="nc" id="L232">            return decimal.negate();</span>
        }
<span class="fc" id="L234">        return decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} of a given {@code scale} bounded below by {@code -bound} (exclusive) and
     * above by {@code 0} (inclusive)
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @since 1
     */
    public BigDecimal nextNegativeBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L253" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L255">        final BigDecimal decimal = nextBigDecimal(bound, scale);</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (decimal.compareTo(BigDecimal.ZERO) &gt; 0) {</span>
<span class="fc" id="L257">            return decimal.negate();</span>
        }
<span class="fc" id="L259">        return decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} of a given {@code scale} bounded below by {@code -bound} (exclusive) and above by
     * {@code bound} (exclusive)
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @since 1
     */
    public BigDecimal nextBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L278" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L280">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L281">        return keepBigDecimalInBound(decimal, bound).setScale(scale, RoundingMode.HALF_UP);</span>
    }

    /**
     * Returns a positive {@link BigDecimal} which is invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @see #nextPositiveBigDecimal
     * @since 1
     */
    public BigDecimal nextInvertiblePositiveBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L300" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L302">        final BigDecimal decimal = nextInvertibleBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &lt; 0) {</span>
<span class="nc" id="L304">            return decimal.negate();</span>
        }
<span class="fc" id="L306">        return decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} which is invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @see #nextNegativeBigDecimal
     * @see #nextInvertibleBigDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleNegativeBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L326" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L328">        final BigDecimal decimal = nextInvertibleBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &gt; 0) {</span>
<span class="fc" id="L330">            return decimal.negate();</span>
        }
<span class="nc" id="L332">        return decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} which is invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @see #nextBigDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L351" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L353">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L354">        return keepBigDecimalInBound(decimal, bound).setScale(scale, RoundingMode.HALF_UP);</span>
    }

    @VisibleForTesting
    BigDecimal keepBigDecimalInBound(final BigDecimal decimal, final long bound) {
<span class="fc" id="L359">        BigDecimal result = decimal;</span>
<span class="fc" id="L360">        final BigDecimal decimalBound = BigDecimal.valueOf(bound);</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (result.compareTo(BigDecimal.ZERO) &gt; -1) {</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">            while (result.compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L363">                result = result.subtract(decimalBound);</span>
            }
        } else {
<span class="fc bfc" id="L366" title="All 2 branches covered.">            while (result.abs().compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L367">                result = result.add(decimalBound);</span>
            }
        }
<span class="fc" id="L370">        return result;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link BigDecimal BigDecimals}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextPositiveBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextPositiveBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L393" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L396">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L398">            decimals.add(nextPositiveBigDecimal(bound, scale));</span>
        }
<span class="fc" id="L400">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link BigDecimal BigDecimals}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextNegativeBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextNegativeBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L423" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L426">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L428">            decimals.add(nextNegativeBigDecimal(bound, scale));</span>
        }
<span class="fc" id="L430">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigDecimal BigDecimals}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L453" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L456">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L458">            decimals.add(nextBigDecimal(bound, scale));</span>
        }
<span class="fc" id="L460">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link BigDecimal BigDecimals} which
     * are invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertiblePositiveBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertiblePositiveBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L484" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L487">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L489">            decimals.add(nextInvertiblePositiveBigDecimal(bound, scale));</span>
        }
<span class="fc" id="L491">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link BigDecimal BigDecimals} which
     * are invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertibleNegativeBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleNegativeBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L515" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L518">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L520">            decimals.add(nextInvertibleNegativeBigDecimal(bound, scale));</span>
        }
<span class="fc" id="L522">        return decimals;</span>
    }

    /**
     * Returns a {@code List} of the size of {@code howMany} containing {@link BigDecimal BigDecimals} which are
     * invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertibleBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L546" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L549">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L551">            decimals.add(nextInvertibleBigDecimal(bound, scale));</span>
        }
<span class="fc" id="L553">        return decimals;</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by {@code 0} (inclusive) and above by {@code
     * bound} (exclusive) and whose {@code denominator} is bounded below {@code 1} (inclusive) and {@code bound}
     * (exclusive)
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @since 1
     */
    public Fraction nextPositiveFraction(final long bound) {
<span class="fc bfc" id="L569" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L570">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L571">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L572">        return new Fraction(numerator, denominator);</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by {@code -bound} (exclusive) and above by
     * {@code 0} (inclusive) and whose {@code denominator} is bounded below {@code 1} (inclusive) and {@code bound}
     * (exclusive)
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @since 1
     */
    public Fraction nextNegativeFraction(final long bound) {
<span class="fc bfc" id="L588" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L589">        return nextPositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by {@code -bound} (exclusive) and above by
     * {@code bound} (exclusive) and whose {@code denominator} is bounded below {@code -bound} (exclusive) and {@code
     * bound} (exclusive)
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @since 1
     */
    public Fraction nextFraction(final long bound) {
<span class="fc bfc" id="L605" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L607">            return nextNegativeFraction(bound);</span>
        }
<span class="fc" id="L609">        return nextPositiveFraction(bound);</span>
    }

    /**
     * Returns a positive {@link Fraction} which is invertible
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @see #nextPositiveFraction
     * @since 1
     */
    public Fraction nextInvertiblePositiveFraction(final long bound) {
<span class="fc bfc" id="L624" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L625">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L626">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L627">        return new Fraction(numerator, denominator);</span>
    }

    /**
     * Returns a negative {@link Fraction} which is invertible
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @see #nextNegativeFraction
     * @since 1
     */
    public Fraction nextInvertibleNegativeFraction(final long bound) {
<span class="fc bfc" id="L642" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L643">        return nextInvertiblePositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} which is invertible
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @see #nextFraction
     * @since 1
     */
    public Fraction nextInvertibleFraction(final long bound) {
<span class="fc bfc" id="L658" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L660">            return nextInvertibleNegativeFraction(bound);</span>
        }
<span class="fc" id="L662">        return nextInvertiblePositiveFraction(bound);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link Fraction Fractions}
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextPositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextPositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L681" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L683">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L685">            fractions.add(nextPositiveFraction(bound));</span>
        }
<span class="fc" id="L687">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link Fraction Fractions}
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L706" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L708">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L710">            fractions.add(nextNegativeFraction(bound));</span>
        }
<span class="fc" id="L712">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link Fraction Fractions}
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L731" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L733">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L735">            fractions.add(nextFraction(bound));</span>
        }
<span class="fc" id="L737">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link Fraction Fractions} which are
     * invertible
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertiblePositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertiblePositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L757" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L759">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L761">            fractions.add(nextInvertiblePositiveFraction(bound));</span>
        }
<span class="fc" id="L763">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link Fraction Fractions} which are
     * invertible
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertibleNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L783" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L785">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L787">            fractions.add(nextInvertibleNegativeFraction(bound));</span>
        }
<span class="fc" id="L789">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link Fraction Fractions} which are invertible
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertibleFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L808" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L810">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L812">            fractions.add(nextInvertibleFraction(bound));</span>
        }
<span class="fc" id="L814">        return fractions;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} whose {@code real} and {@code imaginary} part are bounded below by {@code
     * -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public SimpleComplexNumber nextSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L830" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L831">        return new SimpleComplexNumber(nextBigInteger(bound), nextBigInteger(bound));</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} which is invertible
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public SimpleComplexNumber nextInvertibleSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L846" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L847">        final BigInteger nonZeroPart = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L848">        final BigInteger possibleZeroPart = nextBigInteger(bound);</span>
<span class="fc bfc" id="L849" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L850">            return new SimpleComplexNumber(possibleZeroPart, nonZeroPart);</span>
        }
<span class="fc" id="L852">        return new SimpleComplexNumber(nonZeroPart, possibleZeroPart);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumber
     * SimpleComplexNumbers}
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A List {@link List} of pseudo random {@link SimpleComplexNumber SimpleComplexNumbers}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L872" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L873" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L874">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L875" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L876">            complexNumbers.add(nextSimpleComplexNumber(bound));</span>
        }
<span class="fc" id="L878">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumber SimpleComplexNumbers}
     * which are invertible
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumber SimpleComplexNumbers}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertibleSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextInvertibleSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L898" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L900">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L902">            complexNumbers.add(nextInvertibleSimpleComplexNumber(bound));</span>
        }
<span class="fc" id="L904">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link RealComplexNumber} whose {@code real} and {@code imaginary} part are bounded below by {@code
     * -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @since 1
     */
    public RealComplexNumber nextRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L921" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L922" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L923">        final BigDecimal real = nextBigDecimal(bound, scale);</span>
<span class="fc" id="L924">        final BigDecimal imaginary = nextBigDecimal(bound, scale);</span>
<span class="fc" id="L925">        return new RealComplexNumber(real, imaginary);</span>
    }

    /**
     * Returns a {@link RealComplexNumber} which is invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @see #nextRealComplexNumber
     * @since 1
     */
    public RealComplexNumber nextInvertibleRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L942" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L944">        final BigDecimal nonZeroPart = nextInvertibleBigDecimal(bound, scale);</span>
        final BigDecimal possibleZeroPart =
<span class="fc bfc" id="L946" title="All 2 branches covered.">                random.nextBoolean() ? nextInvertibleBigDecimal(bound, scale) : nextBigDecimal(bound, scale);</span>
<span class="fc bfc" id="L947" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L948">            return new RealComplexNumber(possibleZeroPart, nonZeroPart);</span>
        }
<span class="fc" id="L950">        return new RealComplexNumber(nonZeroPart, possibleZeroPart);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumber RealComplexNumbers}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber RealComplexNumbers}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextRealComplexNumbers(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L973" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L974" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L976">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L977" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L978">            complexNumbers.add(nextRealComplexNumber(bound, scale));</span>
        }
<span class="fc" id="L980">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumber RealComplexNumbers}
     * which are invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber RealComplexNumbers}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextInvertibleRealComplexNumbers(final long bound, final int scale,
            final int howMany) {
<span class="fc bfc" id="L1005" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1008">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1009" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1010">            complexNumbers.add(nextInvertibleRealComplexNumber(bound, scale));</span>
        }
<span class="fc" id="L1012">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link PolarForm}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A {@link PolarForm}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public PolarForm nextPolarForm(final long bound, final int scale) {
<span class="fc bfc" id="L1031" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1032" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L1033">        return new PolarForm(nextBigDecimal(bound, scale), nextBigDecimal(bound, scale));</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link PolarForm PolarForms}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber RealComplexNumbers}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public List&lt;PolarForm&gt; nextPolarForms(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L1056" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1057" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1058" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1059">        final List&lt;PolarForm&gt; polarForms = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1060" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1061">            polarForms.add(nextPolarForm(bound, scale));</span>
        }
<span class="fc" id="L1063">        return polarForms;</span>
    }

    /**
     * Returns a {@link BigIntegerVector}
     *
     * @param bound
     *         the bound
     * @param size
     *         the size of the resulting {@link BigIntegerVector}
     * @return A pseudo random {@link BigIntegerVector}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public BigIntegerVector nextBigIntegerVector(final long bound, final int size) {
<span class="fc bfc" id="L1082" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1084">        final BigIntegerVectorBuilder builder = BigIntegerVector.builder(size);</span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1086">            builder.put(nextBigInteger(bound));</span>
        }
<span class="fc" id="L1088">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigIntegerVector BigIntegerVectors}
     *
     * @param bound
     *         the bound
     * @param size
     *         the sizes of the resulting {@link BigIntegerVector BigIntegerVectors}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigIntegerVector BigIntegerVectors}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextBigIntegerVector
     * @since 1
     */
    public List&lt;BigIntegerVector&gt; nextBigIntegerVectors(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1109" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1110" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1111" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1112">        final List&lt;BigIntegerVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1113" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1114">            vectors.add(nextBigIntegerVector(bound, size));</span>
        }
<span class="fc" id="L1116">        return vectors;</span>
    }

    /**
     * Returns a {@link BigIntegerMatrix}
     *
     * @param bound
     *         the bound
     * @param rowSize
     *         the row size of the resulting {@link BigIntegerMatrix}
     * @param columnSize
     *         the column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public BigIntegerMatrix nextBigIntegerMatrix(final long bound, final int rowSize, final int columnSize) {
<span class="fc bfc" id="L1139" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1140" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1141" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L1142">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L1143">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1144">            IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1145">                builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
<span class="fc" id="L1146">            });</span>
<span class="fc" id="L1147">        });</span>
<span class="fc" id="L1148">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link BigIntegerMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of resulting {@link BigIntegerMatrix}
     * @return A pseudo random upper triangular {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextBigInteger(long)
     * @see BigIntegerMatrix#upperTriangular
     * @since 1
     */
    public BigIntegerMatrix nextUpperTriangularBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1168" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1169" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1170">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1171">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1172">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1173" title="All 2 branches covered.">                if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L1174">                    builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
                } else {
<span class="fc" id="L1176">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1178">            });</span>
<span class="fc" id="L1179">        });</span>
<span class="fc" id="L1180">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link BigIntegerMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random lower triangular {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextBigInteger(long)
     * @see BigIntegerMatrix#lowerTriangular
     * @since 1
     */
    public BigIntegerMatrix nextLowerTriangularBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1200" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1201" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1202">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1203">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1204">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1205" title="All 2 branches covered.">                if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L1206">                    builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
                } else {
<span class="fc" id="L1208">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1210">            });</span>
<span class="fc" id="L1211">        });</span>
<span class="fc" id="L1212">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link BigIntegerMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random triangular {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextUpperTriangularBigIntegerMatrix
     * @see #nextLowerTriangularBigIntegerMatrix
     * @see BigIntegerMatrix#triangular
     * @since 1
     */
    public BigIntegerMatrix nextTriangularBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1233" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1234" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1235" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L1236">            return nextLowerTriangularBigIntegerMatrix(bound, size);</span>
        }
<span class="fc" id="L1238">        return nextUpperTriangularBigIntegerMatrix(bound, size);</span>
    }

    /**
     * Returns a diagonal {@link BigIntegerMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random diagonal {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see BigIntegerMatrix#diagonal
     * @since 1
     */
    public BigIntegerMatrix nextDiagonalBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1257" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1258" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1259">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1260">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1261">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1262" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1263">                    builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
                } else {
<span class="fc" id="L1265">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1267">            });</span>
<span class="fc" id="L1268">        });</span>
<span class="fc" id="L1269">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link BigIntegerMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random symmetric {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see BigIntegerMatrix#symmetric
     * @since 1
     */
    public BigIntegerMatrix nextSymmetricBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1288" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1289" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1290">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1291">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1292">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1293">                final BigInteger element = nextBigInteger(bound);</span>
<span class="fc bfc" id="L1294" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1295">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1296">                    builder.put(columnIndex, rowIndex, element);</span>
                }
<span class="fc bfc" id="L1298" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1299">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L1301">            });</span>
<span class="fc" id="L1302">        });</span>
<span class="fc" id="L1303">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link BigIntegerMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random skew-symmetric {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see BigIntegerMatrix#skewSymmetric
     * @since 1
     */
    public BigIntegerMatrix nextSkewSymmetricBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1322" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1323" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1324">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1325">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1326">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1327" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1328">                    final BigInteger element = nextBigInteger(bound);</span>
<span class="fc" id="L1329">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1330">                    builder.put(columnIndex, rowIndex, element.negate());</span>
                }
<span class="fc bfc" id="L1332" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1333">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1335">            });</span>
<span class="fc" id="L1336">        });</span>
<span class="fc" id="L1337">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *         the bound
     * @param rowSize
     *         the row size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param columnSize
     *         the column size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextBigIntegerMatrices(final long bound, final int rowSize, final int columnSize,
            final int howMany) {
<span class="fc bfc" id="L1365" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1366" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1367" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1368" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1369">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1370" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1371">            matrices.add(nextBigIntegerMatrix(bound, rowSize, columnSize));</span>
        }
<span class="fc" id="L1373">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular {@link BigIntegerMatrix
     * BigIntegerMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextUpperTriangularBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextUpperTriangularBigIntegerMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L1398" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1399" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1400" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1401">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1402" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1403">            matrices.add(nextUpperTriangularBigIntegerMatrix(bound, size));</span>
        }
<span class="fc" id="L1405">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular {@link BigIntegerMatrix
     * BigIntegerMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextLowerTriangularBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextLowerTriangularBigIntegerMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L1430" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1431" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1432" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1433">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1434" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1435">            matrices.add(nextLowerTriangularBigIntegerMatrix(bound, size));</span>
        }
<span class="fc" id="L1437">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular {@link BigIntegerMatrix
     * BigIntegerMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextTriangularBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextTriangularBigIntegerMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L1462" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1463" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1464" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1465">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1466" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1467">            matrices.add(nextTriangularBigIntegerMatrix(bound, size));</span>
        }
<span class="fc" id="L1469">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal {@link BigIntegerMatrix
     * BigIntegerMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextDiagonalBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextDiagonalBigIntegerMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1493" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1494" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1495" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1496">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1497" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1498">            matrices.add(nextDiagonalBigIntegerMatrix(bound, size));</span>
        }
<span class="fc" id="L1500">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric {@link BigIntegerMatrix
     * BigIntegerMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSymmetricBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextSymmetricBigIntegerMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1524" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1525" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1526" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1527">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1528" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1529">            matrices.add(nextSymmetricBigIntegerMatrix(bound, size));</span>
        }
<span class="fc" id="L1531">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric {@link BigIntegerMatrix
     * BigIntegerMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextSkewSymmetricBigIntegerMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L1556" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1557" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1558" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1559">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1560" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1561">            matrices.add(nextSkewSymmetricBigIntegerMatrix(bound, size));</span>
        }
<span class="fc" id="L1563">        return matrices;</span>
    }

    /**
     * Returns a {@link BigDecimalVector}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param size
     *         the size of the resulting {@link BigDecimalVector}
     * @return A speudo random {@link BigDecimalVector}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextBigDecimal
     * @since 1
     */
    public BigDecimalVector nextBigDecimalVector(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1586" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1587" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1588" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1589">        final BigDecimalVectorBuilder builder = BigDecimalVector.builder(size);</span>
<span class="fc bfc" id="L1590" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1591">            builder.put(nextBigDecimal(bound, scale));</span>
        }
<span class="fc" id="L1593">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigDecimalVector BigDecimalVectors}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param size
     *         the size of the resulting {@link BigDecimalVector BigDecimalVectors}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimalVector BigDecimalVectors}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextBigDecimalVector
     * @since 1
     */
    public List&lt;BigDecimalVector&gt; nextBigDecimalVectors(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L1623" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1624" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1625" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1626" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1627">        final List&lt;BigDecimalVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1628" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1629">            vectors.add(nextBigDecimalVector(bound, scale, size));</span>
        }
<span class="fc" id="L1631">        return vectors;</span>
    }

    /**
     * Returns a {@link BigDecimalMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param rowSize
     *         the row size of the resulting {@link BigDecimalMatrix}
     * @param columnSize
     *         the column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @see #nextBigDecimal
     * @since 1
     */
    public BigDecimalMatrix nextBigDecimalMatrix(final long bound, final int scale, final int rowSize,
            final int columnSize) {
<span class="fc bfc" id="L1659" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1660" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1661" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1662" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L1663">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L1664">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1665">            IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1666">                builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
<span class="fc" id="L1667">            });</span>
<span class="fc" id="L1668">        });</span>
<span class="fc" id="L1669">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link BigDecimalMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of resulting {@link BigDecimalMatrix}
     * @return A pseudo random upper triangular {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextBigDecimal
     * @see BigDecimalMatrix#upperTriangular
     * @since 1
     */
    public BigDecimalMatrix nextUpperTriangularBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1693" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1694" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1695">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1696">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1697">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1698" title="All 2 branches covered.">                if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L1699">                    builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1701">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1703">            });</span>
<span class="fc" id="L1704">        });</span>
<span class="fc" id="L1705">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link BigDecimalMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random lower triangular {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextBigDecimal
     * @see BigDecimalMatrix#lowerTriangular
     * @since 1
     */
    public BigDecimalMatrix nextLowerTriangularBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1729" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1730" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1731">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1732">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1733">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1734" title="All 2 branches covered.">                if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L1735">                    builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1737">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1739">            });</span>
<span class="fc" id="L1740">        });</span>
<span class="fc" id="L1741">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link BigDecimalMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random triangular {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextUpperTriangularBigDecimalMatrix
     * @see #nextLowerTriangularBigDecimalMatrix
     * @see BigDecimalMatrix#triangular
     * @since 1
     */
    public BigDecimalMatrix nextTriangularBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1766" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1767" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1768" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L1769">            return nextLowerTriangularBigDecimalMatrix(bound, scale, size);</span>
        }
<span class="fc" id="L1771">        return nextUpperTriangularBigDecimalMatrix(bound, scale, size);</span>
    }

    /**
     * Returns a diagonal {@link BigDecimalMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random diagonal {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see BigDecimalMatrix#diagonal
     * @since 1
     */
    public BigDecimalMatrix nextDiagonalBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1794" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1795" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1796">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1797">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1798">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1799" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1800">                    builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1802">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1804">            });</span>
<span class="fc" id="L1805">        });</span>
<span class="fc" id="L1806">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link BigDecimalMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random symmetric {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see BigDecimalMatrix#symmetric
     * @since 1
     */
    public BigDecimalMatrix nextSymmetricBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1829" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1830" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1831">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1832">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1833">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1834">                final BigDecimal element = nextBigDecimal(bound, scale);</span>
<span class="fc bfc" id="L1835" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1836">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1837">                    builder.put(columnIndex, rowIndex, element);</span>
                }
<span class="fc bfc" id="L1839" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1840">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L1842">            });</span>
<span class="fc" id="L1843">        });</span>
<span class="fc" id="L1844">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link BigDecimalMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random skew-symmetric {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see BigDecimalMatrix#skewSymmetric
     * @since 1
     */
    public BigDecimalMatrix nextSkewSymmetricBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1867" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1868" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1869">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1870">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1871">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1872" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1873">                    final BigDecimal element = nextBigDecimal(bound, scale);</span>
<span class="fc" id="L1874">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1875">                    builder.put(columnIndex, rowIndex, element.negate());</span>
                }
<span class="fc bfc" id="L1877" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1878">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1880">            });</span>

<span class="fc" id="L1882">        });</span>
<span class="fc" id="L1883">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param rowSize
     *         the row size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param columnSize
     *         the column size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextBigDecimalMatrices(final long bound, final int scale, final int rowSize,
            final int columnSize, final int howMany) {
<span class="fc bfc" id="L1915" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1916" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1917" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1918" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1919" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1920">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1921" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1922">            matrices.add(nextBigDecimalMatrix(bound, scale, rowSize, columnSize));</span>
        }
<span class="fc" id="L1924">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular {@link BigDecimalMatrix
     * BigDecimalMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextUpperTriangularBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextUpperTriangularBigDecimalMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L1953" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1954" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1955" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1956" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1957">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1958" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1959">            matrices.add(nextUpperTriangularBigDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L1961">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular {@link BigDecimalMatrix
     * BigDecimalMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextLowerTriangularBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextLowerTriangularBigDecimalMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L1990" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1991" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1992" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1993" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1994">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1995" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1996">            matrices.add(nextLowerTriangularBigDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L1998">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular {@link BigDecimalMatrix
     * BigDecimalMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextTriangularBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextTriangularBigDecimalMatrices(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2027" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2028" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2029" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2030" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2031">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2032" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2033">            matrices.add(nextTriangularBigDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2035">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal {@link BigDecimalMatrix
     * BigDecimalMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextDiagonalBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextDiagonalBigDecimalMatrices(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2064" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2065" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2066" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2067" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2068">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2069" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2070">            matrices.add(nextDiagonalBigDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2072">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric {@link BigDecimalMatrix
     * BigDecimalMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSymmetricBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextSymmetricBigDecimalMatrices(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2101" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2102" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2103" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2104" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2105">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2106" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2107">            matrices.add(nextSymmetricBigDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2109">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric {@link BigDecimalMatrix
     * BigDecimalMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextSkewSymmetricBigDecimalMatrices(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2138" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2139" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2140" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2141" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2142">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2143" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2144">            matrices.add(nextSkewSymmetricBigDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2146">        return matrices;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumberVector}
     *
     * @param bound
     *         the bound
     * @param size
     *         the size of the resulting {@link SimpleComplexNumberVector}
     * @return A pseudo random {@link SimpleComplexNumberVector}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextSimpleComplexNumber(long)
     * @since 1
     */
    public SimpleComplexNumberVector nextSimpleComplexNumberVector(final long bound, final int size) {
<span class="fc bfc" id="L2165" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2166" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2167">        final SimpleComplexNumberVector.SimpleComplexNumberVectorBuilder builder =</span>
<span class="fc" id="L2168">                SimpleComplexNumberVector.builder(size);</span>
<span class="fc bfc" id="L2169" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L2170">            builder.put(nextSimpleComplexNumber(bound));</span>
        }
<span class="fc" id="L2172">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumberVector
     * SimpleComplexNumberVectors}
     *
     * @param bound
     *         the bound
     * @param size
     *         the sizes of the resulting {@link SimpleComplexNumberVector SimpleComplexNumberVectors}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumberVector SimpleComplexNumberVectors}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextSimpleComplexNumberVector
     * @since 1
     */
    public List&lt;SimpleComplexNumberVector&gt; nextSimpleComplexNumberVectors(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L2195" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2196" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2197" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2198">        final List&lt;SimpleComplexNumberVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2199" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2200">            vectors.add(nextSimpleComplexNumberVector(bound, size));</span>
        }
<span class="fc" id="L2202">        return vectors;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param rowSize
     *         the row size of the resulting {@link SimpleComplexNumberMatrix}
     * @param columnSize
     *         the column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @see #nextSimpleComplexNumber(long)
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSimpleComplexNumberMatrix(final long bound, final int rowSize,
            final int columnSize) {
<span class="fc bfc" id="L2226" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2227" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2228" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L2229">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L2230">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2231">            IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L2232">                builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
<span class="fc" id="L2233">            });</span>
<span class="fc" id="L2234">        });</span>
<span class="fc" id="L2235">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random upper triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#upperTriangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextUpperTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2254" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2255" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2256">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2257">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2258">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2259" title="All 2 branches covered.">                if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L2260">                    builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                } else {
<span class="fc" id="L2262">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2264">            });</span>
<span class="fc" id="L2265">        });</span>
<span class="fc" id="L2266">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random lower triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#lowerTriangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextLowerTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2285" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2286" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2287">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2288">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2289">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2290" title="All 2 branches covered.">                if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L2291">                    builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                } else {
<span class="fc" id="L2293">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2295">            });</span>
<span class="fc" id="L2296">        });</span>
<span class="fc" id="L2297">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextUpperTriangularSimpleComplexNumberMatrix
     * @see #nextLowerTriangularSimpleComplexNumberMatrix
     * @see SimpleComplexNumberMatrix#triangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2318" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2319" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2320" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L2321">            return nextLowerTriangularSimpleComplexNumberMatrix(bound, size);</span>
        }
<span class="fc" id="L2323">        return nextUpperTriangularSimpleComplexNumberMatrix(bound, size);</span>
    }

    /**
     * Returns a diagonal {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random diagonal {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#diagonal
     * @since 1
     */
    public SimpleComplexNumberMatrix nextDiagonalSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2342" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2343" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2344">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2345">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2346">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2347" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2348">                    builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                } else {
<span class="fc" id="L2350">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2352">            });</span>
<span class="fc" id="L2353">        });</span>
<span class="fc" id="L2354">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random symmetric {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#symmetric
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSymmetricSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2373" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2374" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2375">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2376">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2377">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L2378">                final SimpleComplexNumber element = nextSimpleComplexNumber(bound);</span>
<span class="fc bfc" id="L2379" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L2380">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2381">                    builder.put(columnIndex, rowIndex, element);</span>
                }
<span class="fc bfc" id="L2383" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2384">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L2386">            });</span>
<span class="fc" id="L2387">        });</span>
<span class="fc" id="L2388">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random skew-symmetric {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#skewSymmetric
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSkewSymmetricSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2407" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2408" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2409">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2410">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2411">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2412" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L2413">                    final SimpleComplexNumber element = nextSimpleComplexNumber(bound);</span>
<span class="fc" id="L2414">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2415">                    builder.put(columnIndex, rowIndex, element.negate());</span>
                }
<span class="fc bfc" id="L2417" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2418">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2420">            });</span>
<span class="fc" id="L2421">        });</span>
<span class="fc" id="L2422">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param rowSize
     *         the row size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param columnSize
     *         the column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSimpleComplexNumberMatrices(final long bound, final int rowSize,
            final int columnSize, final int howMany) {
<span class="fc bfc" id="L2451" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2452" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2453" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L2454" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2455">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2456" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2457">            matrices.add(nextSimpleComplexNumberMatrix(bound, rowSize, columnSize));</span>
        }
<span class="fc" id="L2459">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular {@link
     * SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextUpperTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextUpperTriangularSimpleComplexNumberMatrices(final long bound,
            final int size, final int howMany) {
<span class="fc bfc" id="L2485" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2486" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2487" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2488">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2489" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2490">            matrices.add(nextUpperTriangularSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2492">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular {@link
     * SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextLowerTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextLowerTriangularSimpleComplexNumberMatrices(final long bound,
            final int size, final int howMany) {
<span class="fc bfc" id="L2518" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2519" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2520" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2521">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2522" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2523">            matrices.add(nextLowerTriangularSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2525">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextTriangularSimpleComplexNumberMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L2550" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2551" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2552" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2553">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2554" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2555">            matrices.add(nextTriangularSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2557">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextDiagonalSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextDiagonalSimpleComplexNumberMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L2582" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2583" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2584" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2585">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2586" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2587">            matrices.add(nextDiagonalSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2589">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSymmetricSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSymmetricSimpleComplexNumberMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L2614" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2615" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2616" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2617">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2618" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2619">            matrices.add(nextSymmetricSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2621">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSkewSymmetricSimpleComplexNumberMatrices(final long bound,
            final int size, final int howMany) {
<span class="fc bfc" id="L2647" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2648" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2649" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2650">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2651" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2652">            matrices.add(nextSkewSymmetricSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2654">        return matrices;</span>
    }

    /**
     * Returns a {@link RealComplexNumberVector}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the size of the resulting {@link RealComplexNumberVector}
     * @return A pseudo random {@link RealComplexNumberVector}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @since 1
     */
    public RealComplexNumberVector nextRealComplexNumberVector(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L2677" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2678" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2679" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2680">        final RealComplexNumberVectorBuilder builder = RealComplexNumberVector.builder(size);</span>
<span class="fc bfc" id="L2681" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L2682">            builder.put(nextRealComplexNumber(bound, scale));</span>
        }
<span class="fc" id="L2684">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumberVector
     * RealComplexNumberVectors}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the sizes of the resulting {@link RealComplexNumberVector RealComplexNumberVectors}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumberVector RealComplexNumberVectors}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextRealComplexNumberVector
     * @since 1
     */
    public List&lt;RealComplexNumberVector&gt; nextRealComplexNumberVectors(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2711" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2712" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2713" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2714" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2715">        final List&lt;RealComplexNumberVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2716" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2717">            vectors.add(nextRealComplexNumberVector(bound, scale, size));</span>
        }
<span class="fc" id="L2719">        return vectors;</span>
    }

    /**
     * Returns a {@link RealComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param rowSize
     *         the row size of the resulting {@link RealComplexNumberMatrix}
     * @param columnSize
     *         the column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @since 1
     */
    public RealComplexNumberMatrix nextRealComplexNumberMatrix(final long bound, final int scale, final int rowSize,
            final int columnSize) {
<span class="fc bfc" id="L2747" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2748" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2749" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2750" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L2751">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L2752">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2753">            IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L2754">                builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
<span class="fc" id="L2755">            });</span>
<span class="fc" id="L2756">        });</span>
<span class="fc" id="L2757">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random upper triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @see RealComplexNumberMatrix#upperTriangular
     * @since 1
     */
    public RealComplexNumberMatrix nextUpperTriangularRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2782" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2783" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2784" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2785">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2786">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2787">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2788" title="All 2 branches covered.">                if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L2789">                    builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                } else {
<span class="fc" id="L2791">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2793">            });</span>
<span class="fc" id="L2794">        });</span>
<span class="fc" id="L2795">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random lower triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @see RealComplexNumberMatrix#lowerTriangular
     * @since 1
     */
    public RealComplexNumberMatrix nextLowerTriangularRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2820" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2821" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2822" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2823">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2824">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2825">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2826" title="All 2 branches covered.">                if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L2827">                    builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                } else {
<span class="fc" id="L2829">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2831">            });</span>
<span class="fc" id="L2832">        });</span>
<span class="fc" id="L2833">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextUpperTriangularRealComplexNumberMatrix
     * @see #nextLowerTriangularRealComplexNumberMatrix
     * @see RealComplexNumberMatrix#triangular
     * @since 1
     */
    public RealComplexNumberMatrix nextTriangularRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2859" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2860" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2861" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2862" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L2863">            return nextLowerTriangularRealComplexNumberMatrix(bound, scale, size);</span>
        }
<span class="fc" id="L2865">        return nextUpperTriangularRealComplexNumberMatrix(bound, scale, size);</span>
    }

    /**
     * Returns a diagonal {@link RealComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random diagonal {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see RealComplexNumberMatrix#diagonal
     * @since 1
     */
    public RealComplexNumberMatrix nextDiagonalRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2889" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2890" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2891" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2892">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2893">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2894">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2895" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2896">                    builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                } else {
<span class="fc" id="L2898">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2900">            });</span>
<span class="fc" id="L2901">        });</span>
<span class="fc" id="L2902">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link RealComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random symmetric {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see RealComplexNumberMatrix#symmetric
     * @since 1
     */
    public RealComplexNumberMatrix nextSymmetricRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2926" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2927" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2928" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2929">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2930">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2931">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L2932">                final RealComplexNumber element = nextRealComplexNumber(bound, scale);</span>
<span class="fc bfc" id="L2933" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L2934">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2935">                    builder.put(columnIndex, rowIndex, element);</span>
                }
<span class="fc bfc" id="L2937" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2938">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L2940">            });</span>
<span class="fc" id="L2941">        });</span>
<span class="fc" id="L2942">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link RealComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random skew-symmetric {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see RealComplexNumberMatrix#skewSymmetric
     * @since 1
     */
    public RealComplexNumberMatrix nextSkewSymmetricRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2966" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2967" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2968" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2969">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2970">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2971">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2972" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L2973">                    final RealComplexNumber element = nextRealComplexNumber(bound, scale);</span>
<span class="fc" id="L2974">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2975">                    builder.put(columnIndex, rowIndex, element.negate());</span>
                }
<span class="fc bfc" id="L2977" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2978">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2980">            });</span>
<span class="fc" id="L2981">        });</span>
<span class="fc" id="L2982">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param rowSize
     *         the row size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param columnSize
     *         the column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextRealComplexNumberMatrices(final long bound, final int scale,
            final int rowSize, final int columnSize, final int howMany) {
<span class="fc bfc" id="L3015" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3016" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3017" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L3018" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L3019" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3020">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3021" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3022">            matrices.add(nextRealComplexNumberMatrix(bound, scale, rowSize, columnSize));</span>
        }
<span class="fc" id="L3024">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextUpperTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextUpperTriangularRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3054" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3055" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3056" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3057" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3058">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3059" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3060">            matrices.add(nextUpperTriangularRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3062">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextLowerTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextLowerTriangularRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3092" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3093" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3094" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3095" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3096">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3097" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3098">            matrices.add(nextLowerTriangularRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3100">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextTriangularRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3129" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3130" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3131" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3132" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3133">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3134" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3135">            matrices.add(nextTriangularRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3137">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextDiagonalRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextDiagonalRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3166" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3167" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3168" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3169" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3170">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3171" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3172">            matrices.add(nextDiagonalRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3174">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSymmetricRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextSymmetricRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3203" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3204" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3205" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3206" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3207">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3208" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3209">            matrices.add(nextSymmetricRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3211">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextSkewSymmetricRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3240" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3241" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3242" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3243" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3244">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3245" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3246">            matrices.add(nextSkewSymmetricRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3248">        return matrices;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L3253">        return MoreObjects.toStringHelper(this).add(&quot;random&quot;, random).toString();</span>
    }

    @VisibleForTesting
    Random getRandom() {
<span class="fc" id="L3258">        return random;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>