<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MathRandom.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">finnMath Core</a> &gt; <a href="index.source.html" class="el_package">com.github.ltennstedt.finnmath.core.util</a> &gt; <span class="el_source">MathRandom.java</span></div><h1>MathRandom.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017 Lars Tennstedt
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.ltennstedt.finnmath.core.util;

import static com.google.common.base.Preconditions.checkArgument;

import com.github.ltennstedt.finnmath.core.linear.BigDecimalMatrix;
import com.github.ltennstedt.finnmath.core.linear.BigDecimalMatrix.BigDecimalMatrixBuilder;
import com.github.ltennstedt.finnmath.core.linear.BigDecimalVector;
import com.github.ltennstedt.finnmath.core.linear.BigDecimalVector.BigDecimalVectorBuilder;
import com.github.ltennstedt.finnmath.core.linear.BigIntegerMatrix;
import com.github.ltennstedt.finnmath.core.linear.BigIntegerVector;
import com.github.ltennstedt.finnmath.core.linear.BigIntegerVector.BigIntegerVectorBuilder;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberMatrix;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberMatrix.RealComplexNumberMatrixBuilder;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberVector;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberVector.RealComplexNumberVectorBuilder;
import com.github.ltennstedt.finnmath.core.linear.SimpleComplexNumberMatrix;
import com.github.ltennstedt.finnmath.core.linear.SimpleComplexNumberMatrix.SimpleComplexNumberMatrixBuilder;
import com.github.ltennstedt.finnmath.core.linear.SimpleComplexNumberVector;
import com.github.ltennstedt.finnmath.core.number.Fraction;
import com.github.ltennstedt.finnmath.core.number.PolarForm;
import com.github.ltennstedt.finnmath.core.number.RealComplexNumber;
import com.github.ltennstedt.finnmath.core.number.SimpleComplexNumber;
import com.google.common.annotations.Beta;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.apache.commons.lang3.RandomUtils;

/**
 * A pseudo random generator for {@code long}, {@link BigDecimal},
 * {@link Fraction}, {@link SimpleComplexNumber}, {@link RealComplexNumber},
 * {@link BigIntegerVector}, {@link BigDecimalVector}, {@link BigIntegerMatrix}
 * and {@link BigDecimalMatrix}
 *
 * @author Lars Tennstedt
 * @since 1
 */
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">@Beta</span>
public final class MathRandom {
    private final Random random;

    /**
     * Default constructor
     *
     * @since 1
     */
<span class="fc" id="L70">    public MathRandom() {</span>
<span class="fc" id="L71">        random = new Random();</span>
<span class="fc" id="L72">    }</span>

    /**
     * Constructor which has the seed value as parameter
     *
     * @param seed
     *            The seed
     * @since 1
     */
<span class="fc" id="L81">    public MathRandom(final long seed) {</span>
<span class="fc" id="L82">        random = new Random(seed);</span>
<span class="fc" id="L83">    }</span>

    /**
     * Returns a positive {@link BigInteger} bounded below by {@code 0} (inclusive)
     * and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link BigInteger}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @since 1
     */
    public BigInteger nextPositiveBigInteger(final long bound) {
<span class="fc bfc" id="L97" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L98">        return BigInteger.valueOf(RandomUtils.nextLong(0, bound));</span>
    }

    /**
     * Returns a negative {@link BigInteger} bounded below by {@code -bound}
     * (exclusive) and above by {@code 0} (inclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link BigInteger}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @see #nextPositiveBigInteger(long)
     * @since 1
     */
    public BigInteger nextNegativeBigInteger(final long bound) {
<span class="fc bfc" id="L114" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L115">        return nextPositiveBigInteger(bound).negate();</span>
    }

    /**
     * Returns a {@link BigInteger} bounded below by {@code -bound} (exclusive) and
     * above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link BigInteger}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @see #nextPositiveBigInteger(long)
     * @see #nextNegativeBigInteger(long)
     * @since 1
     */
    public BigInteger nextBigInteger(final long bound) {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        return random.nextBoolean() ? nextNegativeBigInteger(bound) : nextPositiveBigInteger(bound);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive
     * {@link BigInteger BigIntegers}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigInteger BigIntegers}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextPositiveBigInteger(long)
     * @since 1
     */
    public List&lt;BigInteger&gt; nextPositiveBigIntegers(final long bound, final int howMany) {
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L155">        final List&lt;BigInteger&gt; integers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L156">        IntStream.range(0, howMany).forEach(i -&gt; integers.add(nextPositiveBigInteger(bound)));</span>
<span class="fc" id="L157">        return integers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative
     * {@link BigInteger BigIntegers}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigInteger BigIntegers}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextNegativeBigInteger(long)
     * @since 1
     */
    public List&lt;BigInteger&gt; nextNegativeBigIntegers(final long bound, final int howMany) {
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L179">        final List&lt;BigInteger&gt; integers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L180">        IntStream.range(0, howMany).forEach(i -&gt; integers.add(nextNegativeBigInteger(bound)));</span>
<span class="fc" id="L181">        return integers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link BigInteger BigIntegers}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigInteger BigIntegers}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public List&lt;BigInteger&gt; nextBigIntegers(final long bound, final int howMany) {
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L203">        final List&lt;BigInteger&gt; integers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L204">        IntStream.range(0, howMany).forEach(i -&gt; integers.add(nextBigInteger(bound)));</span>
<span class="fc" id="L205">        return integers;</span>
    }

    /**
     * Returns a positive {@link BigDecimal} of a given {@code scale} bounded below
     * by {@code 0} (inclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @since 1
     */
    public BigDecimal nextPositiveBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L224" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L226">        final BigDecimal decimal = nextBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">        return decimal.compareTo(BigDecimal.ZERO) &lt; 0 ? decimal.negate() : decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} of a given {@code scale} bounded below
     * by {@code -bound} (exclusive) and above by {@code 0} (inclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @since 1
     */
    public BigDecimal nextNegativeBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L246" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L248">        final BigDecimal decimal = nextBigDecimal(bound, scale);</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        return decimal.compareTo(BigDecimal.ZERO) &gt; 0 ? decimal.negate() : decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} of a given {@code scale} bounded below by
     * {@code -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @since 1
     */
    public BigDecimal nextBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L268" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L270">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L271">        return keepBigDecimalInBound(decimal, bound).setScale(scale, RoundingMode.HALF_UP);</span>
    }

    /**
     * Returns a positive {@link BigDecimal} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @see #nextPositiveBigDecimal
     * @since 1
     */
    public BigDecimal nextInvertiblePositiveBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L290" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L292">        final BigDecimal decimal = nextInvertibleBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        return decimal.compareTo(BigDecimal.ZERO) &lt; 0 ? decimal.negate() : decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @see #nextNegativeBigDecimal
     * @see #nextInvertibleBigDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleNegativeBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L313" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L315">        final BigDecimal decimal = nextInvertibleBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        return decimal.compareTo(BigDecimal.ZERO) &gt; 0 ? decimal.negate() : decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @see #nextBigDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L335" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L337">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L338">        return keepBigDecimalInBound(decimal, bound).setScale(scale, RoundingMode.HALF_UP);</span>
    }

    @VisibleForTesting
    BigDecimal keepBigDecimalInBound(final BigDecimal decimal, final long bound) {
<span class="pc bpc" id="L343" title="2 of 4 branches missed.">        assert decimal != null;</span>
<span class="pc bpc" id="L344" title="2 of 4 branches missed.">        assert bound &gt; 1;</span>
<span class="fc" id="L345">        BigDecimal result = decimal;</span>
<span class="fc" id="L346">        final BigDecimal decimalBound = BigDecimal.valueOf(bound);</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if (result.compareTo(BigDecimal.ZERO) &gt; -1) {</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">            while (result.compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L349">                result = result.subtract(decimalBound);</span>
            }
        } else {
<span class="fc bfc" id="L352" title="All 2 branches covered.">            while (result.abs().compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L353">                result = result.add(decimalBound);</span>
            }
        }
<span class="fc" id="L356">        return result;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive
     * {@link BigDecimal BigDecimals}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextPositiveBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextPositiveBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L380" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L383">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L384">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextPositiveBigDecimal(bound, scale)));</span>
<span class="fc" id="L385">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative
     * {@link BigDecimal BigDecimals}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextNegativeBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextNegativeBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L409" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L412">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L413">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextNegativeBigDecimal(bound, scale)));</span>
<span class="fc" id="L414">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link BigDecimal BigDecimals}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L438" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L441">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L442">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextBigDecimal(bound, scale)));</span>
<span class="fc" id="L443">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive
     * {@link BigDecimal BigDecimals} which are invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertiblePositiveBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertiblePositiveBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L467" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L470">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L471">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextInvertiblePositiveBigDecimal(bound, scale)));</span>
<span class="fc" id="L472">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative
     * {@link BigDecimal BigDecimals} which are invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleNegativeBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleNegativeBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L496" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L499">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L500">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextInvertibleNegativeBigDecimal(bound, scale)));</span>
<span class="fc" id="L501">        return decimals;</span>
    }

    /**
     * Returns a {@code List} of the size of {@code howMany} containing
     * {@link BigDecimal BigDecimals} which are invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L525" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L528">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L529">        IntStream.range(0, howMany).forEach(i -&gt; decimals.add(nextInvertibleBigDecimal(bound, scale)));</span>
<span class="fc" id="L530">        return decimals;</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by
     * {@code 0} (inclusive) and above by {@code
     * bound} (exclusive) and whose {@code denominator} is bounded below {@code 1}
     * (inclusive) and {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @since 1
     */
    public Fraction nextPositiveFraction(final long bound) {
<span class="fc bfc" id="L547" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L548">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L549">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L550">        return Fraction.of(numerator, denominator);</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by
     * {@code -bound} (exclusive) and above by {@code 0} (inclusive) and whose
     * {@code denominator} is bounded below {@code 1} (inclusive) and {@code bound}
     * (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @since 1
     */
    public Fraction nextNegativeFraction(final long bound) {
<span class="fc bfc" id="L567" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L568">        return nextPositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by
     * {@code -bound} (exclusive) and above by {@code bound} (exclusive) and whose
     * {@code denominator} is bounded below {@code -bound} (exclusive) and {@code
     * bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @since 1
     */
    public Fraction nextFraction(final long bound) {
<span class="fc bfc" id="L585" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">        return random.nextBoolean() ? nextNegativeFraction(bound) : nextPositiveFraction(bound);</span>
    }

    /**
     * Returns a positive {@link Fraction} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @see #nextPositiveFraction
     * @since 1
     */
    public Fraction nextInvertiblePositiveFraction(final long bound) {
<span class="fc bfc" id="L601" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L602">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L603">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L604">        return Fraction.of(numerator, denominator);</span>
    }

    /**
     * Returns a negative {@link Fraction} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @see #nextNegativeFraction
     * @since 1
     */
    public Fraction nextInvertibleNegativeFraction(final long bound) {
<span class="fc bfc" id="L619" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L620">        return nextInvertiblePositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @see #nextFraction
     * @since 1
     */
    public Fraction nextInvertibleFraction(final long bound) {
<span class="fc bfc" id="L635" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">        return random.nextBoolean() ? nextInvertibleNegativeFraction(bound) : nextInvertiblePositiveFraction(bound);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive
     * {@link Fraction Fractions}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextPositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextPositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L656" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L658">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L659">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextPositiveFraction(bound)));</span>
<span class="fc" id="L660">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative
     * {@link Fraction Fractions}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L680" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L682">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L683">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextNegativeFraction(bound)));</span>
<span class="fc" id="L684">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link Fraction Fractions}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L704" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L706">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L707">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextFraction(bound)));</span>
<span class="fc" id="L708">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive
     * {@link Fraction Fractions} which are invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertiblePositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertiblePositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L728" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L730">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L731">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextInvertiblePositiveFraction(bound)));</span>
<span class="fc" id="L732">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative
     * {@link Fraction Fractions} which are invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L752" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L754">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L755">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextInvertibleNegativeFraction(bound)));</span>
<span class="fc" id="L756">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link Fraction Fractions} which are invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L776" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L778">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L779">        IntStream.range(0, howMany).forEach(i -&gt; fractions.add(nextInvertibleFraction(bound)));</span>
<span class="fc" id="L780">        return fractions;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} whose {@code real} and
     * {@code imaginary} part are bounded below by {@code
     * -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public SimpleComplexNumber nextSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L797" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L798">        return SimpleComplexNumber.of(nextBigInteger(bound), nextBigInteger(bound));</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public SimpleComplexNumber nextInvertibleSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L813" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L814">        final BigInteger nonZeroPart = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L815">        final BigInteger possibleZeroPart = nextBigInteger(bound);</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">        return random.nextBoolean() ? SimpleComplexNumber.of(possibleZeroPart, nonZeroPart)</span>
<span class="fc" id="L817">            : SimpleComplexNumber.of(nonZeroPart, possibleZeroPart);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link SimpleComplexNumber SimpleComplexNumbers}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A List {@link List} of pseudo random {@link SimpleComplexNumber
     *         SimpleComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L838" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L840">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L841">        IntStream.range(0, howMany).forEach(i -&gt; complexNumbers.add(nextSimpleComplexNumber(bound)));</span>
<span class="fc" id="L842">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link SimpleComplexNumber SimpleComplexNumbers} which are invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumber
     *         SimpleComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextInvertibleSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L863" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L865">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L866">        IntStream.range(0, howMany).forEach(i -&gt; complexNumbers.add(nextInvertibleSimpleComplexNumber(bound)));</span>
<span class="fc" id="L867">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link RealComplexNumber} whose {@code real} and {@code imaginary}
     * part are bounded below by {@code
     * -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @since 1
     */
    public RealComplexNumber nextRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L885" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L887">        final BigDecimal real = nextBigDecimal(bound, scale);</span>
<span class="fc" id="L888">        final BigDecimal imaginary = nextBigDecimal(bound, scale);</span>
<span class="fc" id="L889">        return RealComplexNumber.of(real, imaginary);</span>
    }

    /**
     * Returns a {@link RealComplexNumber} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @see #nextRealComplexNumber
     * @since 1
     */
    public RealComplexNumber nextInvertibleRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L906" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L907" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L908">        final BigDecimal nonZeroPart = nextInvertibleBigDecimal(bound, scale);</span>
        final BigDecimal possibleZeroPart =
<span class="fc bfc" id="L910" title="All 2 branches covered.">            random.nextBoolean() ? nextInvertibleBigDecimal(bound, scale) : nextBigDecimal(bound, scale);</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">        return random.nextBoolean() ? RealComplexNumber.of(possibleZeroPart, nonZeroPart)</span>
<span class="fc" id="L912">            : RealComplexNumber.of(nonZeroPart, possibleZeroPart);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link RealComplexNumber RealComplexNumbers}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber
     *         RealComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextRealComplexNumbers(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L937" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L940">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L941">        IntStream.range(0, howMany).forEach(i -&gt; complexNumbers.add(nextRealComplexNumber(bound, scale)));</span>
<span class="fc" id="L942">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link RealComplexNumber RealComplexNumbers} which are invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber
     *         RealComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextInvertibleRealComplexNumbers(final long bound, final int scale,
        final int howMany) {
<span class="fc bfc" id="L968" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L969" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L970" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L971">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L972">        IntStream.range(0, howMany).forEach(i -&gt; complexNumbers.add(nextInvertibleRealComplexNumber(bound, scale)));</span>
<span class="fc" id="L973">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link PolarForm}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A {@link PolarForm}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public PolarForm nextPolarForm(final long bound, final int scale) {
<span class="fc bfc" id="L992" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L994">        return new PolarForm(nextBigDecimal(bound, scale), nextBigDecimal(bound, scale));</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link PolarForm PolarForms}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber
     *         RealComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public List&lt;PolarForm&gt; nextPolarForms(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L1019" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1021" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1022">        final List&lt;PolarForm&gt; polarForms = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1023">        IntStream.range(0, howMany).forEach(i -&gt; polarForms.add(nextPolarForm(bound, scale)));</span>
<span class="fc" id="L1024">        return polarForms;</span>
    }

    /**
     * Returns a {@link BigIntegerVector}
     *
     * @param bound
     *            the bound
     * @param size
     *            the size of the resulting {@link BigIntegerVector}
     * @return A pseudo random {@link BigIntegerVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public BigIntegerVector nextBigIntegerVector(final long bound, final int size) {
<span class="fc bfc" id="L1043" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1044" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1045">        final BigIntegerVectorBuilder builder = BigIntegerVector.builder(size);</span>
<span class="fc" id="L1046">        IntStream.rangeClosed(1, size).forEach(i -&gt; builder.put(nextBigInteger(bound)));</span>
<span class="fc" id="L1047">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link BigIntegerVector BigIntegerVectors}
     *
     * @param bound
     *            the bound
     * @param size
     *            the sizes of the resulting {@link BigIntegerVector
     *            BigIntegerVectors}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigIntegerVector
     *         BigIntegerVectors}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextBigIntegerVector
     * @since 1
     */
    public List&lt;BigIntegerVector&gt; nextBigIntegerVectors(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1071" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1074">        final List&lt;BigIntegerVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1075">        IntStream.range(0, howMany).forEach(i -&gt; vectors.add(nextBigIntegerVector(bound, size)));</span>
<span class="fc" id="L1076">        return vectors;</span>
    }

    /**
     * Returns a {@link BigIntegerMatrix}
     *
     * @param bound
     *            the bound
     * @param rowSize
     *            the row size of the resulting {@link BigIntegerMatrix}
     * @param columnSize
     *            the column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public BigIntegerMatrix nextBigIntegerMatrix(final long bound, final int rowSize, final int columnSize) {
<span class="fc bfc" id="L1099" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1100" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1101" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L1102">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L1103">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L1104">            .forEach(rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L1105">                .forEach(columnIndex -&gt; builder.put(rowIndex, columnIndex, nextBigInteger(bound))));</span>
<span class="fc" id="L1106">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link BigIntegerMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of resulting {@link BigIntegerMatrix}
     * @return A pseudo random upper triangular {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigInteger(long)
     * @see BigIntegerMatrix#upperTriangular
     * @since 1
     */
    public BigIntegerMatrix nextUpperTriangularBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1126" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1127" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1128">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1129">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1130">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1131" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 1) {</span>
<span class="fc" id="L1132">                    builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
                } else {
<span class="fc" id="L1134">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1136">            }));</span>
<span class="fc" id="L1137">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link BigIntegerMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random lower triangular {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigInteger(long)
     * @see BigIntegerMatrix#lowerTriangular
     * @since 1
     */
    public BigIntegerMatrix nextLowerTriangularBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1157" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1158" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1159">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1160">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1161">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1162" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &gt; -1) {</span>
<span class="fc" id="L1163">                    builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
                } else {
<span class="fc" id="L1165">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1167">            }));</span>
<span class="fc" id="L1168">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link BigIntegerMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random triangular {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextUpperTriangularBigIntegerMatrix
     * @see #nextLowerTriangularBigIntegerMatrix
     * @see BigIntegerMatrix#triangular
     * @since 1
     */
    public BigIntegerMatrix nextTriangularBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1189" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1190" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1191" title="All 2 branches covered.">        return random.nextBoolean() ? nextLowerTriangularBigIntegerMatrix(bound, size)</span>
<span class="fc" id="L1192">            : nextUpperTriangularBigIntegerMatrix(bound, size);</span>
    }

    /**
     * Returns a diagonal {@link BigIntegerMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random diagonal {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigIntegerMatrix#diagonal
     * @since 1
     */
    public BigIntegerMatrix nextDiagonalBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1211" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1212" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1213">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1214">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1215">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1216" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1217">                    builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
                } else {
<span class="fc" id="L1219">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1221">            }));</span>
<span class="fc" id="L1222">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link BigIntegerMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random symmetric {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigIntegerMatrix#symmetric
     * @since 1
     */
    public BigIntegerMatrix nextSymmetricBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1241" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1242" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1243">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1244">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1245">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1246">                final BigInteger element = nextBigInteger(bound);</span>
<span class="fc bfc" id="L1247" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L1248">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1249">                    builder.put(columnIndex, rowIndex, element);</span>
<span class="fc bfc" id="L1250" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1251">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L1253">            }));</span>
<span class="fc" id="L1254">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link BigIntegerMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random skew-symmetric {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigIntegerMatrix#skewSymmetric
     * @since 1
     */
    public BigIntegerMatrix nextSkewSymmetricBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1273" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1274" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1275">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1276">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1277">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1278" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L1279">                    final BigInteger element = nextBigInteger(bound);</span>
<span class="fc" id="L1280">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1281">                    builder.put(columnIndex, rowIndex, element.negate());</span>
<span class="fc bfc" id="L1282" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1283">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1285">            }));</span>
<span class="fc" id="L1286">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            the bound
     * @param rowSize
     *            the row size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param columnSize
     *            the column size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigIntegerMatrix
     *         BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextBigIntegerMatrices(final long bound, final int rowSize, final int columnSize,
        final int howMany) {
<span class="fc bfc" id="L1318" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1319" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1320" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1321" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1322">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1323">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextBigIntegerMatrix(bound, rowSize, columnSize)));</span>
<span class="fc" id="L1324">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper
     * triangular {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular
     *         {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextUpperTriangularBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextUpperTriangularBigIntegerMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L1351" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1352" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1353" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1354">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1355">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextUpperTriangularBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1356">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower
     * triangular {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular
     *         {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextLowerTriangularBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextLowerTriangularBigIntegerMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L1383" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1384" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1385" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1386">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1387">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextLowerTriangularBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1388">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular
     * {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link BigIntegerMatrix
     *         BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextTriangularBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextTriangularBigIntegerMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L1415" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1416" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1417" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1418">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1419">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextTriangularBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1420">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal
     * {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link BigIntegerMatrix
     *         BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextDiagonalBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextDiagonalBigIntegerMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1446" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1447" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1448" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1449">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1450">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextDiagonalBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1451">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric
     * {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link BigIntegerMatrix
     *         BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSymmetricBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextSymmetricBigIntegerMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1477" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1478" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1479" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1480">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1481">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSymmetricBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1482">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * skew-symmetric {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntegerMatrix
     *            BigIntegerMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric
     *         {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextSkewSymmetricBigIntegerMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L1509" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1510" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1511" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1512">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1513">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSkewSymmetricBigIntegerMatrix(bound, size)));</span>
<span class="fc" id="L1514">        return matrices;</span>
    }

    /**
     * Returns a {@link BigDecimalVector}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param size
     *            the size of the resulting {@link BigDecimalVector}
     * @return A speudo random {@link BigDecimalVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigDecimal
     * @since 1
     */
    public BigDecimalVector nextBigDecimalVector(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1537" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1538" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1539" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1540">        final BigDecimalVectorBuilder builder = BigDecimalVector.builder(size);</span>
<span class="fc" id="L1541">        IntStream.rangeClosed(1, size).forEach(i -&gt; builder.put(nextBigDecimal(bound, scale)));</span>
<span class="fc" id="L1542">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link BigDecimalVector BigDecimalVectors}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param size
     *            the size of the resulting {@link BigDecimalVector
     *            BigDecimalVectors}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimalVector
     *         BigDecimalVectors}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextBigDecimalVector
     * @since 1
     */
    public List&lt;BigDecimalVector&gt; nextBigDecimalVectors(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L1575" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1576" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1577" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1578" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1579">        final List&lt;BigDecimalVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1580">        IntStream.range(0, howMany).forEach(i -&gt; vectors.add(nextBigDecimalVector(bound, scale, size)));</span>
<span class="fc" id="L1581">        return vectors;</span>
    }

    /**
     * Returns a {@link BigDecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param rowSize
     *            the row size of the resulting {@link BigDecimalMatrix}
     * @param columnSize
     *            the column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @see #nextBigDecimal
     * @since 1
     */
    public BigDecimalMatrix nextBigDecimalMatrix(final long bound, final int scale, final int rowSize,
        final int columnSize) {
<span class="fc bfc" id="L1609" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1610" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1611" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1612" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L1613">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L1614">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L1615">            .forEach(rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L1616">                .forEach(columnIndex -&gt; builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale))));</span>
<span class="fc" id="L1617">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link BigDecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of resulting {@link BigDecimalMatrix}
     * @return A pseudo random upper triangular {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigDecimal
     * @see BigDecimalMatrix#upperTriangular
     * @since 1
     */
    public BigDecimalMatrix nextUpperTriangularBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1641" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1642" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1643">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1644">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1645">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1646" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 1) {</span>
<span class="fc" id="L1647">                    builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1649">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1651">            }));</span>
<span class="fc" id="L1652">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link BigDecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random lower triangular {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextBigDecimal
     * @see BigDecimalMatrix#lowerTriangular
     * @since 1
     */
    public BigDecimalMatrix nextLowerTriangularBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1676" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1677" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1678">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1679">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1680">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1681" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &gt; -1) {</span>
<span class="fc" id="L1682">                    builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1684">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1686">            }));</span>
<span class="fc" id="L1687">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link BigDecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random triangular {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextUpperTriangularBigDecimalMatrix
     * @see #nextLowerTriangularBigDecimalMatrix
     * @see BigDecimalMatrix#triangular
     * @since 1
     */
    public BigDecimalMatrix nextTriangularBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1712" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1713" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1714" title="All 2 branches covered.">        return random.nextBoolean() ? nextLowerTriangularBigDecimalMatrix(bound, scale, size)</span>
<span class="fc" id="L1715">            : nextUpperTriangularBigDecimalMatrix(bound, scale, size);</span>
    }

    /**
     * Returns a diagonal {@link BigDecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random diagonal {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigDecimalMatrix#diagonal
     * @since 1
     */
    public BigDecimalMatrix nextDiagonalBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1738" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1739" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1740">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1741">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1742">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1743" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1744">                    builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1746">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1748">            }));</span>
<span class="fc" id="L1749">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link BigDecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random symmetric {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigDecimalMatrix#symmetric
     * @since 1
     */
    public BigDecimalMatrix nextSymmetricBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1772" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1773" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1774">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1775">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1776">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1777">                final BigDecimal element = nextBigDecimal(bound, scale);</span>
<span class="fc bfc" id="L1778" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L1779">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1780">                    builder.put(columnIndex, rowIndex, element);</span>
<span class="fc bfc" id="L1781" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1782">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L1784">            }));</span>
<span class="fc" id="L1785">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link BigDecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random skew-symmetric {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see BigDecimalMatrix#skewSymmetric
     * @since 1
     */
    public BigDecimalMatrix nextSkewSymmetricBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1808" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1809" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1810">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1811">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1812">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1813" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L1814">                    final BigDecimal element = nextBigDecimal(bound, scale);</span>
<span class="fc" id="L1815">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1816">                    builder.put(columnIndex, rowIndex, element.negate());</span>
<span class="fc bfc" id="L1817" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L1818">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1820">            }));</span>
<span class="fc" id="L1821">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param rowSize
     *            the row size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param columnSize
     *            the column size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimalMatrix
     *         BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextBigDecimalMatrices(final long bound, final int scale, final int rowSize,
        final int columnSize, final int howMany) {
<span class="fc bfc" id="L1857" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1858" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1859" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1860" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1861" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1862">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1863">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextBigDecimalMatrix(bound, scale, rowSize, columnSize)));</span>
<span class="fc" id="L1864">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper
     * triangular {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular
     *         {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextUpperTriangularBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextUpperTriangularBigDecimalMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L1895" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1896" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1897" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1898" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1899">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1900">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextUpperTriangularBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L1901">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower
     * triangular {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular
     *         {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextLowerTriangularBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextLowerTriangularBigDecimalMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L1932" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1933" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1934" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1935" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1936">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1937">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextLowerTriangularBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L1938">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular
     * {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link BigDecimalMatrix
     *         BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextTriangularBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextTriangularBigDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L1969" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1970" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1971" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1972" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1973">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L1974">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextTriangularBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L1975">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal
     * {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link BigDecimalMatrix
     *         BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextDiagonalBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextDiagonalBigDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2006" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2007" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2008" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2009" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2010">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2011">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextDiagonalBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L2012">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric
     * {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link BigDecimalMatrix
     *         BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSymmetricBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextSymmetricBigDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2043" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2044" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2045" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2046" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2047">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2048">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSymmetricBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L2049">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * skew-symmetric {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link BigDecimalMatrix
     *            BigDecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric
     *         {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextSkewSymmetricBigDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2080" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2081" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2082" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2083" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2084">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2085">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSkewSymmetricBigDecimalMatrix(bound, scale, size)));</span>
<span class="fc" id="L2086">        return matrices;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumberVector}
     *
     * @param bound
     *            the bound
     * @param size
     *            the size of the resulting {@link SimpleComplexNumberVector}
     * @return A pseudo random {@link SimpleComplexNumberVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextSimpleComplexNumber(long)
     * @since 1
     */
    public SimpleComplexNumberVector nextSimpleComplexNumberVector(final long bound, final int size) {
<span class="fc bfc" id="L2105" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2106" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2107">        final SimpleComplexNumberVector.SimpleComplexNumberVectorBuilder builder =</span>
<span class="fc" id="L2108">            SimpleComplexNumberVector.builder(size);</span>
<span class="fc" id="L2109">        IntStream.rangeClosed(1, size).forEach(i -&gt; builder.put(nextSimpleComplexNumber(bound)));</span>
<span class="fc" id="L2110">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link SimpleComplexNumberVector SimpleComplexNumberVectors}
     *
     * @param bound
     *            the bound
     * @param size
     *            the sizes of the resulting {@link SimpleComplexNumberVector
     *            SimpleComplexNumberVectors}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumberVector
     *         SimpleComplexNumberVectors}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextSimpleComplexNumberVector
     * @since 1
     */
    public List&lt;SimpleComplexNumberVector&gt; nextSimpleComplexNumberVectors(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L2135" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2136" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2137" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2138">        final List&lt;SimpleComplexNumberVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2139">        IntStream.range(0, howMany).forEach(i -&gt; vectors.add(nextSimpleComplexNumberVector(bound, size)));</span>
<span class="fc" id="L2140">        return vectors;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param rowSize
     *            the row size of the resulting {@link SimpleComplexNumberMatrix}
     * @param columnSize
     *            the column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @see #nextSimpleComplexNumber(long)
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSimpleComplexNumberMatrix(final long bound, final int rowSize,
        final int columnSize) {
<span class="fc bfc" id="L2164" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2165" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2166" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L2167">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L2168">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L2169">            .forEach(rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L2170">                .forEach(columnIndex -&gt; builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound))));</span>
<span class="fc" id="L2171">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of resulting
     *            {@link SimpleComplexNumberMatrix}
     * @return A pseudo random upper triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#upperTriangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextUpperTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2191" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2192" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2193">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2194">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2195">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2196" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 1) {</span>
<span class="fc" id="L2197">                    builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                } else {
<span class="fc" id="L2199">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2201">            }));</span>
<span class="fc" id="L2202">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix}
     * @return A pseudo random lower triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#lowerTriangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextLowerTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2222" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2223" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2224">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2225">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2226">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2227" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &gt; -1) {</span>
<span class="fc" id="L2228">                    builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                } else {
<span class="fc" id="L2230">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2232">            }));</span>
<span class="fc" id="L2233">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix}
     * @return A pseudo random triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextUpperTriangularSimpleComplexNumberMatrix
     * @see #nextLowerTriangularSimpleComplexNumberMatrix
     * @see SimpleComplexNumberMatrix#triangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2255" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2256" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2257" title="All 2 branches covered.">        return random.nextBoolean() ? nextLowerTriangularSimpleComplexNumberMatrix(bound, size)</span>
<span class="fc" id="L2258">            : nextUpperTriangularSimpleComplexNumberMatrix(bound, size);</span>
    }

    /**
     * Returns a diagonal {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix}
     * @return A pseudo random diagonal {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#diagonal
     * @since 1
     */
    public SimpleComplexNumberMatrix nextDiagonalSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2278" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2279" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2280">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2281">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2282">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2283" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2284">                    builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                } else {
<span class="fc" id="L2286">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2288">            }));</span>
<span class="fc" id="L2289">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix}
     * @return A pseudo random symmetric {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#symmetric
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSymmetricSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2309" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2310" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2311">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2312">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2313">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L2314">                final SimpleComplexNumber element = nextSimpleComplexNumber(bound);</span>
<span class="fc bfc" id="L2315" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L2316">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2317">                    builder.put(columnIndex, rowIndex, element);</span>
<span class="fc bfc" id="L2318" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2319">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L2321">            }));</span>
<span class="fc" id="L2322">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix}
     * @return A pseudo random skew-symmetric {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#skewSymmetric
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSkewSymmetricSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2342" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2343" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2344">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2345">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2346">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2347" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L2348">                    final SimpleComplexNumber element = nextSimpleComplexNumber(bound);</span>
<span class="fc" id="L2349">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2350">                    builder.put(columnIndex, rowIndex, element.negate());</span>
<span class="fc bfc" id="L2351" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2352">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2354">            }));</span>
<span class="fc" id="L2355">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param rowSize
     *            the row size of the resulting {@link SimpleComplexNumberMatrix
     *            SimpleComplexNumberMatrices}
     * @param columnSize
     *            the column size of the resulting {@link SimpleComplexNumberMatrix
     *            SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumberMatrix
     *         SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSimpleComplexNumberMatrices(final long bound, final int rowSize,
        final int columnSize, final int howMany) {
<span class="fc bfc" id="L2387" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2388" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2389" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L2390" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2391">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2392">        IntStream.range(0, howMany)</span>
<span class="fc" id="L2393">            .forEach(i -&gt; matrices.add(nextSimpleComplexNumberMatrix(bound, rowSize, columnSize)));</span>
<span class="fc" id="L2394">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper
     * triangular {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextUpperTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextUpperTriangularSimpleComplexNumberMatrices(final long bound,
        final int size, final int howMany) {
<span class="fc bfc" id="L2421" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2422" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2423" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2424">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2425">        IntStream.range(0, howMany)</span>
<span class="fc" id="L2426">            .forEach(i -&gt; matrices.add(nextUpperTriangularSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2427">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower
     * triangular {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextLowerTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextLowerTriangularSimpleComplexNumberMatrices(final long bound,
        final int size, final int howMany) {
<span class="fc bfc" id="L2454" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2455" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2456" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2457">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2458">        IntStream.range(0, howMany)</span>
<span class="fc" id="L2459">            .forEach(i -&gt; matrices.add(nextLowerTriangularSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2460">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextTriangularSimpleComplexNumberMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L2487" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2488" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2489" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2490">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2491">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextTriangularSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2492">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextDiagonalSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextDiagonalSimpleComplexNumberMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L2519" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2520" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2521" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2522">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2523">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextDiagonalSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2524">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSymmetricSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSymmetricSimpleComplexNumberMatrices(final long bound, final int size,
        final int howMany) {
<span class="fc bfc" id="L2551" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2552" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2553" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2554">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2555">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSymmetricSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2556">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * skew-symmetric {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting
     *            {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric
     *         {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSkewSymmetricSimpleComplexNumberMatrices(final long bound,
        final int size, final int howMany) {
<span class="fc bfc" id="L2583" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2584" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2585" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2586">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2587">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextSkewSymmetricSimpleComplexNumberMatrix(bound, size)));</span>
<span class="fc" id="L2588">        return matrices;</span>
    }

    /**
     * Returns a {@link RealComplexNumberVector}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the size of the resulting {@link RealComplexNumberVector}
     * @return A pseudo random {@link RealComplexNumberVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @since 1
     */
    public RealComplexNumberVector nextRealComplexNumberVector(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L2611" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2612" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2613" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2614">        final RealComplexNumberVectorBuilder builder = RealComplexNumberVector.builder(size);</span>
<span class="fc" id="L2615">        IntStream.rangeClosed(1, size).forEach(i -&gt; builder.put(nextRealComplexNumber(bound, scale)));</span>
<span class="fc" id="L2616">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link RealComplexNumberVector RealComplexNumberVectors}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the sizes of the resulting {@link RealComplexNumberVector
     *            RealComplexNumberVectors}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumberVector
     *         RealComplexNumberVectors}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @see #nextRealComplexNumberVector
     * @since 1
     */
    public List&lt;RealComplexNumberVector&gt; nextRealComplexNumberVectors(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2645" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2646" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2647" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2648" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2649">        final List&lt;RealComplexNumberVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2650">        IntStream.range(0, howMany).forEach(i -&gt; vectors.add(nextRealComplexNumberVector(bound, scale, size)));</span>
<span class="fc" id="L2651">        return vectors;</span>
    }

    /**
     * Returns a {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param rowSize
     *            the row size of the resulting {@link RealComplexNumberMatrix}
     * @param columnSize
     *            the column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @since 1
     */
    public RealComplexNumberMatrix nextRealComplexNumberMatrix(final long bound, final int scale, final int rowSize,
        final int columnSize) {
<span class="fc bfc" id="L2679" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2680" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2681" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2682" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L2683">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L2684">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L2685">            .forEach(rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L2686">                .forEach(columnIndex -&gt; builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale))));</span>
<span class="fc" id="L2687">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of resulting
     *            {@link RealComplexNumberMatrix}
     * @return A pseudo random upper triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @see RealComplexNumberMatrix#upperTriangular
     * @since 1
     */
    public RealComplexNumberMatrix nextUpperTriangularRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2713" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2714" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2715" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2716">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2717">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2718">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2719" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 1) {</span>
<span class="fc" id="L2720">                    builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                } else {
<span class="fc" id="L2722">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2724">            }));</span>
<span class="fc" id="L2725">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix}
     * @return A pseudo random lower triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @see RealComplexNumberMatrix#lowerTriangular
     * @since 1
     */
    public RealComplexNumberMatrix nextLowerTriangularRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2751" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2752" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2753" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2754">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2755">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2756">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2757" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &gt; -1) {</span>
<span class="fc" id="L2758">                    builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                } else {
<span class="fc" id="L2760">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2762">            }));</span>
<span class="fc" id="L2763">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix}
     * @return A pseudo random triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see #nextUpperTriangularRealComplexNumberMatrix
     * @see #nextLowerTriangularRealComplexNumberMatrix
     * @see RealComplexNumberMatrix#triangular
     * @since 1
     */
    public RealComplexNumberMatrix nextTriangularRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2790" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2791" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2792" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2793" title="All 2 branches covered.">        return random.nextBoolean() ? nextLowerTriangularRealComplexNumberMatrix(bound, scale, size)</span>
<span class="fc" id="L2794">            : nextUpperTriangularRealComplexNumberMatrix(bound, scale, size);</span>
    }

    /**
     * Returns a diagonal {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix}
     * @return A pseudo random diagonal {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see RealComplexNumberMatrix#diagonal
     * @since 1
     */
    public RealComplexNumberMatrix nextDiagonalRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2819" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2820" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2821" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2822">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2823">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2824">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2825" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2826">                    builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                } else {
<span class="fc" id="L2828">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2830">            }));</span>
<span class="fc" id="L2831">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix}
     * @return A pseudo random symmetric {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see RealComplexNumberMatrix#symmetric
     * @since 1
     */
    public RealComplexNumberMatrix nextSymmetricRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2856" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2857" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2858" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2859">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2860">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2861">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L2862">                final RealComplexNumber element = nextRealComplexNumber(bound, scale);</span>
<span class="fc bfc" id="L2863" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L2864">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2865">                    builder.put(columnIndex, rowIndex, element);</span>
<span class="fc bfc" id="L2866" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2867">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L2869">            }));</span>
<span class="fc" id="L2870">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix}
     * @return A pseudo random skew-symmetric {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @see RealComplexNumberMatrix#skewSymmetric
     * @since 1
     */
    public RealComplexNumberMatrix nextSkewSymmetricRealComplexNumberMatrix(final long bound, final int scale,
        final int size) {
<span class="fc bfc" id="L2895" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2896" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2897" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2898">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2899">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2900">            rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2901" title="All 2 branches covered.">                if (rowIndex.compareTo(columnIndex) &lt; 0) {</span>
<span class="fc" id="L2902">                    final RealComplexNumber element = nextRealComplexNumber(bound, scale);</span>
<span class="fc" id="L2903">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2904">                    builder.put(columnIndex, rowIndex, element.negate());</span>
<span class="fc bfc" id="L2905" title="All 2 branches covered.">                } else if (rowIndex.compareTo(columnIndex) == 0) {</span>
<span class="fc" id="L2906">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2908">            }));</span>
<span class="fc" id="L2909">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param rowSize
     *            the row size of the resulting {@link RealComplexNumberMatrix
     *            RealComplexNumberMatrices}
     * @param columnSize
     *            the column size of the resulting {@link RealComplexNumberMatrix
     *            RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumberMatrix
     *         RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextRealComplexNumberMatrices(final long bound, final int scale,
        final int rowSize, final int columnSize, final int howMany) {
<span class="fc bfc" id="L2945" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2946" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2947" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2948" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L2949" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2950">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2951">        IntStream.range(0, howMany)</span>
<span class="fc" id="L2952">            .forEach(i -&gt; matrices.add(nextRealComplexNumberMatrix(bound, scale, rowSize, columnSize)));</span>
<span class="fc" id="L2953">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper
     * triangular {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextUpperTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextUpperTriangularRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L2984" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2985" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2986" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2987" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2988">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L2989">        IntStream.range(0, howMany)</span>
<span class="fc" id="L2990">            .forEach(i -&gt; matrices.add(nextUpperTriangularRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L2991">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower
     * triangular {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextLowerTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextLowerTriangularRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L3022" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3023" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3024" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3025" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3026">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L3027">        IntStream.range(0, howMany)</span>
<span class="fc" id="L3028">            .forEach(i -&gt; matrices.add(nextLowerTriangularRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L3029">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular
     * {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextTriangularRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L3060" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3061" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3062" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3063" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3064">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L3065">        IntStream.range(0, howMany)</span>
<span class="fc" id="L3066">            .forEach(i -&gt; matrices.add(nextTriangularRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L3067">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal
     * {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextDiagonalRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextDiagonalRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L3098" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3099" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3100" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3101" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3102">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L3103">        IntStream.range(0, howMany).forEach(i -&gt; matrices.add(nextDiagonalRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L3104">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric
     * {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSymmetricRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextSymmetricRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L3135" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3136" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3137" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3138" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3139">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L3140">        IntStream.range(0, howMany)</span>
<span class="fc" id="L3141">            .forEach(i -&gt; matrices.add(nextSymmetricRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L3142">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing
     * skew-symmetric {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting
     *            {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric
     *         {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextSkewSymmetricRealComplexNumberMatrices(final long bound, final int scale,
        final int size, final int howMany) {
<span class="fc bfc" id="L3173" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3174" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3175" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3176" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3177">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc" id="L3178">        IntStream.range(0, howMany)</span>
<span class="fc" id="L3179">            .forEach(i -&gt; matrices.add(nextSkewSymmetricRealComplexNumberMatrix(bound, scale, size)));</span>
<span class="fc" id="L3180">        return matrices;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L3185">        return MoreObjects.toStringHelper(this).add(&quot;random&quot;, random).toString();</span>
    }

    @VisibleForTesting
    Random getRandom() {
<span class="fc" id="L3190">        return random;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>