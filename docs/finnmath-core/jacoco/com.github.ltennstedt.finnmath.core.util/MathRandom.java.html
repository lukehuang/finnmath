<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MathRandom.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">finnMath Core</a> &gt; <a href="index.source.html" class="el_package">com.github.ltennstedt.finnmath.core.util</a> &gt; <span class="el_source">MathRandom.java</span></div><h1>MathRandom.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017 Lars Tennstedt
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.ltennstedt.finnmath.core.util;

import static com.google.common.base.Preconditions.checkArgument;

import com.github.ltennstedt.finnmath.core.linear.BigDecimalMatrix;
import com.github.ltennstedt.finnmath.core.linear.BigDecimalMatrix.BigDecimalMatrixBuilder;
import com.github.ltennstedt.finnmath.core.linear.BigDecimalVector;
import com.github.ltennstedt.finnmath.core.linear.BigDecimalVector.BigDecimalVectorBuilder;
import com.github.ltennstedt.finnmath.core.linear.BigIntegerMatrix;
import com.github.ltennstedt.finnmath.core.linear.BigIntegerVector;
import com.github.ltennstedt.finnmath.core.linear.BigIntegerVector.BigIntegerVectorBuilder;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberMatrix;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberMatrix.RealComplexNumberMatrixBuilder;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberVector;
import com.github.ltennstedt.finnmath.core.linear.RealComplexNumberVector.RealComplexNumberVectorBuilder;
import com.github.ltennstedt.finnmath.core.linear.SimpleComplexNumberMatrix;
import com.github.ltennstedt.finnmath.core.linear.SimpleComplexNumberMatrix.SimpleComplexNumberMatrixBuilder;
import com.github.ltennstedt.finnmath.core.linear.SimpleComplexNumberVector;
import com.github.ltennstedt.finnmath.core.number.Fraction;
import com.github.ltennstedt.finnmath.core.number.PolarForm;
import com.github.ltennstedt.finnmath.core.number.RealComplexNumber;
import com.github.ltennstedt.finnmath.core.number.SimpleComplexNumber;
import com.google.common.annotations.Beta;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.apache.commons.lang3.RandomUtils;

/**
 * A pseudo random generator for {@code long}, {@link BigDecimal}, {@link Fraction}, {@link SimpleComplexNumber}, {@link
 * RealComplexNumber}, {@link BigIntegerVector}, {@link BigDecimalVector}, {@link BigIntegerMatrix} and {@link
 * BigDecimalMatrix}
 *
 * @author Lars Tennstedt
 * @since 1
 */
@Beta
public final class MathRandom {
    private final Random random;

    /**
     * Default constructor
     *
     * @since 1
     */
<span class="fc" id="L69">    public MathRandom() {</span>
<span class="fc" id="L70">        random = new Random();</span>
<span class="fc" id="L71">    }</span>

    /**
     * Constructor which has the seed value as parameter
     *
     * @param seed
     *         The seed
     * @since 1
     */
<span class="fc" id="L80">    public MathRandom(final long seed) {</span>
<span class="fc" id="L81">        random = new Random(seed);</span>
<span class="fc" id="L82">    }</span>

    /**
     * Returns a positive {@link BigInteger} bounded below by {@code 0} (inclusive) and above by {@code bound}
     * (exclusive)
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link BigInteger}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @since 1
     */
    public BigInteger nextPositiveBigInteger(final long bound) {
<span class="fc bfc" id="L96" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L97">        return BigInteger.valueOf(RandomUtils.nextLong(0, bound));</span>
    }

    /**
     * Returns a negative {@link BigInteger} bounded below by {@code -bound} (exclusive) and above by {@code 0}
     * (inclusive)
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link BigInteger}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @see #nextPositiveBigInteger(long)
     * @since 1
     */
    public BigInteger nextNegativeBigInteger(final long bound) {
<span class="fc bfc" id="L113" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L114">        return nextPositiveBigInteger(bound).negate();</span>
    }

    /**
     * Returns a {@link BigInteger} bounded below by {@code -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link BigInteger}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @see #nextPositiveBigInteger(long)
     * @see #nextNegativeBigInteger(long)
     * @since 1
     */
    public BigInteger nextBigInteger(final long bound) {
<span class="fc bfc" id="L130" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L132">            return nextNegativeBigInteger(bound);</span>
        }
<span class="fc" id="L134">        return nextPositiveBigInteger(bound);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link BigInteger BigIntegers}
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigInteger BigIntegers}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextPositiveBigInteger(long)
     * @since 1
     */
    public List&lt;BigInteger&gt; nextPositiveBigIntegers(final long bound, final int howMany) {
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L155">        final List&lt;BigInteger&gt; integers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L157">            integers.add(nextPositiveBigInteger(bound));</span>
        }
<span class="fc" id="L159">        return integers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link BigInteger BigIntegers}
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigInteger BigIntegers}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextNegativeBigInteger(long)
     * @since 1
     */
    public List&lt;BigInteger&gt; nextNegativeBigIntegers(final long bound, final int howMany) {
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L180">        final List&lt;BigInteger&gt; integers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L182">            integers.add(nextNegativeBigInteger(bound));</span>
        }
<span class="fc" id="L184">        return integers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigInteger BigIntegers}
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigInteger BigIntegers}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public List&lt;BigInteger&gt; nextBigIntegers(final long bound, final int howMany) {
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L205">        final List&lt;BigInteger&gt; integers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L207">            integers.add(nextBigInteger(bound));</span>
        }
<span class="fc" id="L209">        return integers;</span>
    }

    /**
     * Returns a positive {@link BigDecimal} of a given {@code scale} bounded below by {@code 0} (inclusive) and above
     * by {@code bound} (exclusive)
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @since 1
     */
    public BigDecimal nextPositiveBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L228" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L230">        final BigDecimal decimal = nextBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &lt; 0) {</span>
<span class="nc" id="L232">            return decimal.negate();</span>
        }
<span class="fc" id="L234">        return decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} of a given {@code scale} bounded below by {@code -bound} (exclusive) and
     * above by {@code 0} (inclusive)
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @since 1
     */
    public BigDecimal nextNegativeBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L253" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L255">        final BigDecimal decimal = nextBigDecimal(bound, scale);</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (decimal.compareTo(BigDecimal.ZERO) &gt; 0) {</span>
<span class="fc" id="L257">            return decimal.negate();</span>
        }
<span class="fc" id="L259">        return decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} of a given {@code scale} bounded below by {@code -bound} (exclusive) and above by
     * {@code bound} (exclusive)
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @since 1
     */
    public BigDecimal nextBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L278" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L280">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L281">        return keepBigDecimalInBound(decimal, bound).setScale(scale, RoundingMode.HALF_UP);</span>
    }

    /**
     * Returns a positive {@link BigDecimal} which is invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @see #nextPositiveBigDecimal
     * @since 1
     */
    public BigDecimal nextInvertiblePositiveBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L300" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L302">        final BigDecimal decimal = nextInvertibleBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &lt; 0) {</span>
<span class="nc" id="L304">            return decimal.negate();</span>
        }
<span class="fc" id="L306">        return decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} which is invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @see #nextNegativeBigDecimal
     * @see #nextInvertibleBigDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleNegativeBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L326" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L328">        final BigDecimal decimal = nextInvertibleBigDecimal(bound, scale);</span>
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &gt; 0) {</span>
<span class="fc" id="L330">            return decimal.negate();</span>
        }
<span class="nc" id="L332">        return decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} which is invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @see #nextBigDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleBigDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L351" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L353">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L354">        return keepBigDecimalInBound(decimal, bound).setScale(scale, RoundingMode.HALF_UP);</span>
    }

    @VisibleForTesting
    BigDecimal keepBigDecimalInBound(final BigDecimal decimal, final long bound) {
<span class="fc" id="L359">        BigDecimal result = decimal;</span>
<span class="fc" id="L360">        final BigDecimal decimalBound = BigDecimal.valueOf(bound);</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (result.compareTo(BigDecimal.ZERO) &gt; -1) {</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">            while (result.compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L363">                result = result.subtract(decimalBound);</span>
            }
        } else {
<span class="fc bfc" id="L366" title="All 2 branches covered.">            while (result.abs().compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L367">                result = result.add(decimalBound);</span>
            }
        }
<span class="fc" id="L370">        return result;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link BigDecimal BigDecimals}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextPositiveBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextPositiveBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L393" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L396">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L398">            decimals.add(nextPositiveBigDecimal(bound, scale));</span>
        }
<span class="fc" id="L400">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link BigDecimal BigDecimals}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextNegativeBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextNegativeBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L423" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L426">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L428">            decimals.add(nextNegativeBigDecimal(bound, scale));</span>
        }
<span class="fc" id="L430">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigDecimal BigDecimals}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L453" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L456">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L458">            decimals.add(nextBigDecimal(bound, scale));</span>
        }
<span class="fc" id="L460">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link BigDecimal BigDecimals} which
     * are invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertiblePositiveBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertiblePositiveBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L484" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L487">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L489">            decimals.add(nextInvertiblePositiveBigDecimal(bound, scale));</span>
        }
<span class="fc" id="L491">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link BigDecimal BigDecimals} which
     * are invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertibleNegativeBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleNegativeBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L515" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L518">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L520">            decimals.add(nextInvertibleNegativeBigDecimal(bound, scale));</span>
        }
<span class="fc" id="L522">        return decimals;</span>
    }

    /**
     * Returns a {@code List} of the size of {@code howMany} containing {@link BigDecimal BigDecimals} which are
     * invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertibleBigDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleBigDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L546" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L549">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L551">            decimals.add(nextInvertibleBigDecimal(bound, scale));</span>
        }
<span class="fc" id="L553">        return decimals;</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by {@code 0} (inclusive) and above by {@code
     * bound} (exclusive) and whose {@code denominator} is bounded below {@code 1} (inclusive) and {@code bound}
     * (exclusive)
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @since 1
     */
    public Fraction nextPositiveFraction(final long bound) {
<span class="fc bfc" id="L569" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L570">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L571">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L572">        return new Fraction(numerator, denominator);</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by {@code -bound} (exclusive) and above by
     * {@code 0} (inclusive) and whose {@code denominator} is bounded below {@code 1} (inclusive) and {@code bound}
     * (exclusive)
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @since 1
     */
    public Fraction nextNegativeFraction(final long bound) {
<span class="fc bfc" id="L588" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L589">        return nextPositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by {@code -bound} (exclusive) and above by
     * {@code bound} (exclusive) and whose {@code denominator} is bounded below {@code -bound} (exclusive) and {@code
     * bound} (exclusive)
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @since 1
     */
    public Fraction nextFraction(final long bound) {
<span class="fc bfc" id="L605" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L607">            return nextNegativeFraction(bound);</span>
        }
<span class="fc" id="L609">        return nextPositiveFraction(bound);</span>
    }

    /**
     * Returns a positive {@link Fraction} which is invertible
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @see #nextPositiveFraction
     * @since 1
     */
    public Fraction nextInvertiblePositiveFraction(final long bound) {
<span class="fc bfc" id="L624" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L625">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L626">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L627">        return new Fraction(numerator, denominator);</span>
    }

    /**
     * Returns a negative {@link Fraction} which is invertible
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @see #nextNegativeFraction
     * @since 1
     */
    public Fraction nextInvertibleNegativeFraction(final long bound) {
<span class="fc bfc" id="L642" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L643">        return nextInvertiblePositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} which is invertible
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 2}
     * @see #nextFraction
     * @since 1
     */
    public Fraction nextInvertibleFraction(final long bound) {
<span class="fc bfc" id="L658" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L660">            return nextInvertibleNegativeFraction(bound);</span>
        }
<span class="fc" id="L662">        return nextInvertiblePositiveFraction(bound);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link Fraction Fractions}
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextPositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextPositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L681" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L683">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L685">            fractions.add(nextPositiveFraction(bound));</span>
        }
<span class="fc" id="L687">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link Fraction Fractions}
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L706" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L708">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L710">            fractions.add(nextNegativeFraction(bound));</span>
        }
<span class="fc" id="L712">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link Fraction Fractions}
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L731" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L733">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L735">            fractions.add(nextFraction(bound));</span>
        }
<span class="fc" id="L737">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link Fraction Fractions} which are
     * invertible
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertiblePositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertiblePositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L757" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L759">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L761">            fractions.add(nextInvertiblePositiveFraction(bound));</span>
        }
<span class="fc" id="L763">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link Fraction Fractions} which are
     * invertible
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertibleNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L783" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L785">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L787">            fractions.add(nextInvertibleNegativeFraction(bound));</span>
        }
<span class="fc" id="L789">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link Fraction Fractions} which are invertible
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertibleFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L808" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L810">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L812">            fractions.add(nextInvertibleFraction(bound));</span>
        }
<span class="fc" id="L814">        return fractions;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} whose {@code real} and {@code imaginary} part are bounded below by {@code
     * -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public SimpleComplexNumber nextSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L830" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L831">        return new SimpleComplexNumber(nextBigInteger(bound), nextBigInteger(bound));</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} which is invertible
     *
     * @param bound
     *         the bound
     * @return A pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public SimpleComplexNumber nextInvertibleSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L846" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L847">        final BigInteger nonZeroPart = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L848">        final BigInteger possibleZeroPart = nextBigInteger(bound);</span>
<span class="fc bfc" id="L849" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L850">            return new SimpleComplexNumber(possibleZeroPart, nonZeroPart);</span>
        }
<span class="fc" id="L852">        return new SimpleComplexNumber(nonZeroPart, possibleZeroPart);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumber
     * SimpleComplexNumbers}
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A List {@link List} of pseudo random {@link SimpleComplexNumber SimpleComplexNumbers}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L872" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L873" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L874">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L875" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L876">            complexNumbers.add(nextSimpleComplexNumber(bound));</span>
        }
<span class="fc" id="L878">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumber SimpleComplexNumbers}
     * which are invertible
     *
     * @param bound
     *         the bound
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumber SimpleComplexNumbers}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertibleSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextInvertibleSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L898" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L900">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L902">            complexNumbers.add(nextInvertibleSimpleComplexNumber(bound));</span>
        }
<span class="fc" id="L904">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link RealComplexNumber} whose {@code real} and {@code imaginary} part are bounded below by {@code
     * -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @since 1
     */
    public RealComplexNumber nextRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L921" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L922" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L923">        final BigDecimal real = nextBigDecimal(bound, scale);</span>
<span class="fc" id="L924">        final BigDecimal imaginary = nextBigDecimal(bound, scale);</span>
<span class="fc" id="L925">        return new RealComplexNumber(real, imaginary);</span>
    }

    /**
     * Returns a {@link RealComplexNumber} which is invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @see #nextRealComplexNumber
     * @since 1
     */
    public RealComplexNumber nextInvertibleRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L942" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L944">        final BigDecimal nonZeroPart = nextInvertibleBigDecimal(bound, scale);</span>
        final BigDecimal possibleZeroPart =
<span class="fc bfc" id="L946" title="All 2 branches covered.">                random.nextBoolean() ? nextInvertibleBigDecimal(bound, scale) : nextBigDecimal(bound, scale);</span>
<span class="fc bfc" id="L947" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L948">            return new RealComplexNumber(possibleZeroPart, nonZeroPart);</span>
        }
<span class="fc" id="L950">        return new RealComplexNumber(nonZeroPart, possibleZeroPart);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumber RealComplexNumbers}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber RealComplexNumbers}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextRealComplexNumbers(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L973" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L974" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L976">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L977" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L978">            complexNumbers.add(nextRealComplexNumber(bound, scale));</span>
        }
<span class="fc" id="L980">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumber RealComplexNumbers}
     * which are invertible
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber RealComplexNumbers}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextInvertibleRealComplexNumbers(final long bound, final int scale,
            final int howMany) {
<span class="fc bfc" id="L1005" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1008">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1009" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1010">            complexNumbers.add(nextInvertibleRealComplexNumber(bound, scale));</span>
        }
<span class="fc" id="L1012">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link PolarForm}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A {@link PolarForm}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public PolarForm nextPolarForm(final long bound, final int scale) {
<span class="fc bfc" id="L1031" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1032" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L1033">        return new PolarForm(nextBigDecimal(bound, scale), nextBigDecimal(bound, scale));</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link PolarForm PolarForms}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber RealComplexNumbers}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public List&lt;PolarForm&gt; nextPolarForms(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L1056" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1057" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1058" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1059">        final List&lt;PolarForm&gt; polarForms = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1060" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1061">            polarForms.add(nextPolarForm(bound, scale));</span>
        }
<span class="fc" id="L1063">        return polarForms;</span>
    }

    /**
     * Returns a {@link BigIntegerVector}
     *
     * @param bound
     *         the bound
     * @param size
     *         the size of the resulting {@link BigIntegerVector}
     * @return A pseudo random {@link BigIntegerVector}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public BigIntegerVector nextBigIntegerVector(final long bound, final int size) {
<span class="fc bfc" id="L1082" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1084">        final BigIntegerVectorBuilder builder = BigIntegerVector.builder(size);</span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1086">            builder.put(nextBigInteger(bound));</span>
        }
<span class="fc" id="L1088">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigIntegerVector BigIntegerVectors}
     *
     * @param bound
     *         the bound
     * @param size
     *         the sizes of the resulting {@link BigIntegerVector BigIntegerVectors}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigIntegerVector BigIntegerVectors}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextBigIntegerVector
     * @since 1
     */
    public List&lt;BigIntegerVector&gt; nextBigIntegerVectors(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1109" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1110" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1111" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1112">        final List&lt;BigIntegerVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1113" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1114">            vectors.add(nextBigIntegerVector(bound, size));</span>
        }
<span class="fc" id="L1116">        return vectors;</span>
    }

    /**
     * Returns a {@link BigIntegerMatrix}
     *
     * @param bound
     *         the bound
     * @param rowSize
     *         the row size of the resulting {@link BigIntegerMatrix}
     * @param columnSize
     *         the column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @see #nextBigInteger(long)
     * @since 1
     */
    public BigIntegerMatrix nextBigIntegerMatrix(final long bound, final int rowSize, final int columnSize) {
<span class="fc bfc" id="L1139" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1140" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1141" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L1142">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L1143">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1144">                rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L1145">                        .forEach(columnIndex -&gt; builder.put(rowIndex, columnIndex, nextBigInteger(bound))));</span>
<span class="fc" id="L1146">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link BigIntegerMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of resulting {@link BigIntegerMatrix}
     * @return A pseudo random upper triangular {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextBigInteger(long)
     * @see BigIntegerMatrix#upperTriangular
     * @since 1
     */
    public BigIntegerMatrix nextUpperTriangularBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1166" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1167" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1168">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1169">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1170">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">                    if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L1172">                        builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
                    } else {
<span class="fc" id="L1174">                        builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                    }
<span class="fc" id="L1176">                }));</span>
<span class="fc" id="L1177">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link BigIntegerMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random lower triangular {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextBigInteger(long)
     * @see BigIntegerMatrix#lowerTriangular
     * @since 1
     */
    public BigIntegerMatrix nextLowerTriangularBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1197" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1198" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1199">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1200">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1201">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1202" title="All 2 branches covered.">                    if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L1203">                        builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
                    } else {
<span class="fc" id="L1205">                        builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                    }
<span class="fc" id="L1207">                }));</span>
<span class="fc" id="L1208">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link BigIntegerMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random triangular {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextUpperTriangularBigIntegerMatrix
     * @see #nextLowerTriangularBigIntegerMatrix
     * @see BigIntegerMatrix#triangular
     * @since 1
     */
    public BigIntegerMatrix nextTriangularBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1229" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1230" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1231" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L1232">            return nextLowerTriangularBigIntegerMatrix(bound, size);</span>
        }
<span class="fc" id="L1234">        return nextUpperTriangularBigIntegerMatrix(bound, size);</span>
    }

    /**
     * Returns a diagonal {@link BigIntegerMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random diagonal {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see BigIntegerMatrix#diagonal
     * @since 1
     */
    public BigIntegerMatrix nextDiagonalBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1253" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1254" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1255">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1256">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1257">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1258" title="All 2 branches covered.">                    if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1259">                        builder.put(rowIndex, columnIndex, nextBigInteger(bound));</span>
                    } else {
<span class="fc" id="L1261">                        builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                    }
<span class="fc" id="L1263">                }));</span>
<span class="fc" id="L1264">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link BigIntegerMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random symmetric {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see BigIntegerMatrix#symmetric
     * @since 1
     */
    public BigIntegerMatrix nextSymmetricBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1283" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1284" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1285">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1286">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1287">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1288">                    final BigInteger element = nextBigInteger(bound);</span>
<span class="fc bfc" id="L1289" title="All 2 branches covered.">                    if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1290">                        builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1291">                        builder.put(columnIndex, rowIndex, element);</span>
                    }
<span class="fc bfc" id="L1293" title="All 2 branches covered.">                    if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1294">                        builder.put(rowIndex, columnIndex, element);</span>
                    }
<span class="fc" id="L1296">                }));</span>
<span class="fc" id="L1297">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link BigIntegerMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix}
     * @return A pseudo random skew-symmetric {@link BigIntegerMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see BigIntegerMatrix#skewSymmetric
     * @since 1
     */
    public BigIntegerMatrix nextSkewSymmetricBigIntegerMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1316" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1317" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1318">        final BigIntegerMatrix.BigIntegerMatrixBuilder builder = BigIntegerMatrix.builder(size, size);</span>
<span class="fc" id="L1319">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1320">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1321" title="All 2 branches covered.">                    if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1322">                        final BigInteger element = nextBigInteger(bound);</span>
<span class="fc" id="L1323">                        builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1324">                        builder.put(columnIndex, rowIndex, element.negate());</span>
                    }
<span class="fc bfc" id="L1326" title="All 2 branches covered.">                    if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1327">                        builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                    }
<span class="fc" id="L1329">                }));</span>
<span class="fc" id="L1330">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigIntegerMatrix BigIntegerMatrices}
     *
     * @param bound
     *         the bound
     * @param rowSize
     *         the row size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param columnSize
     *         the column size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextBigIntegerMatrices(final long bound, final int rowSize, final int columnSize,
            final int howMany) {
<span class="fc bfc" id="L1358" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1359" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1360" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1361" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1362">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1363" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1364">            matrices.add(nextBigIntegerMatrix(bound, rowSize, columnSize));</span>
        }
<span class="fc" id="L1366">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular {@link BigIntegerMatrix
     * BigIntegerMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextUpperTriangularBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextUpperTriangularBigIntegerMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L1391" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1392" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1393" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1394">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1395" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1396">            matrices.add(nextUpperTriangularBigIntegerMatrix(bound, size));</span>
        }
<span class="fc" id="L1398">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular {@link BigIntegerMatrix
     * BigIntegerMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextLowerTriangularBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextLowerTriangularBigIntegerMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L1423" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1424" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1425" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1426">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1427" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1428">            matrices.add(nextLowerTriangularBigIntegerMatrix(bound, size));</span>
        }
<span class="fc" id="L1430">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular {@link BigIntegerMatrix
     * BigIntegerMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextTriangularBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextTriangularBigIntegerMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L1455" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1456" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1457" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1458">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1459" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1460">            matrices.add(nextTriangularBigIntegerMatrix(bound, size));</span>
        }
<span class="fc" id="L1462">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal {@link BigIntegerMatrix
     * BigIntegerMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextDiagonalBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextDiagonalBigIntegerMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1486" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1487" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1488" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1489">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1490" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1491">            matrices.add(nextDiagonalBigIntegerMatrix(bound, size));</span>
        }
<span class="fc" id="L1493">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric {@link BigIntegerMatrix
     * BigIntegerMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSymmetricBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextSymmetricBigIntegerMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1517" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1518" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1519" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1520">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1521" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1522">            matrices.add(nextSymmetricBigIntegerMatrix(bound, size));</span>
        }
<span class="fc" id="L1524">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric {@link BigIntegerMatrix
     * BigIntegerMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link BigIntegerMatrix BigIntegerMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link BigIntegerMatrix BigIntegerMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricBigIntegerMatrix
     * @since 1
     */
    public List&lt;BigIntegerMatrix&gt; nextSkewSymmetricBigIntegerMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L1549" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1550" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1551" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1552">        final List&lt;BigIntegerMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1553" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1554">            matrices.add(nextSkewSymmetricBigIntegerMatrix(bound, size));</span>
        }
<span class="fc" id="L1556">        return matrices;</span>
    }

    /**
     * Returns a {@link BigDecimalVector}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param size
     *         the size of the resulting {@link BigDecimalVector}
     * @return A speudo random {@link BigDecimalVector}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextBigDecimal
     * @since 1
     */
    public BigDecimalVector nextBigDecimalVector(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1579" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1580" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1581" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1582">        final BigDecimalVectorBuilder builder = BigDecimalVector.builder(size);</span>
<span class="fc bfc" id="L1583" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1584">            builder.put(nextBigDecimal(bound, scale));</span>
        }
<span class="fc" id="L1586">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigDecimalVector BigDecimalVectors}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param size
     *         the size of the resulting {@link BigDecimalVector BigDecimalVectors}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimalVector BigDecimalVectors}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextBigDecimalVector
     * @since 1
     */
    public List&lt;BigDecimalVector&gt; nextBigDecimalVectors(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L1616" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1617" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1618" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1619" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1620">        final List&lt;BigDecimalVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1621" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1622">            vectors.add(nextBigDecimalVector(bound, scale, size));</span>
        }
<span class="fc" id="L1624">        return vectors;</span>
    }

    /**
     * Returns a {@link BigDecimalMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param rowSize
     *         the row size of the resulting {@link BigDecimalMatrix}
     * @param columnSize
     *         the column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @see #nextBigDecimal
     * @since 1
     */
    public BigDecimalMatrix nextBigDecimalMatrix(final long bound, final int scale, final int rowSize,
            final int columnSize) {
<span class="fc bfc" id="L1652" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1653" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1654" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1655" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L1656">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L1657">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1658">                rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L1659">                        .forEach(columnIndex -&gt; builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale))));</span>
<span class="fc" id="L1660">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link BigDecimalMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of resulting {@link BigDecimalMatrix}
     * @return A pseudo random upper triangular {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextBigDecimal
     * @see BigDecimalMatrix#upperTriangular
     * @since 1
     */
    public BigDecimalMatrix nextUpperTriangularBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1684" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1685" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1686">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1687">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1688">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1689" title="All 2 branches covered.">                    if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L1690">                        builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
                    } else {
<span class="fc" id="L1692">                        builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                    }
<span class="fc" id="L1694">                }));</span>
<span class="fc" id="L1695">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link BigDecimalMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random lower triangular {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextBigDecimal
     * @see BigDecimalMatrix#lowerTriangular
     * @since 1
     */
    public BigDecimalMatrix nextLowerTriangularBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1719" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1720" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1721">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1722">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1723">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1724" title="All 2 branches covered.">                    if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L1725">                        builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
                    } else {
<span class="fc" id="L1727">                        builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                    }
<span class="fc" id="L1729">                }));</span>
<span class="fc" id="L1730">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link BigDecimalMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random triangular {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextUpperTriangularBigDecimalMatrix
     * @see #nextLowerTriangularBigDecimalMatrix
     * @see BigDecimalMatrix#triangular
     * @since 1
     */
    public BigDecimalMatrix nextTriangularBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1755" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1756" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1757" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L1758">            return nextLowerTriangularBigDecimalMatrix(bound, scale, size);</span>
        }
<span class="fc" id="L1760">        return nextUpperTriangularBigDecimalMatrix(bound, scale, size);</span>
    }

    /**
     * Returns a diagonal {@link BigDecimalMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random diagonal {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see BigDecimalMatrix#diagonal
     * @since 1
     */
    public BigDecimalMatrix nextDiagonalBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1783" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1784" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1785">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1786">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1787">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1788" title="All 2 branches covered.">                    if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1789">                        builder.put(rowIndex, columnIndex, nextBigDecimal(bound, scale));</span>
                    } else {
<span class="fc" id="L1791">                        builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                    }
<span class="fc" id="L1793">                }));</span>
<span class="fc" id="L1794">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link BigDecimalMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random symmetric {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see BigDecimalMatrix#symmetric
     * @since 1
     */
    public BigDecimalMatrix nextSymmetricBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1817" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1818" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1819">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1820">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1821">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1822">                    final BigDecimal element = nextBigDecimal(bound, scale);</span>
<span class="fc bfc" id="L1823" title="All 2 branches covered.">                    if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1824">                        builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1825">                        builder.put(columnIndex, rowIndex, element);</span>
                    }
<span class="fc bfc" id="L1827" title="All 2 branches covered.">                    if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1828">                        builder.put(rowIndex, columnIndex, element);</span>
                    }
<span class="fc" id="L1830">                }));</span>
<span class="fc" id="L1831">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link BigDecimalMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix}
     * @return A pseudo random skew-symmetric {@link BigDecimalMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see BigDecimalMatrix#skewSymmetric
     * @since 1
     */
    public BigDecimalMatrix nextSkewSymmetricBigDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1854" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1855" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1856">        final BigDecimalMatrixBuilder builder = BigDecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1857">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L1858">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1859" title="All 2 branches covered.">                    if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1860">                        final BigDecimal element = nextBigDecimal(bound, scale);</span>
<span class="fc" id="L1861">                        builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1862">                        builder.put(columnIndex, rowIndex, element.negate());</span>
                    }
<span class="fc bfc" id="L1864" title="All 2 branches covered.">                    if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1865">                        builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                    }
<span class="fc" id="L1867">                }));</span>
<span class="fc" id="L1868">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigDecimalMatrix BigDecimalMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale to be set on the {@link BigDecimal BigDecimals}
     * @param rowSize
     *         the row size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param columnSize
     *         the column size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextBigDecimalMatrices(final long bound, final int scale, final int rowSize,
            final int columnSize, final int howMany) {
<span class="fc bfc" id="L1900" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1901" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1902" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1903" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1904" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1905">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1906" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1907">            matrices.add(nextBigDecimalMatrix(bound, scale, rowSize, columnSize));</span>
        }
<span class="fc" id="L1909">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular {@link BigDecimalMatrix
     * BigDecimalMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextUpperTriangularBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextUpperTriangularBigDecimalMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L1938" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1939" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1940" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1941" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1942">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1943" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1944">            matrices.add(nextUpperTriangularBigDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L1946">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular {@link BigDecimalMatrix
     * BigDecimalMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextLowerTriangularBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextLowerTriangularBigDecimalMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L1975" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1976" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1977" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1978" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1979">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1980" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1981">            matrices.add(nextLowerTriangularBigDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L1983">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular {@link BigDecimalMatrix
     * BigDecimalMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextTriangularBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextTriangularBigDecimalMatrices(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2012" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2013" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2014" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2015" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2016">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2017" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2018">            matrices.add(nextTriangularBigDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2020">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal {@link BigDecimalMatrix
     * BigDecimalMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextDiagonalBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextDiagonalBigDecimalMatrices(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2049" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2050" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2051" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2052" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2053">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2054" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2055">            matrices.add(nextDiagonalBigDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2057">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric {@link BigDecimalMatrix
     * BigDecimalMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSymmetricBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextSymmetricBigDecimalMatrices(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2086" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2087" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2088" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2089" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2090">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2091" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2092">            matrices.add(nextSymmetricBigDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2094">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric {@link BigDecimalMatrix
     * BigDecimalMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link BigDecimalMatrix BigDecimalMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link BigDecimalMatrix BigDecimalMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricBigDecimalMatrix
     * @since 1
     */
    public List&lt;BigDecimalMatrix&gt; nextSkewSymmetricBigDecimalMatrices(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2123" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2124" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2125" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2126" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2127">        final List&lt;BigDecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2128" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2129">            matrices.add(nextSkewSymmetricBigDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2131">        return matrices;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumberVector}
     *
     * @param bound
     *         the bound
     * @param size
     *         the size of the resulting {@link SimpleComplexNumberVector}
     * @return A pseudo random {@link SimpleComplexNumberVector}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextSimpleComplexNumber(long)
     * @since 1
     */
    public SimpleComplexNumberVector nextSimpleComplexNumberVector(final long bound, final int size) {
<span class="fc bfc" id="L2150" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2151" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2152">        final SimpleComplexNumberVector.SimpleComplexNumberVectorBuilder builder =</span>
<span class="fc" id="L2153">                SimpleComplexNumberVector.builder(size);</span>
<span class="fc bfc" id="L2154" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L2155">            builder.put(nextSimpleComplexNumber(bound));</span>
        }
<span class="fc" id="L2157">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumberVector
     * SimpleComplexNumberVectors}
     *
     * @param bound
     *         the bound
     * @param size
     *         the sizes of the resulting {@link SimpleComplexNumberVector SimpleComplexNumberVectors}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumberVector SimpleComplexNumberVectors}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextSimpleComplexNumberVector
     * @since 1
     */
    public List&lt;SimpleComplexNumberVector&gt; nextSimpleComplexNumberVectors(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L2180" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2181" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2182" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2183">        final List&lt;SimpleComplexNumberVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2184" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2185">            vectors.add(nextSimpleComplexNumberVector(bound, size));</span>
        }
<span class="fc" id="L2187">        return vectors;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param rowSize
     *         the row size of the resulting {@link SimpleComplexNumberMatrix}
     * @param columnSize
     *         the column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @see #nextSimpleComplexNumber(long)
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSimpleComplexNumberMatrix(final long bound, final int rowSize,
            final int columnSize) {
<span class="fc bfc" id="L2211" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2212" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2213" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L2214">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L2215">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2216">                rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList())</span>
<span class="fc" id="L2217">                        .forEach(columnIndex -&gt; builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound))));</span>
<span class="fc" id="L2218">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random upper triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#upperTriangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextUpperTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2237" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2238" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2239">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2240">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2241">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2242" title="All 2 branches covered.">                    if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L2243">                        builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                    } else {
<span class="fc" id="L2245">                        builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                    }
<span class="fc" id="L2247">                }));</span>
<span class="fc" id="L2248">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random lower triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#lowerTriangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextLowerTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2267" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2268" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2269">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2270">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2271">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2272" title="All 2 branches covered.">                    if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L2273">                        builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                    } else {
<span class="fc" id="L2275">                        builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                    }
<span class="fc" id="L2277">                }));</span>
<span class="fc" id="L2278">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextUpperTriangularSimpleComplexNumberMatrix
     * @see #nextLowerTriangularSimpleComplexNumberMatrix
     * @see SimpleComplexNumberMatrix#triangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2299" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2300" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2301" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L2302">            return nextLowerTriangularSimpleComplexNumberMatrix(bound, size);</span>
        }
<span class="fc" id="L2304">        return nextUpperTriangularSimpleComplexNumberMatrix(bound, size);</span>
    }

    /**
     * Returns a diagonal {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random diagonal {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#diagonal
     * @since 1
     */
    public SimpleComplexNumberMatrix nextDiagonalSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2323" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2324" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2325">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2326">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2327">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2328" title="All 2 branches covered.">                    if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2329">                        builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                    } else {
<span class="fc" id="L2331">                        builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                    }
<span class="fc" id="L2333">                }));</span>
<span class="fc" id="L2334">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random symmetric {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#symmetric
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSymmetricSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2353" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2354" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2355">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2356">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2357">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L2358">                    final SimpleComplexNumber element = nextSimpleComplexNumber(bound);</span>
<span class="fc bfc" id="L2359" title="All 2 branches covered.">                    if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L2360">                        builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2361">                        builder.put(columnIndex, rowIndex, element);</span>
                    }
<span class="fc bfc" id="L2363" title="All 2 branches covered.">                    if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2364">                        builder.put(rowIndex, columnIndex, element);</span>
                    }
<span class="fc" id="L2366">                }));</span>
<span class="fc" id="L2367">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random skew-symmetric {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see SimpleComplexNumberMatrix#skewSymmetric
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSkewSymmetricSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2386" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2387" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2388">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2389">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2390">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2391" title="All 2 branches covered.">                    if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L2392">                        final SimpleComplexNumber element = nextSimpleComplexNumber(bound);</span>
<span class="fc" id="L2393">                        builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2394">                        builder.put(columnIndex, rowIndex, element.negate());</span>
                    }
<span class="fc bfc" id="L2396" title="All 2 branches covered.">                    if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2397">                        builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                    }
<span class="fc" id="L2399">                }));</span>
<span class="fc" id="L2400">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param rowSize
     *         the row size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param columnSize
     *         the column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSimpleComplexNumberMatrices(final long bound, final int rowSize,
            final int columnSize, final int howMany) {
<span class="fc bfc" id="L2429" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2430" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2431" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L2432" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2433">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2434" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2435">            matrices.add(nextSimpleComplexNumberMatrix(bound, rowSize, columnSize));</span>
        }
<span class="fc" id="L2437">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular {@link
     * SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextUpperTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextUpperTriangularSimpleComplexNumberMatrices(final long bound,
            final int size, final int howMany) {
<span class="fc bfc" id="L2463" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2464" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2465" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2466">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2467" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2468">            matrices.add(nextUpperTriangularSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2470">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular {@link
     * SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextLowerTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextLowerTriangularSimpleComplexNumberMatrices(final long bound,
            final int size, final int howMany) {
<span class="fc bfc" id="L2496" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2497" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2498" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2499">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2500" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2501">            matrices.add(nextLowerTriangularSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2503">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextTriangularSimpleComplexNumberMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L2528" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2529" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2530" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2531">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2532" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2533">            matrices.add(nextTriangularSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2535">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextDiagonalSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextDiagonalSimpleComplexNumberMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L2560" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2561" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2562" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2563">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2564" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2565">            matrices.add(nextDiagonalSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2567">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSymmetricSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSymmetricSimpleComplexNumberMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L2592" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2593" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2594" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2595">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2596" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2597">            matrices.add(nextSymmetricSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2599">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param size
     *         the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSkewSymmetricSimpleComplexNumberMatrices(final long bound,
            final int size, final int howMany) {
<span class="fc bfc" id="L2625" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2626" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2627" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2628">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2629" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2630">            matrices.add(nextSkewSymmetricSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2632">        return matrices;</span>
    }

    /**
     * Returns a {@link RealComplexNumberVector}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the size of the resulting {@link RealComplexNumberVector}
     * @return A pseudo random {@link RealComplexNumberVector}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @since 1
     */
    public RealComplexNumberVector nextRealComplexNumberVector(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L2655" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2656" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2657" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2658">        final RealComplexNumberVectorBuilder builder = RealComplexNumberVector.builder(size);</span>
<span class="fc bfc" id="L2659" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L2660">            builder.put(nextRealComplexNumber(bound, scale));</span>
        }
<span class="fc" id="L2662">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumberVector
     * RealComplexNumberVectors}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the sizes of the resulting {@link RealComplexNumberVector RealComplexNumberVectors}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumberVector RealComplexNumberVectors}
     * @throws IllegalArgumentException
     *         if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 2}
     * @see #nextRealComplexNumberVector
     * @since 1
     */
    public List&lt;RealComplexNumberVector&gt; nextRealComplexNumberVectors(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2689" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2690" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2691" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2692" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2693">        final List&lt;RealComplexNumberVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2694" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2695">            vectors.add(nextRealComplexNumberVector(bound, scale, size));</span>
        }
<span class="fc" id="L2697">        return vectors;</span>
    }

    /**
     * Returns a {@link RealComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param rowSize
     *         the row size of the resulting {@link RealComplexNumberMatrix}
     * @param columnSize
     *         the column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @since 1
     */
    public RealComplexNumberMatrix nextRealComplexNumberMatrix(final long bound, final int scale, final int rowSize,
            final int columnSize) {
<span class="fc bfc" id="L2725" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2726" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2727" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2728" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L2729">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L2730">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2731">                rowIndex -&gt; IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2732">                        columnIndex -&gt; builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale))));</span>
<span class="fc" id="L2733">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random upper triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @see RealComplexNumberMatrix#upperTriangular
     * @since 1
     */
    public RealComplexNumberMatrix nextUpperTriangularRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2758" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2759" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2760" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2761">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2762">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2763">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2764" title="All 2 branches covered.">                    if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L2765">                        builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                    } else {
<span class="fc" id="L2767">                        builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                    }
<span class="fc" id="L2769">                }));</span>
<span class="fc" id="L2770">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random lower triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextRealComplexNumber(long, int)
     * @see RealComplexNumberMatrix#lowerTriangular
     * @since 1
     */
    public RealComplexNumberMatrix nextLowerTriangularRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2795" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2796" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2797" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2798">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2799">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2800">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2801" title="All 2 branches covered.">                    if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L2802">                        builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                    } else {
<span class="fc" id="L2804">                        builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                    }
<span class="fc" id="L2806">                }));</span>
<span class="fc" id="L2807">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see #nextUpperTriangularRealComplexNumberMatrix
     * @see #nextLowerTriangularRealComplexNumberMatrix
     * @see RealComplexNumberMatrix#triangular
     * @since 1
     */
    public RealComplexNumberMatrix nextTriangularRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2833" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2834" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2835" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2836" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L2837">            return nextLowerTriangularRealComplexNumberMatrix(bound, scale, size);</span>
        }
<span class="fc" id="L2839">        return nextUpperTriangularRealComplexNumberMatrix(bound, scale, size);</span>
    }

    /**
     * Returns a diagonal {@link RealComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random diagonal {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see RealComplexNumberMatrix#diagonal
     * @since 1
     */
    public RealComplexNumberMatrix nextDiagonalRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2863" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2864" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2865" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2866">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2867">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2868">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2869" title="All 2 branches covered.">                    if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2870">                        builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                    } else {
<span class="fc" id="L2872">                        builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                    }
<span class="fc" id="L2874">                }));</span>
<span class="fc" id="L2875">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link RealComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random symmetric {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see RealComplexNumberMatrix#symmetric
     * @since 1
     */
    public RealComplexNumberMatrix nextSymmetricRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2899" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2900" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2901" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2902">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2903">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2904">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L2905">                    final RealComplexNumber element = nextRealComplexNumber(bound, scale);</span>
<span class="fc bfc" id="L2906" title="All 2 branches covered.">                    if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L2907">                        builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2908">                        builder.put(columnIndex, rowIndex, element);</span>
                    }
<span class="fc bfc" id="L2910" title="All 2 branches covered.">                    if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2911">                        builder.put(rowIndex, columnIndex, element);</span>
                    }
<span class="fc" id="L2913">                }));</span>
<span class="fc" id="L2914">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link RealComplexNumberMatrix}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random skew-symmetric {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @see RealComplexNumberMatrix#skewSymmetric
     * @since 1
     */
    public RealComplexNumberMatrix nextSkewSymmetricRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2938" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2939" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2940" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2941">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2942">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(</span>
<span class="fc" id="L2943">                rowIndex -&gt; IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2944" title="All 2 branches covered.">                    if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L2945">                        final RealComplexNumber element = nextRealComplexNumber(bound, scale);</span>
<span class="fc" id="L2946">                        builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2947">                        builder.put(columnIndex, rowIndex, element.negate());</span>
                    }
<span class="fc bfc" id="L2949" title="All 2 branches covered.">                    if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2950">                        builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                    }
<span class="fc" id="L2952">                }));</span>
<span class="fc" id="L2953">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param rowSize
     *         the row size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param columnSize
     *         the column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextRealComplexNumberMatrices(final long bound, final int scale,
            final int rowSize, final int columnSize, final int howMany) {
<span class="fc bfc" id="L2986" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2987" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2988" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2989" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L2990" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2991">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2992" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2993">            matrices.add(nextRealComplexNumberMatrix(bound, scale, rowSize, columnSize));</span>
        }
<span class="fc" id="L2995">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextUpperTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextUpperTriangularRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3025" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3026" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3027" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3028" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3029">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3030" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3031">            matrices.add(nextUpperTriangularRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3033">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextLowerTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextLowerTriangularRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3063" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3064" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3065" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3066" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3067">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3068" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3069">            matrices.add(nextLowerTriangularRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3071">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextTriangularRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3100" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3101" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3102" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3103" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3104">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3105" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3106">            matrices.add(nextTriangularRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3108">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextDiagonalRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextDiagonalRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3137" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3138" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3139" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3140" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3141">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3142" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3143">            matrices.add(nextDiagonalRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3145">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSymmetricRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextSymmetricRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3174" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3175" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3176" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3177" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3178">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3179" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3180">            matrices.add(nextSymmetricRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3182">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *         the bound
     * @param scale
     *         the scale
     * @param size
     *         the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *         the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *         if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *         if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *         if {@code howMany &lt; 1}
     * @see #nextSkewSymmetricRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextSkewSymmetricRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3211" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3212" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3213" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3214" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3215">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3216" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3217">            matrices.add(nextSkewSymmetricRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3219">        return matrices;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L3224">        return MoreObjects.toStringHelper(this).add(&quot;random&quot;, random).toString();</span>
    }

    @VisibleForTesting
    Random getRandom() {
<span class="fc" id="L3229">        return random;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>