<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MathRandom.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">finnMath</a> &gt; <a href="index.source.html" class="el_package">com.github.ltennstedt.finnmath.util</a> &gt; <span class="el_source">MathRandom.java</span></div><h1>MathRandom.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017 Lars Tennstedt
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.ltennstedt.finnmath.util;

import static com.google.common.base.Preconditions.checkArgument;

import com.github.ltennstedt.finnmath.linear.BigIntMatrix;
import com.github.ltennstedt.finnmath.linear.BigIntMatrix.BigIntMatrixBuilder;
import com.github.ltennstedt.finnmath.linear.BigIntVector;
import com.github.ltennstedt.finnmath.linear.BigIntVector.BigIntVectorBuilder;
import com.github.ltennstedt.finnmath.linear.DecimalMatrix;
import com.github.ltennstedt.finnmath.linear.DecimalMatrix.DecimalMatrixBuilder;
import com.github.ltennstedt.finnmath.linear.DecimalVector;
import com.github.ltennstedt.finnmath.linear.DecimalVector.DecimalVectorBuilder;
import com.github.ltennstedt.finnmath.number.Fraction;
import com.github.ltennstedt.finnmath.number.PolarForm;
import com.github.ltennstedt.finnmath.number.RealComplexNumber;
import com.github.ltennstedt.finnmath.number.SimpleComplexNumber;
import com.google.common.annotations.Beta;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.apache.commons.lang3.RandomUtils;

/**
 * A pseudo random generator for {@code long}, {@link BigDecimal}, {@link Fraction}, {@link SimpleComplexNumber},
 * {@link RealComplexNumber}, {@link BigIntVector}, {@link DecimalVector}, {@link BigIntMatrix} and
 * {@link DecimalMatrix}
 *
 * @author Lars Tennstedt
 * @since 1
 */
@Beta
public final class MathRandom {
    private final Random random;

    /**
     * Default constructor
     *
     * @author Lars Tennstedt
     * @since 1
     */
<span class="fc" id="L63">    public MathRandom() {</span>
<span class="fc" id="L64">        random = new Random();</span>
<span class="fc" id="L65">    }</span>

    /**
     * Constructor which has the seed value as parameter
     *
     * @param seed
     *            The seed
     * @author Lars Tennstedt
     * @since 1
     */
<span class="fc" id="L75">    public MathRandom(final long seed) {</span>
<span class="fc" id="L76">        random = new Random(seed);</span>
<span class="fc" id="L77">    }</span>

    /**
     * Returns a positive {@code long} bounded below by {@code 0} (inclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@code long}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @since 1
     */
    public long nextPositiveLong(final long bound) {
<span class="fc bfc" id="L91" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L92">        return RandomUtils.nextLong(0, bound);</span>
    }

    /**
     * Returns a negative {@code long} bounded below by {@code -bound} (exclusive) and above by {@code 0} (inclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@code long}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @since 1
     */
    public long nextNegativeLong(final long bound) {
<span class="fc bfc" id="L107" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L108">        return (-1) * RandomUtils.nextLong(0, bound);</span>
    }

    /**
     * Returns a {@code long} bounded below by {@code -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@code long}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @since 1
     */
    public long nextLong(final long bound) {
<span class="fc bfc" id="L123" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L125">            return nextNegativeLong(bound);</span>
        }
<span class="fc" id="L127">        return nextPositiveLong(bound);</span>
    }

    /**
     * Returns an array of the length of {@code howMany} containing positive {@code long longs}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the length of the resulting array
     * @return An array of pseudo random {@code long longs}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextPositiveLong
     * @since 1
     */
    public long[] nextPositiveLongs(final long bound, final int howMany) {
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L149">        final long[] ints = new long[howMany];</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L151">            ints[i] = nextPositiveLong(bound);</span>
        }
<span class="fc" id="L153">        return ints;</span>
    }

    /**
     * Returns an array of the length of {@code howMany} containing negative {@code long longs}
     *
     * @param bound
     *            {@code long}
     * @param howMany
     *            {@code int}
     * @return An array of pseudo random {@code long longs}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextNegativeLong
     * @since 1
     */
    public long[] nextNegativeLongs(final long bound, final int howMany) {
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L175">        final long[] ints = new long[howMany];</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L177">            ints[i] = nextNegativeLong(bound);</span>
        }
<span class="fc" id="L179">        return ints;</span>
    }

    /**
     * Returns an array of the length of {@code howMany} containing {@code long longs}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the length of the resulting array
     * @return An array of pseudo random {@code long longs}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextLong
     * @since 1
     */
    public long[] nextLongs(final long bound, final int howMany) {
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L201">        final long[] ints = new long[howMany];</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L203">            ints[i] = nextLong(bound);</span>
        }
<span class="fc" id="L205">        return ints;</span>
    }

    /**
     * Returns a positive {@link BigDecimal} of a given {@code scale} bounded below by {@code 0} (inclusive) and above
     * by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @since 1
     */
    public BigDecimal nextPositiveDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L225" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L227">        final BigDecimal decimal = nextDecimal(bound, scale);</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &lt; 0) {</span>
<span class="nc" id="L229">            return decimal.negate();</span>
        }
<span class="fc" id="L231">        return decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} of a given {@code scale} bounded below by {@code -bound} (exclusive) and
     * above by {@code 0} (inclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @since 1
     */
    public BigDecimal nextNegativeDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L251" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L253">        final BigDecimal decimal = nextDecimal(bound, scale);</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &gt; 0) {</span>
<span class="fc" id="L255">            return decimal.negate();</span>
        }
<span class="nc" id="L257">        return decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} of a given {@code scale} bounded below by {@code -bound} (exclusive) and above by
     * {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @since 1
     */
    public BigDecimal nextDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L277" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L279">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L280">        return keepDecimalInBound(decimal, bound).setScale(scale, BigDecimal.ROUND_HALF_UP);</span>
    }

    /**
     * Returns a positive {@link BigDecimal} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @see #nextPositiveDecimal
     * @since 1
     */
    public BigDecimal nextInvertiblePositiveDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L300" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L302">        final BigDecimal decimal = nextInvertibleDecimal(bound, scale);</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &lt; 0) {</span>
<span class="nc" id="L304">            return decimal.negate();</span>
        }
<span class="fc" id="L306">        return decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @see #nextNegativeDecimal
     * @see #nextInvertibleDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleNegativeDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L327" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L329">        final BigDecimal decimal = nextInvertibleDecimal(bound, scale);</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &gt; 0) {</span>
<span class="fc" id="L331">            return decimal.negate();</span>
        }
<span class="nc" id="L333">        return decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L353" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L355">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L356">        return keepDecimalInBound(decimal, bound).setScale(scale, BigDecimal.ROUND_HALF_UP);</span>
    }

    @VisibleForTesting
    BigDecimal keepDecimalInBound(final BigDecimal decimal, final long bound) {
<span class="fc" id="L361">        BigDecimal result = decimal;</span>
<span class="fc" id="L362">        final BigDecimal decimalBound = BigDecimal.valueOf(bound);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">        if (result.compareTo(BigDecimal.ZERO) &gt; -1) {</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">            while (result.compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L365">                result = result.subtract(decimalBound);</span>
            }
        } else {
<span class="fc bfc" id="L368" title="All 2 branches covered.">            while (result.abs().compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L369">                result = result.add(decimalBound);</span>
            }
        }
<span class="fc" id="L372">        return result;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link BigDecimal BigDecimals}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextPositiveDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextPositiveDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L396" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L399">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L401">            decimals.add(nextPositiveDecimal(bound, scale));</span>
        }
<span class="fc" id="L403">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link BigDecimal BigDecimals}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextNegativeDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextNegativeDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L427" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L430">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L432">            decimals.add(nextNegativeDecimal(bound, scale));</span>
        }
<span class="fc" id="L434">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigDecimal BigDecimals}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L458" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L461">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L463">            decimals.add(nextDecimal(bound, scale));</span>
        }
<span class="fc" id="L465">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link BigDecimal BigDecimals} which
     * are invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertiblePositiveDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertiblePositiveDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L490" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L493">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L495">            decimals.add(nextInvertiblePositiveDecimal(bound, scale));</span>
        }
<span class="fc" id="L497">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link BigDecimal BigDecimals} which
     * are invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleNegativeDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleNegativeDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L522" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L525">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L527">            decimals.add(nextInvertibleNegativeDecimal(bound, scale));</span>
        }
<span class="fc" id="L529">        return decimals;</span>
    }

    /**
     * Returns a {@code List} of the size of {@code howMany} containing {@link BigDecimal BigDecimals} which are
     * invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L554" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L557">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L559">            decimals.add(nextInvertibleDecimal(bound, scale));</span>
        }
<span class="fc" id="L561">        return decimals;</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by {@code 0} (inclusive) and above by
     * {@code bound} (exclusive) and whose {@code denominator} is bounded below {@code 1} (inclusive) and {@code bound}
     * (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @since 1
     */
    public Fraction nextPositiveFraction(final long bound) {
<span class="fc bfc" id="L578" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L579">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L580">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L581">        return new Fraction(numerator, denominator);</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by {@code -bound} (exclusive) and above by
     * {@code 0} (inclusive) and whose {@code denominator} is bounded below {@code 1} (inclusive) and {@code bound}
     * (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @since 1
     */
    public Fraction nextNegativeFraction(final long bound) {
<span class="fc bfc" id="L598" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L599">        return nextPositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by {@code -bound} (exclusive) and above by
     * {@code bound} (exclusive) and whose {@code denominator} is bounded below {@code -bound} (exclusive) and
     * {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @since 1
     */
    public Fraction nextFraction(final long bound) {
<span class="fc bfc" id="L616" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L618">            return nextNegativeFraction(bound);</span>
        }
<span class="fc" id="L620">        return nextPositiveFraction(bound);</span>
    }

    /**
     * Returns a positive {@link Fraction} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @see #nextPositiveFraction
     * @since 1
     */
    public Fraction nextInvertiblePositiveFraction(final long bound) {
<span class="fc bfc" id="L636" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L637">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L638">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L639">        return new Fraction(numerator, denominator);</span>
    }

    /**
     * Returns a negative {@link Fraction} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @see #nextNegativeFraction
     * @since 1
     */
    public Fraction nextInvertibleNegativeFraction(final long bound) {
<span class="fc bfc" id="L655" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L656">        return nextInvertiblePositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @see #nextFraction
     * @since 1
     */
    public Fraction nextInvertibleFraction(final long bound) {
<span class="fc bfc" id="L672" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L674">            return nextInvertibleNegativeFraction(bound);</span>
        }
<span class="fc" id="L676">        return nextInvertiblePositiveFraction(bound);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link Fraction Fractions}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextPositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextPositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L696" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L698">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L700">            fractions.add(nextPositiveFraction(bound));</span>
        }
<span class="fc" id="L702">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link Fraction Fractions}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L722" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L724">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L726">            fractions.add(nextNegativeFraction(bound));</span>
        }
<span class="fc" id="L728">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link Fraction Fractions}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L748" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L750">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L752">            fractions.add(nextFraction(bound));</span>
        }
<span class="fc" id="L754">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link Fraction Fractions} which are
     * invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertiblePositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertiblePositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L775" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L777">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L779">            fractions.add(nextInvertiblePositiveFraction(bound));</span>
        }
<span class="fc" id="L781">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link Fraction Fractions} which are
     * invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L802" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L804">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L805" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L806">            fractions.add(nextInvertibleNegativeFraction(bound));</span>
        }
<span class="fc" id="L808">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link Fraction Fractions} which are invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L828" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L830">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L832">            fractions.add(nextInvertibleFraction(bound));</span>
        }
<span class="fc" id="L834">        return fractions;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} whose {@code real} and {@code imaginary} part are bounded below by
     * {@code -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @since 1
     */
    public SimpleComplexNumber nextSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L850" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L851">        final BigInteger real = BigInteger.valueOf(nextLong(bound));</span>
<span class="fc" id="L852">        final BigInteger imaginary = BigInteger.valueOf(nextLong(bound));</span>
<span class="fc" id="L853">        return new SimpleComplexNumber(real, imaginary);</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSimpleComplexNumber
     * @since 1
     */
    public SimpleComplexNumber nextInvertibleSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L869" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L870">        final BigInteger nonZeroPart = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc bfc" id="L871" title="All 2 branches covered.">        final long possibleZeroPart = random.nextBoolean() ? RandomUtils.nextLong(1, bound) : nextLong(bound);</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L873">            return new SimpleComplexNumber(BigInteger.valueOf(possibleZeroPart), nonZeroPart);</span>
        }
<span class="fc" id="L875">        return new SimpleComplexNumber(nonZeroPart, BigInteger.valueOf(possibleZeroPart));</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumber SimpleComplexNumbers}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A List {@link List} of pseudo random {@link SimpleComplexNumber SimpleComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L895" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L897">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L899">            complexNumbers.add(nextSimpleComplexNumber(bound));</span>
        }
<span class="fc" id="L901">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumber SimpleComplexNumbers}
     * which are invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumber SimpleComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextInvertibleSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L922" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L923" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L924">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L926">            complexNumbers.add(nextInvertibleSimpleComplexNumber(bound));</span>
        }
<span class="fc" id="L928">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link RealComplexNumber} whose {@code real} and {@code imaginary} part are bounded below by
     * {@code -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @since 1
     */
    public RealComplexNumber nextRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L946" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L947" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L948">        final BigDecimal real = nextDecimal(bound, scale);</span>
<span class="fc" id="L949">        final BigDecimal imaginary = nextDecimal(bound, scale);</span>
<span class="fc" id="L950">        return new RealComplexNumber(real, imaginary);</span>
    }

    /**
     * Returns a {@link RealComplexNumber} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @see #nextRealComplexNumber
     * @since 1
     */
    public RealComplexNumber nextInvertibleRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L968" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L969" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L970">        final BigDecimal nonZeroPart = nextInvertibleDecimal(bound, scale);</span>
        final BigDecimal possibleZeroPart =
<span class="fc bfc" id="L972" title="All 2 branches covered.">            random.nextBoolean() ? nextInvertibleDecimal(bound, scale) : nextDecimal(bound, scale);</span>
<span class="fc bfc" id="L973" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L974">            return new RealComplexNumber(possibleZeroPart, nonZeroPart);</span>
        }
<span class="fc" id="L976">        return new RealComplexNumber(nonZeroPart, possibleZeroPart);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumber RealComplexNumbers}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber RealComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextRealComplexNumbers(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L1000" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1002" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1003">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1005">            complexNumbers.add(nextRealComplexNumber(bound, scale));</span>
        }
<span class="fc" id="L1007">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumber RealComplexNumbers}
     * which are invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber RealComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextInvertibleRealComplexNumbers(final long bound, final int scale,
        final int howMany) {
<span class="fc bfc" id="L1033" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1034" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1035" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1036">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1037" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1038">            complexNumbers.add(nextInvertibleRealComplexNumber(bound, scale));</span>
        }
<span class="fc" id="L1040">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link PolarForm}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A {@link PolarForm}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public PolarForm nextPolarForm(final long bound, final int scale) {
<span class="pc bpc" id="L1060" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L1062">        return new PolarForm(nextDecimal(bound, scale), nextDecimal(bound, scale));</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link PolarForm PolarForms}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber RealComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public List&lt;PolarForm&gt; nextPolarForms(final long bound, final int scale, final int howMany) {
<span class="nc bnc" id="L1086" title="All 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="nc" id="L1089">        final List&lt;PolarForm&gt; polarForms = new ArrayList&lt;&gt;(howMany);</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="nc" id="L1091">            polarForms.add(nextPolarForm(bound, scale));</span>
        }
<span class="nc" id="L1093">        return polarForms;</span>
    }

    /**
     * Returns a {@link BigIntVector}
     *
     * @param bound
     *            the bound
     * @param size
     *            the size of the resulting {@link BigIntVector}
     * @return A pseudo random {@link BigIntVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @since 1
     */
    public BigIntVector nextBigIntVector(final long bound, final int size) {
<span class="fc bfc" id="L1113" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1114" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1115">        final BigIntVectorBuilder builder = BigIntVector.builder(size);</span>
<span class="fc bfc" id="L1116" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1117">            builder.put(BigInteger.valueOf(nextLong(bound)));</span>
        }
<span class="fc" id="L1119">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigIntVector BigIntVectors}
     *
     * @param bound
     *            the bound
     * @param size
     *            the sizes of the resulting {@link BigIntVector BigIntVectors}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigIntVector BigIntVectors}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextBigIntVector
     * @since 1
     */
    public List&lt;BigIntVector&gt; nextBigIntVectors(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1141" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1142" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1143" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1144">        final List&lt;BigIntVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1145" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1146">            vectors.add(nextBigIntVector(bound, size));</span>
        }
<span class="fc" id="L1148">        return vectors;</span>
    }

    /**
     * Returns a {@link BigIntMatrix}
     *
     * @param bound
     *            the bound
     * @param rowSize
     *            the row size of the resulting {@link BigIntMatrix}
     * @param columnSize
     *            the column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random {@link BigIntMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @since 1
     */
    public BigIntMatrix nextBigIntMatrix(final long bound, final int rowSize, final int columnSize) {
<span class="fc bfc" id="L1172" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1173" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1174" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L1175">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L1176">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1177">            IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1178">                builder.put(rowIndex, columnIndex, BigInteger.valueOf(nextLong(bound)));</span>
<span class="fc" id="L1179">            });</span>
<span class="fc" id="L1180">        });</span>
<span class="fc" id="L1181">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link BigIntMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of resulting {@link BigIntMatrix}
     * @return A pseudo random upper triangular {@link BigIntMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @see BigIntMatrix#upperTriangular
     * @since 1
     */
    public BigIntMatrix nextUpperTriangularBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1202" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1203" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1204">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(size, size);</span>
<span class="fc" id="L1205">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1206">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1207" title="All 2 branches covered.">                if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L1208">                    builder.put(rowIndex, columnIndex, BigInteger.valueOf(nextLong(bound)));</span>
                } else {
<span class="fc" id="L1210">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1212">            });</span>
<span class="fc" id="L1213">        });</span>
<span class="fc" id="L1214">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link BigIntMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random lower triangular {@link BigIntMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @see BigIntMatrix#lowerTriangular
     * @since 1
     */
    public BigIntMatrix nextLowerTriangularBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1235" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1236" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1237">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(size, size);</span>
<span class="fc" id="L1238">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1239">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1240" title="All 2 branches covered.">                if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L1241">                    builder.put(rowIndex, columnIndex, BigInteger.valueOf(nextLong(bound)));</span>
                } else {
<span class="fc" id="L1243">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1245">            });</span>
<span class="fc" id="L1246">        });</span>
<span class="fc" id="L1247">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link BigIntMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random triangular {@link BigIntMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularBigIntMatrix
     * @see #nextLowerTriangularBigIntMatrix
     * @see BigIntMatrix#triangular
     * @since 1
     */
    public BigIntMatrix nextTriangularBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1269" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1270" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1271" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L1272">            return nextLowerTriangularBigIntMatrix(bound, size);</span>
        }
<span class="fc" id="L1274">        return nextUpperTriangularBigIntMatrix(bound, size);</span>
    }

    /**
     * Returns a diagonal {@link BigIntMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random diagonal {@link BigIntMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see BigIntMatrix#diagonal
     * @since 1
     */
    public BigIntMatrix nextDiagonalBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1294" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1295" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1296">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(size, size);</span>
<span class="fc" id="L1297">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1298">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1299" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1300">                    builder.put(rowIndex, columnIndex, BigInteger.valueOf(nextLong(bound)));</span>
                } else {
<span class="fc" id="L1302">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1304">            });</span>
<span class="fc" id="L1305">        });</span>
<span class="fc" id="L1306">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link BigIntMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random symmetric {@link BigIntMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see BigIntMatrix#symmetric
     * @since 1
     */
    public BigIntMatrix nextSymmetricBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1326" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1327" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1328">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(size, size);</span>
<span class="fc" id="L1329">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1330">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1331">                final BigInteger element = BigInteger.valueOf(nextLong(bound));</span>
<span class="fc bfc" id="L1332" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1333">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1334">                    builder.put(columnIndex, rowIndex, element);</span>
                }
<span class="fc bfc" id="L1336" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1337">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L1339">            });</span>
<span class="fc" id="L1340">        });</span>
<span class="fc" id="L1341">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link BigIntMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random skew-symmetric {@link BigIntMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see BigIntMatrix#skewSymmetric
     * @since 1
     */
    public BigIntMatrix nextSkewSymmetricBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1361" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1362" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1363">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(size, size);</span>
<span class="fc" id="L1364">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1365">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1366" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1367">                    final BigInteger element = BigInteger.valueOf(nextLong(bound));</span>
<span class="fc" id="L1368">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1369">                    builder.put(columnIndex, rowIndex, element.negate());</span>
                }
<span class="fc bfc" id="L1371" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1372">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1374">            });</span>
<span class="fc" id="L1375">        });</span>
<span class="fc" id="L1376">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigIntMatrix BigIntMatrices}
     *
     * @param bound
     *            the bound
     * @param rowSize
     *            the row size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param columnSize
     *            the column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextBigIntMatrices(final long bound, final int rowSize, final int columnSize,
        final int howMany) {
<span class="fc bfc" id="L1405" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1406" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1407" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1408" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1409">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1410" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1411">            matrices.add(nextBigIntMatrix(bound, rowSize, columnSize));</span>
        }
<span class="fc" id="L1413">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular {@link BigIntMatrix
     * BigIntMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextUpperTriangularBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1438" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1439" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1440" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1441">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1442" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1443">            matrices.add(nextUpperTriangularBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1445">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular {@link BigIntMatrix
     * BigIntMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLowerTriangularBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextLowerTriangularBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1470" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1471" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1472" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1473">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1474" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1475">            matrices.add(nextLowerTriangularBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1477">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular {@link BigIntMatrix BigIntMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextTriangularBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextTriangularBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1501" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1502" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1503" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1504">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1505" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1506">            matrices.add(nextTriangularBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1508">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal {@link BigIntMatrix BigIntMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDiagonalBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextDiagonalBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1532" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1533" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1534" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1535">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1536" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1537">            matrices.add(nextDiagonalBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1539">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric {@link BigIntMatrix BigIntMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSymmetricBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextSymmetricBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1563" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1564" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1565" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1566">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1567" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1568">            matrices.add(nextSymmetricBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1570">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric {@link BigIntMatrix
     * BigIntMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSkewSymmetricBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextSkewSymmetricBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1595" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1596" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1597" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1598">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1599" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1600">            matrices.add(nextSkewSymmetricBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1602">        return matrices;</span>
    }

    /**
     * Returns a {@link DecimalVector}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param size
     *            the size of the resulting {@link DecimalVector}
     * @return A speudo random {@link DecimalVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @since 1
     */
    public DecimalVector nextDecimalVector(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1626" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1627" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1628" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1629">        final DecimalVectorBuilder builder = DecimalVector.builder(size);</span>
<span class="fc bfc" id="L1630" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1631">            builder.put(nextDecimal(bound, scale));</span>
        }
<span class="fc" id="L1633">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link DecimalVector DecimalVectors}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param size
     *            the size of the resulting {@link DecimalVector DecimalVectors}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link DecimalVector DecimalVectors}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimalVector
     * @since 1
     */
    public List&lt;DecimalVector&gt; nextDecimalVectors(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L1664" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1665" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1666" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1667" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1668">        final List&lt;DecimalVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1669" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1670">            vectors.add(nextDecimalVector(bound, scale, size));</span>
        }
<span class="fc" id="L1672">        return vectors;</span>
    }

    /**
     * Returns a {@link DecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param rowSize
     *            the row size of the resulting {@link DecimalMatrix}
     * @param columnSize
     *            the column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random {@link DecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @since 1
     */
    public DecimalMatrix nextDecimalMatrix(final long bound, final int scale, final int rowSize, final int columnSize) {
<span class="fc bfc" id="L1700" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1701" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1702" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1703" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L1704">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L1705">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1706">            IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1707">                builder.put(rowIndex, columnIndex, nextDecimal(bound, scale));</span>
<span class="fc" id="L1708">            });</span>
<span class="fc" id="L1709">        });</span>
<span class="fc" id="L1710">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link DecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of resulting {@link DecimalMatrix}
     * @return A pseudo random upper triangular {@link DecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @see DecimalMatrix#upperTriangular
     * @since 1
     */
    public DecimalMatrix nextUpperTriangularDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1735" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1736" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1737">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1738">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1739">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1740" title="All 2 branches covered.">                if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L1741">                    builder.put(rowIndex, columnIndex, nextDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1743">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1745">            });</span>
<span class="fc" id="L1746">        });</span>
<span class="fc" id="L1747">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link DecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random lower triangular {@link DecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @see DecimalMatrix#lowerTriangular
     * @since 1
     */
    public DecimalMatrix nextLowerTriangularDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1772" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1773" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1774">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1775">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1776">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1777" title="All 2 branches covered.">                if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L1778">                    builder.put(rowIndex, columnIndex, nextDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1780">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1782">            });</span>
<span class="fc" id="L1783">        });</span>
<span class="fc" id="L1784">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link DecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random triangular {@link DecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularDecimalMatrix
     * @see #nextLowerTriangularDecimalMatrix
     * @see DecimalMatrix#triangular
     * @since 1
     */
    public DecimalMatrix nextTriangularDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1810" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1811" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1812" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L1813">            return nextLowerTriangularDecimalMatrix(bound, scale, size);</span>
        }
<span class="fc" id="L1815">        return nextUpperTriangularDecimalMatrix(bound, scale, size);</span>
    }

    /**
     * Returns a diagonal {@link DecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random diagonal {@link DecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see DecimalMatrix#diagonal
     * @since 1
     */
    public DecimalMatrix nextDiagonalDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1839" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1840" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1841">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1842">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1843">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1844" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1845">                    builder.put(rowIndex, columnIndex, nextDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1847">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1849">            });</span>
<span class="fc" id="L1850">        });</span>
<span class="fc" id="L1851">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link DecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random symmetric {@link DecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see DecimalMatrix#symmetric
     * @since 1
     */
    public DecimalMatrix nextSymmetricDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1875" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1876" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1877">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1878">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1879">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1880">                final BigDecimal element = nextDecimal(bound, scale);</span>
<span class="fc bfc" id="L1881" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1882">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1883">                    builder.put(columnIndex, rowIndex, element);</span>
                }
<span class="fc bfc" id="L1885" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1886">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L1888">            });</span>
<span class="fc" id="L1889">        });</span>
<span class="fc" id="L1890">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link DecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random skew-symmetric {@link DecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see DecimalMatrix#skewSymmetric
     * @since 1
     */
    public DecimalMatrix nextSkewSymmetricDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1914" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1915" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1916">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1917">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1918">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1919" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1920">                    final BigDecimal element = nextDecimal(bound, scale);</span>
<span class="fc" id="L1921">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1922">                    builder.put(columnIndex, rowIndex, element.negate());</span>
                }
<span class="fc bfc" id="L1924" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1925">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1927">            });</span>

<span class="fc" id="L1929">        });</span>
<span class="fc" id="L1930">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link DecimalMatrix DecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param rowSize
     *            the row size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param columnSize
     *            the column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextDecimalMatrices(final long bound, final int scale, final int rowSize,
        final int columnSize, final int howMany) {
<span class="fc bfc" id="L1963" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1964" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1965" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1966" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1967" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1968">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1969" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1970">            matrices.add(nextDecimalMatrix(bound, scale, rowSize, columnSize));</span>
        }
<span class="fc" id="L1972">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular {@link DecimalMatrix
     * DecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextUpperTriangularDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2002" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2003" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2004" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2005" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2006">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2007" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2008">            matrices.add(nextUpperTriangularDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2010">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular {@link DecimalMatrix
     * DecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLowerTriangularDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextLowerTriangularDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2040" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2041" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2042" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2043" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2044">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2045" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2046">            matrices.add(nextLowerTriangularDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2048">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular {@link DecimalMatrix DecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextTriangularDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextTriangularDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2077" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2078" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2079" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2080" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2081">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2082" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2083">            matrices.add(nextTriangularDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2085">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal {@link DecimalMatrix DecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDiagonalDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextDiagonalDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2114" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2115" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2116" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2117" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2118">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2119" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2120">            matrices.add(nextDiagonalDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2122">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric {@link DecimalMatrix DecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSymmetricDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextSymmetricDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2151" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2152" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2153" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2154" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2155">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2156" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2157">            matrices.add(nextSymmetricDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2159">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric {@link DecimalMatrix
     * DecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSkewSymmetricDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextSkewSymmetricDecimalMatrices(final long bound, final int scale, final int size,
        final int howMany) {
<span class="fc bfc" id="L2189" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2190" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2191" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2192" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2193">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2194" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2195">            matrices.add(nextSkewSymmetricDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2197">        return matrices;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L2202">        return MoreObjects.toStringHelper(this).add(&quot;random&quot;, random).toString();</span>
    }

    @VisibleForTesting
    Random getRandom() {
<span class="fc" id="L2207">        return random;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>