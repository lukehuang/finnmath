<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MathRandom.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">finnMath</a> &gt; <a href="index.source.html" class="el_package">com.github.ltennstedt.finnmath.util</a> &gt; <span class="el_source">MathRandom.java</span></div><h1>MathRandom.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017 Lars Tennstedt
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.ltennstedt.finnmath.util;

import static com.google.common.base.Preconditions.checkArgument;

import com.github.ltennstedt.finnmath.linear.BigIntMatrix;
import com.github.ltennstedt.finnmath.linear.BigIntMatrix.BigIntMatrixBuilder;
import com.github.ltennstedt.finnmath.linear.BigIntVector;
import com.github.ltennstedt.finnmath.linear.BigIntVector.BigIntVectorBuilder;
import com.github.ltennstedt.finnmath.linear.DecimalMatrix;
import com.github.ltennstedt.finnmath.linear.DecimalMatrix.DecimalMatrixBuilder;
import com.github.ltennstedt.finnmath.linear.DecimalVector;
import com.github.ltennstedt.finnmath.linear.DecimalVector.DecimalVectorBuilder;
import com.github.ltennstedt.finnmath.linear.RealComplexNumberMatrix;
import com.github.ltennstedt.finnmath.linear.RealComplexNumberMatrix.RealComplexNumberMatrixBuilder;
import com.github.ltennstedt.finnmath.linear.RealComplexNumberVector;
import com.github.ltennstedt.finnmath.linear.RealComplexNumberVector.RealComplexNumberVectorBuilder;
import com.github.ltennstedt.finnmath.linear.SimpleComplexNumberMatrix;
import com.github.ltennstedt.finnmath.linear.SimpleComplexNumberMatrix.SimpleComplexNumberMatrixBuilder;
import com.github.ltennstedt.finnmath.linear.SimpleComplexNumberVector;
import com.github.ltennstedt.finnmath.linear.SimpleComplexNumberVector.SimpleComplexNumberVectorBuilder;
import com.github.ltennstedt.finnmath.number.Fraction;
import com.github.ltennstedt.finnmath.number.PolarForm;
import com.github.ltennstedt.finnmath.number.RealComplexNumber;
import com.github.ltennstedt.finnmath.number.SimpleComplexNumber;
import com.google.common.annotations.Beta;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.apache.commons.lang3.RandomUtils;

/**
 * A pseudo random generator for {@code long}, {@link BigDecimal}, {@link Fraction}, {@link SimpleComplexNumber},
 * {@link RealComplexNumber}, {@link BigIntVector}, {@link DecimalVector}, {@link BigIntMatrix} and
 * {@link DecimalMatrix}
 *
 * @author Lars Tennstedt
 * @since 1
 */
@Beta
public final class MathRandom {
    private final Random random;

    /**
     * Default constructor
     *
     * @author Lars Tennstedt
     * @since 1
     */
<span class="fc" id="L72">    public MathRandom() {</span>
<span class="fc" id="L73">        random = new Random();</span>
<span class="fc" id="L74">    }</span>

    /**
     * Constructor which has the seed value as parameter
     *
     * @param seed
     *            The seed
     * @author Lars Tennstedt
     * @since 1
     */
<span class="fc" id="L84">    public MathRandom(final long seed) {</span>
<span class="fc" id="L85">        random = new Random(seed);</span>
<span class="fc" id="L86">    }</span>

    /**
     * Returns a positive {@code long} bounded below by {@code 0} (inclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@code long}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @since 1
     */
    public long nextPositiveLong(final long bound) {
<span class="fc bfc" id="L100" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L101">        return RandomUtils.nextLong(0, bound);</span>
    }

    /**
     * Returns a negative {@code long} bounded below by {@code -bound} (exclusive) and above by {@code 0} (inclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@code long}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @since 1
     */
    public long nextNegativeLong(final long bound) {
<span class="fc bfc" id="L116" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L117">        return (-1) * RandomUtils.nextLong(0, bound);</span>
    }

    /**
     * Returns a {@code long} bounded below by {@code -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@code long}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @since 1
     */
    public long nextLong(final long bound) {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L134">            return nextNegativeLong(bound);</span>
        }
<span class="fc" id="L136">        return nextPositiveLong(bound);</span>
    }

    /**
     * Returns an array of the length of {@code howMany} containing positive {@code long longs}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the length of the resulting array
     * @return An array of pseudo random {@code long longs}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextPositiveLong
     * @since 1
     */
    public long[] nextPositiveLongs(final long bound, final int howMany) {
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L158">        final long[] ints = new long[howMany];</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L160">            ints[i] = nextPositiveLong(bound);</span>
        }
<span class="fc" id="L162">        return ints;</span>
    }

    /**
     * Returns an array of the length of {@code howMany} containing negative {@code long longs}
     *
     * @param bound
     *            {@code long}
     * @param howMany
     *            {@code int}
     * @return An array of pseudo random {@code long longs}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextNegativeLong
     * @since 1
     */
    public long[] nextNegativeLongs(final long bound, final int howMany) {
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L184">        final long[] ints = new long[howMany];</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L186">            ints[i] = nextNegativeLong(bound);</span>
        }
<span class="fc" id="L188">        return ints;</span>
    }

    /**
     * Returns an array of the length of {@code howMany} containing {@code long longs}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the length of the resulting array
     * @return An array of pseudo random {@code long longs}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextLong
     * @since 1
     */
    public long[] nextLongs(final long bound, final int howMany) {
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L210">        final long[] ints = new long[howMany];</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L212">            ints[i] = nextLong(bound);</span>
        }
<span class="fc" id="L214">        return ints;</span>
    }

    /**
     * Returns a positive {@link BigDecimal} of a given {@code scale} bounded below by {@code 0} (inclusive) and above
     * by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @since 1
     */
    public BigDecimal nextPositiveDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L234" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L236">        final BigDecimal decimal = nextDecimal(bound, scale);</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &lt; 0) {</span>
<span class="nc" id="L238">            return decimal.negate();</span>
        }
<span class="fc" id="L240">        return decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} of a given {@code scale} bounded below by {@code -bound} (exclusive) and
     * above by {@code 0} (inclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @since 1
     */
    public BigDecimal nextNegativeDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L260" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L262">        final BigDecimal decimal = nextDecimal(bound, scale);</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (decimal.compareTo(BigDecimal.ZERO) &gt; 0) {</span>
<span class="fc" id="L264">            return decimal.negate();</span>
        }
<span class="fc" id="L266">        return decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} of a given {@code scale} bounded below by {@code -bound} (exclusive) and above by
     * {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @since 1
     */
    public BigDecimal nextDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L286" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L288">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L289">        return keepDecimalInBound(decimal, bound).setScale(scale, RoundingMode.HALF_UP);</span>
    }

    /**
     * Returns a positive {@link BigDecimal} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @see #nextPositiveDecimal
     * @since 1
     */
    public BigDecimal nextInvertiblePositiveDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L309" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L311">        final BigDecimal decimal = nextInvertibleDecimal(bound, scale);</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &lt; 0) {</span>
<span class="nc" id="L313">            return decimal.negate();</span>
        }
<span class="fc" id="L315">        return decimal;</span>
    }

    /**
     * Returns a negative {@link BigDecimal} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @see #nextNegativeDecimal
     * @see #nextInvertibleDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleNegativeDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L336" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L338">        final BigDecimal decimal = nextInvertibleDecimal(bound, scale);</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">        if (decimal.compareTo(BigDecimal.ZERO) &gt; 0) {</span>
<span class="fc" id="L340">            return decimal.negate();</span>
        }
<span class="nc" id="L342">        return decimal;</span>
    }

    /**
     * Returns a {@link BigDecimal} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link BigDecimal}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @since 1
     */
    public BigDecimal nextInvertibleDecimal(final long bound, final int scale) {
<span class="fc bfc" id="L362" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L364">        final BigDecimal decimal = BigDecimal.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L365">        return keepDecimalInBound(decimal, bound).setScale(scale, RoundingMode.HALF_UP);</span>
    }

    @VisibleForTesting
    BigDecimal keepDecimalInBound(final BigDecimal decimal, final long bound) {
<span class="fc" id="L370">        BigDecimal result = decimal;</span>
<span class="fc" id="L371">        final BigDecimal decimalBound = BigDecimal.valueOf(bound);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (result.compareTo(BigDecimal.ZERO) &gt; -1) {</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            while (result.compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L374">                result = result.subtract(decimalBound);</span>
            }
        } else {
<span class="fc bfc" id="L377" title="All 2 branches covered.">            while (result.abs().compareTo(decimalBound) &gt; -1) {</span>
<span class="fc" id="L378">                result = result.add(decimalBound);</span>
            }
        }
<span class="fc" id="L381">        return result;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link BigDecimal BigDecimals}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextPositiveDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextPositiveDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L405" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L408">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L410">            decimals.add(nextPositiveDecimal(bound, scale));</span>
        }
<span class="fc" id="L412">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link BigDecimal BigDecimals}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextNegativeDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextNegativeDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L436" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L439">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L441">            decimals.add(nextNegativeDecimal(bound, scale));</span>
        }
<span class="fc" id="L443">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigDecimal BigDecimals}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L467" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L470">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L472">            decimals.add(nextDecimal(bound, scale));</span>
        }
<span class="fc" id="L474">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link BigDecimal BigDecimals} which
     * are invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertiblePositiveDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertiblePositiveDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L499" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L502">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L504">            decimals.add(nextInvertiblePositiveDecimal(bound, scale));</span>
        }
<span class="fc" id="L506">        return decimals;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link BigDecimal BigDecimals} which
     * are invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleNegativeDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleNegativeDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L531" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L534">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L536">            decimals.add(nextInvertibleNegativeDecimal(bound, scale));</span>
        }
<span class="fc" id="L538">        return decimals;</span>
    }

    /**
     * Returns a {@code List} of the size of {@code howMany} containing {@link BigDecimal BigDecimals} which are
     * invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigDecimal BigDecimals}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleDecimal
     * @since 1
     */
    public List&lt;BigDecimal&gt; nextInvertibleDecimals(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L563" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L566">        final List&lt;BigDecimal&gt; decimals = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L568">            decimals.add(nextInvertibleDecimal(bound, scale));</span>
        }
<span class="fc" id="L570">        return decimals;</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by {@code 0} (inclusive) and above by
     * {@code bound} (exclusive) and whose {@code denominator} is bounded below {@code 1} (inclusive) and {@code bound}
     * (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @since 1
     */
    public Fraction nextPositiveFraction(final long bound) {
<span class="fc bfc" id="L587" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L588">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(0, bound));</span>
<span class="fc" id="L589">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L590">        return new Fraction(numerator, denominator);</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by {@code -bound} (exclusive) and above by
     * {@code 0} (inclusive) and whose {@code denominator} is bounded below {@code 1} (inclusive) and {@code bound}
     * (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @since 1
     */
    public Fraction nextNegativeFraction(final long bound) {
<span class="fc bfc" id="L607" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L608">        return nextPositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} whose {@code numerator} is bounded below by {@code -bound} (exclusive) and above by
     * {@code bound} (exclusive) and whose {@code denominator} is bounded below {@code -bound} (exclusive) and
     * {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @since 1
     */
    public Fraction nextFraction(final long bound) {
<span class="fc bfc" id="L625" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L627">            return nextNegativeFraction(bound);</span>
        }
<span class="fc" id="L629">        return nextPositiveFraction(bound);</span>
    }

    /**
     * Returns a positive {@link Fraction} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @see #nextPositiveFraction
     * @since 1
     */
    public Fraction nextInvertiblePositiveFraction(final long bound) {
<span class="fc bfc" id="L645" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L646">        final BigInteger numerator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L647">        final BigInteger denominator = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc" id="L648">        return new Fraction(numerator, denominator);</span>
    }

    /**
     * Returns a negative {@link Fraction} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @see #nextNegativeFraction
     * @since 1
     */
    public Fraction nextInvertibleNegativeFraction(final long bound) {
<span class="fc bfc" id="L664" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L665">        return nextInvertiblePositiveFraction(bound).negate();</span>
    }

    /**
     * Returns a {@link Fraction} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link Fraction}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 2}
     * @author Lars Tennstedt
     * @see #nextFraction
     * @since 1
     */
    public Fraction nextInvertibleFraction(final long bound) {
<span class="fc bfc" id="L681" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L683">            return nextInvertibleNegativeFraction(bound);</span>
        }
<span class="fc" id="L685">        return nextInvertiblePositiveFraction(bound);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link Fraction Fractions}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextPositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextPositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L705" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L707">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L709">            fractions.add(nextPositiveFraction(bound));</span>
        }
<span class="fc" id="L711">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link Fraction Fractions}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L731" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L733">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L735">            fractions.add(nextNegativeFraction(bound));</span>
        }
<span class="fc" id="L737">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link Fraction Fractions}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L757" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L759">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L761">            fractions.add(nextFraction(bound));</span>
        }
<span class="fc" id="L763">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing positive {@link Fraction Fractions} which are
     * invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertiblePositiveFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertiblePositiveFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L784" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L786">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L788">            fractions.add(nextInvertiblePositiveFraction(bound));</span>
        }
<span class="fc" id="L790">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing negative {@link Fraction Fractions} which are
     * invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleNegativeFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleNegativeFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L811" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L813">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L815">            fractions.add(nextInvertibleNegativeFraction(bound));</span>
        }
<span class="fc" id="L817">        return fractions;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link Fraction Fractions} which are invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link Fraction Fractions}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleFraction
     * @since 1
     */
    public List&lt;Fraction&gt; nextInvertibleFractions(final long bound, final int howMany) {
<span class="fc bfc" id="L837" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L839">        final List&lt;Fraction&gt; fractions = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L841">            fractions.add(nextInvertibleFraction(bound));</span>
        }
<span class="fc" id="L843">        return fractions;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} whose {@code real} and {@code imaginary} part are bounded below by
     * {@code -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @since 1
     */
    public SimpleComplexNumber nextSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L859" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc" id="L860">        final BigInteger real = BigInteger.valueOf(nextLong(bound));</span>
<span class="fc" id="L861">        final BigInteger imaginary = BigInteger.valueOf(nextLong(bound));</span>
<span class="fc" id="L862">        return new SimpleComplexNumber(real, imaginary);</span>
    }

    /**
     * Returns a {@link SimpleComplexNumber} which is invertible
     *
     * @param bound
     *            the bound
     * @return A pseudo random {@link SimpleComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSimpleComplexNumber
     * @since 1
     */
    public SimpleComplexNumber nextInvertibleSimpleComplexNumber(final long bound) {
<span class="fc bfc" id="L878" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc" id="L879">        final BigInteger nonZeroPart = BigInteger.valueOf(RandomUtils.nextLong(1, bound));</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">        final long possibleZeroPart = random.nextBoolean() ? RandomUtils.nextLong(1, bound) : nextLong(bound);</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L882">            return new SimpleComplexNumber(BigInteger.valueOf(possibleZeroPart), nonZeroPart);</span>
        }
<span class="fc" id="L884">        return new SimpleComplexNumber(nonZeroPart, BigInteger.valueOf(possibleZeroPart));</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumber SimpleComplexNumbers}
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A List {@link List} of pseudo random {@link SimpleComplexNumber SimpleComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L904" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L906">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L907" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L908">            complexNumbers.add(nextSimpleComplexNumber(bound));</span>
        }
<span class="fc" id="L910">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumber SimpleComplexNumbers}
     * which are invertible
     *
     * @param bound
     *            the bound
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumber SimpleComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleSimpleComplexNumber
     * @since 1
     */
    public List&lt;SimpleComplexNumber&gt; nextInvertibleSimpleComplexNumbers(final long bound, final int howMany) {
<span class="fc bfc" id="L931" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L932" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L933">        final List&lt;SimpleComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L934" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L935">            complexNumbers.add(nextInvertibleSimpleComplexNumber(bound));</span>
        }
<span class="fc" id="L937">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link RealComplexNumber} whose {@code real} and {@code imaginary} part are bounded below by
     * {@code -bound} (exclusive) and above by {@code bound} (exclusive)
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @since 1
     */
    public RealComplexNumber nextRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L955" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L956" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L957">        final BigDecimal real = nextDecimal(bound, scale);</span>
<span class="fc" id="L958">        final BigDecimal imaginary = nextDecimal(bound, scale);</span>
<span class="fc" id="L959">        return new RealComplexNumber(real, imaginary);</span>
    }

    /**
     * Returns a {@link RealComplexNumber} which is invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A pseudo random {@link RealComplexNumber}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @author Lars Tennstedt
     * @see #nextRealComplexNumber
     * @since 1
     */
    public RealComplexNumber nextInvertibleRealComplexNumber(final long bound, final int scale) {
<span class="fc bfc" id="L977" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L978" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L979">        final BigDecimal nonZeroPart = nextInvertibleDecimal(bound, scale);</span>
        final BigDecimal possibleZeroPart =
<span class="fc bfc" id="L981" title="All 2 branches covered.">                random.nextBoolean() ? nextInvertibleDecimal(bound, scale) : nextDecimal(bound, scale);</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L983">            return new RealComplexNumber(possibleZeroPart, nonZeroPart);</span>
        }
<span class="fc" id="L985">        return new RealComplexNumber(nonZeroPart, possibleZeroPart);</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumber RealComplexNumbers}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber RealComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextRealComplexNumbers(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L1009" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1010" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1011" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1012">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1014">            complexNumbers.add(nextRealComplexNumber(bound, scale));</span>
        }
<span class="fc" id="L1016">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumber RealComplexNumbers}
     * which are invertible
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber RealComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public List&lt;RealComplexNumber&gt; nextInvertibleRealComplexNumbers(final long bound, final int scale,
            final int howMany) {
<span class="fc bfc" id="L1042" title="All 2 branches covered.">        checkArgument(bound &gt; 1, &quot;expected bound &gt; 1 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1043" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1044" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1045">        final List&lt;RealComplexNumber&gt; complexNumbers = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1046" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1047">            complexNumbers.add(nextInvertibleRealComplexNumber(bound, scale));</span>
        }
<span class="fc" id="L1049">        return complexNumbers;</span>
    }

    /**
     * Returns a {@link PolarForm}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @return A {@link PolarForm}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @author Lars Tennstedt
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public PolarForm nextPolarForm(final long bound, final int scale) {
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1070" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc" id="L1071">        return new PolarForm(nextDecimal(bound, scale), nextDecimal(bound, scale));</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link PolarForm PolarForms}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumber RealComplexNumbers}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextInvertibleRealComplexNumber
     * @since 1
     */
    public List&lt;PolarForm&gt; nextPolarForms(final long bound, final int scale, final int howMany) {
<span class="fc bfc" id="L1095" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1096" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1097" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1098">        final List&lt;PolarForm&gt; polarForms = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1099" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1100">            polarForms.add(nextPolarForm(bound, scale));</span>
        }
<span class="fc" id="L1102">        return polarForms;</span>
    }

    /**
     * Returns a {@link BigIntVector}
     *
     * @param bound
     *            the bound
     * @param size
     *            the size of the resulting {@link BigIntVector}
     * @return A pseudo random {@link BigIntVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @since 1
     */
    public BigIntVector nextBigIntVector(final long bound, final int size) {
<span class="fc bfc" id="L1122" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1123" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1124">        final BigIntVectorBuilder builder = BigIntVector.builder(size);</span>
<span class="fc bfc" id="L1125" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1126">            builder.put(BigInteger.valueOf(nextLong(bound)));</span>
        }
<span class="fc" id="L1128">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigIntVector BigIntVectors}
     *
     * @param bound
     *            the bound
     * @param size
     *            the sizes of the resulting {@link BigIntVector BigIntVectors}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigIntVector BigIntVectors}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextBigIntVector
     * @since 1
     */
    public List&lt;BigIntVector&gt; nextBigIntVectors(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1150" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1151" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1152" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1153">        final List&lt;BigIntVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1154" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1155">            vectors.add(nextBigIntVector(bound, size));</span>
        }
<span class="fc" id="L1157">        return vectors;</span>
    }

    /**
     * Returns a {@link BigIntMatrix}
     *
     * @param bound
     *            the bound
     * @param rowSize
     *            the row size of the resulting {@link BigIntMatrix}
     * @param columnSize
     *            the column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random {@link BigIntMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @since 1
     */
    public BigIntMatrix nextBigIntMatrix(final long bound, final int rowSize, final int columnSize) {
<span class="fc bfc" id="L1181" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1182" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1183" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L1184">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L1185">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1186">            IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1187">                builder.put(rowIndex, columnIndex, BigInteger.valueOf(nextLong(bound)));</span>
<span class="fc" id="L1188">            });</span>
<span class="fc" id="L1189">        });</span>
<span class="fc" id="L1190">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link BigIntMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of resulting {@link BigIntMatrix}
     * @return A pseudo random upper triangular {@link BigIntMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @see BigIntMatrix#upperTriangular
     * @since 1
     */
    public BigIntMatrix nextUpperTriangularBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1211" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1212" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1213">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(size, size);</span>
<span class="fc" id="L1214">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1215">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1216" title="All 2 branches covered.">                if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L1217">                    builder.put(rowIndex, columnIndex, BigInteger.valueOf(nextLong(bound)));</span>
                } else {
<span class="fc" id="L1219">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1221">            });</span>
<span class="fc" id="L1222">        });</span>
<span class="fc" id="L1223">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link BigIntMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random lower triangular {@link BigIntMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @see BigIntMatrix#lowerTriangular
     * @since 1
     */
    public BigIntMatrix nextLowerTriangularBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1244" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1245" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1246">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(size, size);</span>
<span class="fc" id="L1247">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1248">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1249" title="All 2 branches covered.">                if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L1250">                    builder.put(rowIndex, columnIndex, BigInteger.valueOf(nextLong(bound)));</span>
                } else {
<span class="fc" id="L1252">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1254">            });</span>
<span class="fc" id="L1255">        });</span>
<span class="fc" id="L1256">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link BigIntMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random triangular {@link BigIntMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularBigIntMatrix
     * @see #nextLowerTriangularBigIntMatrix
     * @see BigIntMatrix#triangular
     * @since 1
     */
    public BigIntMatrix nextTriangularBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1278" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1279" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1280" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L1281">            return nextLowerTriangularBigIntMatrix(bound, size);</span>
        }
<span class="fc" id="L1283">        return nextUpperTriangularBigIntMatrix(bound, size);</span>
    }

    /**
     * Returns a diagonal {@link BigIntMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random diagonal {@link BigIntMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see BigIntMatrix#diagonal
     * @since 1
     */
    public BigIntMatrix nextDiagonalBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1303" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1304" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1305">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(size, size);</span>
<span class="fc" id="L1306">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1307">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1308" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1309">                    builder.put(rowIndex, columnIndex, BigInteger.valueOf(nextLong(bound)));</span>
                } else {
<span class="fc" id="L1311">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1313">            });</span>
<span class="fc" id="L1314">        });</span>
<span class="fc" id="L1315">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link BigIntMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random symmetric {@link BigIntMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see BigIntMatrix#symmetric
     * @since 1
     */
    public BigIntMatrix nextSymmetricBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1335" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1336" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1337">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(size, size);</span>
<span class="fc" id="L1338">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1339">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1340">                final BigInteger element = BigInteger.valueOf(nextLong(bound));</span>
<span class="fc bfc" id="L1341" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1342">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1343">                    builder.put(columnIndex, rowIndex, element);</span>
                }
<span class="fc bfc" id="L1345" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1346">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L1348">            });</span>
<span class="fc" id="L1349">        });</span>
<span class="fc" id="L1350">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link BigIntMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix}
     * @return A pseudo random skew-symmetric {@link BigIntMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see BigIntMatrix#skewSymmetric
     * @since 1
     */
    public BigIntMatrix nextSkewSymmetricBigIntMatrix(final long bound, final int size) {
<span class="fc bfc" id="L1370" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1371" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1372">        final BigIntMatrixBuilder builder = BigIntMatrix.builder(size, size);</span>
<span class="fc" id="L1373">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1374">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1375" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1376">                    final BigInteger element = BigInteger.valueOf(nextLong(bound));</span>
<span class="fc" id="L1377">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1378">                    builder.put(columnIndex, rowIndex, element.negate());</span>
                }
<span class="fc bfc" id="L1380" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1381">                    builder.put(rowIndex, columnIndex, BigInteger.ZERO);</span>
                }
<span class="fc" id="L1383">            });</span>
<span class="fc" id="L1384">        });</span>
<span class="fc" id="L1385">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link BigIntMatrix BigIntMatrices}
     *
     * @param bound
     *            the bound
     * @param rowSize
     *            the row size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param columnSize
     *            the column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextBigIntMatrices(final long bound, final int rowSize, final int columnSize,
            final int howMany) {
<span class="fc bfc" id="L1414" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1415" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1416" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1417" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1418">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1419" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1420">            matrices.add(nextBigIntMatrix(bound, rowSize, columnSize));</span>
        }
<span class="fc" id="L1422">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular {@link BigIntMatrix
     * BigIntMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextUpperTriangularBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1447" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1448" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1449" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1450">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1451" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1452">            matrices.add(nextUpperTriangularBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1454">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular {@link BigIntMatrix
     * BigIntMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLowerTriangularBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextLowerTriangularBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1479" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1480" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1481" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1482">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1483" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1484">            matrices.add(nextLowerTriangularBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1486">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular {@link BigIntMatrix BigIntMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextTriangularBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextTriangularBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1510" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1511" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1512" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1513">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1514" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1515">            matrices.add(nextTriangularBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1517">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal {@link BigIntMatrix BigIntMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDiagonalBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextDiagonalBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1541" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1542" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1543" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1544">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1545" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1546">            matrices.add(nextDiagonalBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1548">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric {@link BigIntMatrix BigIntMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSymmetricBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextSymmetricBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1572" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1573" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1574" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1575">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1576" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1577">            matrices.add(nextSymmetricBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1579">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric {@link BigIntMatrix
     * BigIntMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link BigIntMatrix BigIntMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link BigIntMatrix BigIntMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSkewSymmetricBigIntMatrix
     * @since 1
     */
    public List&lt;BigIntMatrix&gt; nextSkewSymmetricBigIntMatrices(final long bound, final int size, final int howMany) {
<span class="fc bfc" id="L1604" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1605" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1606" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1607">        final List&lt;BigIntMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1608" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1609">            matrices.add(nextSkewSymmetricBigIntMatrix(bound, size));</span>
        }
<span class="fc" id="L1611">        return matrices;</span>
    }

    /**
     * Returns a {@link DecimalVector}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param size
     *            the size of the resulting {@link DecimalVector}
     * @return A speudo random {@link DecimalVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @since 1
     */
    public DecimalVector nextDecimalVector(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1635" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1636" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1637" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1638">        final DecimalVectorBuilder builder = DecimalVector.builder(size);</span>
<span class="fc bfc" id="L1639" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1640">            builder.put(nextDecimal(bound, scale));</span>
        }
<span class="fc" id="L1642">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link DecimalVector DecimalVectors}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param size
     *            the size of the resulting {@link DecimalVector DecimalVectors}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link DecimalVector DecimalVectors}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimalVector
     * @since 1
     */
    public List&lt;DecimalVector&gt; nextDecimalVectors(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L1673" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1674" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1675" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1676" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1677">        final List&lt;DecimalVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1678" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1679">            vectors.add(nextDecimalVector(bound, scale, size));</span>
        }
<span class="fc" id="L1681">        return vectors;</span>
    }

    /**
     * Returns a {@link DecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param rowSize
     *            the row size of the resulting {@link DecimalMatrix}
     * @param columnSize
     *            the column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random {@link DecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @since 1
     */
    public DecimalMatrix nextDecimalMatrix(final long bound, final int scale, final int rowSize, final int columnSize) {
<span class="fc bfc" id="L1709" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1710" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1711" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1712" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L1713">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L1714">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1715">            IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1716">                builder.put(rowIndex, columnIndex, nextDecimal(bound, scale));</span>
<span class="fc" id="L1717">            });</span>
<span class="fc" id="L1718">        });</span>
<span class="fc" id="L1719">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link DecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of resulting {@link DecimalMatrix}
     * @return A pseudo random upper triangular {@link DecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @see DecimalMatrix#upperTriangular
     * @since 1
     */
    public DecimalMatrix nextUpperTriangularDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1744" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1745" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1746">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1747">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1748">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1749" title="All 2 branches covered.">                if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L1750">                    builder.put(rowIndex, columnIndex, nextDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1752">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1754">            });</span>
<span class="fc" id="L1755">        });</span>
<span class="fc" id="L1756">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link DecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random lower triangular {@link DecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimal
     * @see DecimalMatrix#lowerTriangular
     * @since 1
     */
    public DecimalMatrix nextLowerTriangularDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1781" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1782" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1783">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1784">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1785">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1786" title="All 2 branches covered.">                if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L1787">                    builder.put(rowIndex, columnIndex, nextDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1789">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1791">            });</span>
<span class="fc" id="L1792">        });</span>
<span class="fc" id="L1793">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link DecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random triangular {@link DecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularDecimalMatrix
     * @see #nextLowerTriangularDecimalMatrix
     * @see DecimalMatrix#triangular
     * @since 1
     */
    public DecimalMatrix nextTriangularDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1819" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1820" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L1821" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L1822">            return nextLowerTriangularDecimalMatrix(bound, scale, size);</span>
        }
<span class="fc" id="L1824">        return nextUpperTriangularDecimalMatrix(bound, scale, size);</span>
    }

    /**
     * Returns a diagonal {@link DecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random diagonal {@link DecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see DecimalMatrix#diagonal
     * @since 1
     */
    public DecimalMatrix nextDiagonalDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1848" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1849" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1850">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1851">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1852">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1853" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1854">                    builder.put(rowIndex, columnIndex, nextDecimal(bound, scale));</span>
                } else {
<span class="fc" id="L1856">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1858">            });</span>
<span class="fc" id="L1859">        });</span>
<span class="fc" id="L1860">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link DecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random symmetric {@link DecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see DecimalMatrix#symmetric
     * @since 1
     */
    public DecimalMatrix nextSymmetricDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1884" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1885" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1886">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1887">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1888">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L1889">                final BigDecimal element = nextDecimal(bound, scale);</span>
<span class="fc bfc" id="L1890" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1891">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1892">                    builder.put(columnIndex, rowIndex, element);</span>
                }
<span class="fc bfc" id="L1894" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1895">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L1897">            });</span>
<span class="fc" id="L1898">        });</span>
<span class="fc" id="L1899">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link DecimalMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix}
     * @return A pseudo random skew-symmetric {@link DecimalMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see DecimalMatrix#skewSymmetric
     * @since 1
     */
    public DecimalMatrix nextSkewSymmetricDecimalMatrix(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L1923" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1924" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L1925">        final DecimalMatrixBuilder builder = DecimalMatrix.builder(size, size);</span>
<span class="fc" id="L1926">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L1927">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L1928" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L1929">                    final BigDecimal element = nextDecimal(bound, scale);</span>
<span class="fc" id="L1930">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L1931">                    builder.put(columnIndex, rowIndex, element.negate());</span>
                }
<span class="fc bfc" id="L1933" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L1934">                    builder.put(rowIndex, columnIndex, BigDecimal.ZERO);</span>
                }
<span class="fc" id="L1936">            });</span>

<span class="fc" id="L1938">        });</span>
<span class="fc" id="L1939">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link DecimalMatrix DecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale to be set on the {@link BigDecimal BigDecimals}
     * @param rowSize
     *            the row size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param columnSize
     *            the column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextDecimalMatrices(final long bound, final int scale, final int rowSize,
            final int columnSize, final int howMany) {
<span class="fc bfc" id="L1972" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L1973" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L1974" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L1975" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L1976" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L1977">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L1978" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L1979">            matrices.add(nextDecimalMatrix(bound, scale, rowSize, columnSize));</span>
        }
<span class="fc" id="L1981">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular {@link DecimalMatrix
     * DecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextUpperTriangularDecimalMatrices(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2011" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2012" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2013" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2014" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2015">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2016" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2017">            matrices.add(nextUpperTriangularDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2019">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular {@link DecimalMatrix
     * DecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLowerTriangularDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextLowerTriangularDecimalMatrices(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2049" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2050" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2051" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2052" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2053">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2054" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2055">            matrices.add(nextLowerTriangularDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2057">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular {@link DecimalMatrix DecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextTriangularDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextTriangularDecimalMatrices(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2086" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2087" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2088" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2089" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2090">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2091" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2092">            matrices.add(nextTriangularDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2094">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal {@link DecimalMatrix DecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDiagonalDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextDiagonalDecimalMatrices(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2123" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2124" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2125" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2126" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2127">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2128" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2129">            matrices.add(nextDiagonalDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2131">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric {@link DecimalMatrix DecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSymmetricDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextSymmetricDecimalMatrices(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2160" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2161" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2162" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2163" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2164">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2165" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2166">            matrices.add(nextSymmetricDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2168">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric {@link DecimalMatrix
     * DecimalMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link DecimalMatrix DecimalMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link DecimalMatrix DecimalMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSkewSymmetricDecimalMatrix
     * @since 1
     */
    public List&lt;DecimalMatrix&gt; nextSkewSymmetricDecimalMatrices(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2198" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2199" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2200" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2201" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2202">        final List&lt;DecimalMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2203" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2204">            matrices.add(nextSkewSymmetricDecimalMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L2206">        return matrices;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumberVector}
     *
     * @param bound
     *            the bound
     * @param size
     *            the size of the resulting {@link SimpleComplexNumberVector}
     * @return A pseudo random {@link SimpleComplexNumberVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @since 1
     */
    public SimpleComplexNumberVector nextSimpleComplexNumberVector(final long bound, final int size) {
<span class="fc bfc" id="L2226" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2227" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2228">        final SimpleComplexNumberVectorBuilder builder = SimpleComplexNumberVector.builder(size);</span>
<span class="fc bfc" id="L2229" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L2230">            builder.put(nextSimpleComplexNumber(bound));</span>
        }
<span class="fc" id="L2232">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumberVector
     * SimpleComplexNumberVectors}
     *
     * @param bound
     *            the bound
     * @param size
     *            the sizes of the resulting {@link SimpleComplexNumberVector SimpleComplexNumberVectors}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumberVector SimpleComplexNumberVectors}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextSimpleComplexNumberVector
     * @since 1
     */
    public List&lt;SimpleComplexNumberVector&gt; nextSimpleComplexNumberVectors(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L2256" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2257" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2258" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2259">        final List&lt;SimpleComplexNumberVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2260" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2261">            vectors.add(nextSimpleComplexNumberVector(bound, size));</span>
        }
<span class="fc" id="L2263">        return vectors;</span>
    }

    /**
     * Returns a {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param rowSize
     *            the row size of the resulting {@link SimpleComplexNumberMatrix}
     * @param columnSize
     *            the column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSimpleComplexNumberMatrix(final long bound, final int rowSize,
            final int columnSize) {
<span class="fc bfc" id="L2288" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2289" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2290" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L2291">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L2292">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2293">            IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L2294">                builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
<span class="fc" id="L2295">            });</span>
<span class="fc" id="L2296">        });</span>
<span class="fc" id="L2297">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random upper triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @see SimpleComplexNumberMatrix#upperTriangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextUpperTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2318" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2319" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2320">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2321">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2322">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2323" title="All 2 branches covered.">                if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L2324">                    builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                } else {
<span class="fc" id="L2326">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2328">            });</span>
<span class="fc" id="L2329">        });</span>
<span class="fc" id="L2330">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random lower triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @see SimpleComplexNumberMatrix#lowerTriangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextLowerTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2351" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2352" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2353">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2354">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2355">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2356" title="All 2 branches covered.">                if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L2357">                    builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                } else {
<span class="fc" id="L2359">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2361">            });</span>
<span class="fc" id="L2362">        });</span>
<span class="fc" id="L2363">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random triangular {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularSimpleComplexNumberMatrix
     * @see #nextLowerTriangularSimpleComplexNumberMatrix
     * @see SimpleComplexNumberMatrix#triangular
     * @since 1
     */
    public SimpleComplexNumberMatrix nextTriangularSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2385" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2386" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2387" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L2388">            return nextLowerTriangularSimpleComplexNumberMatrix(bound, size);</span>
        }
<span class="fc" id="L2390">        return nextUpperTriangularSimpleComplexNumberMatrix(bound, size);</span>
    }

    /**
     * Returns a diagonal {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random diagonal {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see SimpleComplexNumberMatrix#diagonal
     * @since 1
     */
    public SimpleComplexNumberMatrix nextDiagonalSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2410" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2411" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2412">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2413">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2414">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2415" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2416">                    builder.put(rowIndex, columnIndex, nextSimpleComplexNumber(bound));</span>
                } else {
<span class="fc" id="L2418">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2420">            });</span>
<span class="fc" id="L2421">        });</span>
<span class="fc" id="L2422">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random symmetric {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see SimpleComplexNumberMatrix#symmetric
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSymmetricSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2442" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2443" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2444">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2445">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2446">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L2447">                final SimpleComplexNumber element = nextSimpleComplexNumber(bound);</span>
<span class="fc bfc" id="L2448" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L2449">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2450">                    builder.put(columnIndex, rowIndex, element);</span>
                }
<span class="fc bfc" id="L2452" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2453">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L2455">            });</span>
<span class="fc" id="L2456">        });</span>
<span class="fc" id="L2457">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link SimpleComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link SimpleComplexNumberMatrix}
     * @return A pseudo random skew-symmetric {@link SimpleComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see SimpleComplexNumberMatrix#skewSymmetric
     * @since 1
     */
    public SimpleComplexNumberMatrix nextSkewSymmetricSimpleComplexNumberMatrix(final long bound, final int size) {
<span class="fc bfc" id="L2477" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2478" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2479">        final SimpleComplexNumberMatrixBuilder builder = SimpleComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2480">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2481">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2482" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L2483">                    final SimpleComplexNumber element = nextSimpleComplexNumber(bound);</span>
<span class="fc" id="L2484">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L2485">                    builder.put(columnIndex, rowIndex, element.negate());</span>
                }
<span class="fc bfc" id="L2487" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2488">                    builder.put(rowIndex, columnIndex, SimpleComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2490">            });</span>
<span class="fc" id="L2491">        });</span>
<span class="fc" id="L2492">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param rowSize
     *            the row size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param columnSize
     *            the column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSimpleComplexNumberMatrices(final long bound, final int rowSize,
            final int columnSize, final int howMany) {
<span class="fc bfc" id="L2522" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2523" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2524" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L2525" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2526">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2527" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2528">            matrices.add(nextSimpleComplexNumberMatrix(bound, rowSize, columnSize));</span>
        }
<span class="fc" id="L2530">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link SimpleComplexNumberMatrix
     *         SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextUpperTriangularSimpleComplexNumberMatrices(final long bound,
            final int size, final int howMany) {
<span class="fc bfc" id="L2557" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2558" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2559" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2560">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2561" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2562">            matrices.add(nextUpperTriangularSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2564">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular
     * {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link SimpleComplexNumberMatrix
     *         SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLowerTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextLowerTriangularSimpleComplexNumberMatrices(final long bound,
            final int size, final int howMany) {
<span class="fc bfc" id="L2591" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2592" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2593" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2594">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2595" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2596">            matrices.add(nextLowerTriangularSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2598">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextTriangularSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextTriangularSimpleComplexNumberMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L2624" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2625" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2626" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2627">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2628" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2629">            matrices.add(nextTriangularSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2631">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDiagonalSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextDiagonalSimpleComplexNumberMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L2657" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2658" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2659" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2660">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2661" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2662">            matrices.add(nextDiagonalSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2664">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSymmetricSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSymmetricSimpleComplexNumberMatrices(final long bound, final int size,
            final int howMany) {
<span class="fc bfc" id="L2690" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2691" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2692" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2693">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2694" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2695">            matrices.add(nextSymmetricSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2697">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric {@link SimpleComplexNumberMatrix
     * SimpleComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param size
     *            the row and column size of the resulting {@link SimpleComplexNumberMatrix SimpleComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link SimpleComplexNumberMatrix
     *         SimpleComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSkewSymmetricSimpleComplexNumberMatrix
     * @since 1
     */
    public List&lt;SimpleComplexNumberMatrix&gt; nextSkewSymmetricSimpleComplexNumberMatrices(final long bound,
            final int size, final int howMany) {
<span class="fc bfc" id="L2724" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2725" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2726" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2727">        final List&lt;SimpleComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2728" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2729">            matrices.add(nextSkewSymmetricSimpleComplexNumberMatrix(bound, size));</span>
        }
<span class="fc" id="L2731">        return matrices;</span>
    }

    /**
     * Returns a {@link RealComplexNumberVector}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the size of the resulting {@link RealComplexNumberVector}
     * @return A pseudo random {@link RealComplexNumberVector}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @since 1
     */
    public RealComplexNumberVector nextRealComplexNumberVector(final long bound, final int scale, final int size) {
<span class="fc bfc" id="L2755" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2756" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2757" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2758">        final RealComplexNumberVectorBuilder builder = RealComplexNumberVector.builder(size);</span>
<span class="fc bfc" id="L2759" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L2760">            builder.put(nextRealComplexNumber(bound, scale));</span>
        }
<span class="fc" id="L2762">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumberVector
     * RealComplexNumberVectors}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the sizes of the resulting {@link RealComplexNumberVector RealComplexNumberVectors}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumberVector RealComplexNumberVectors}
     * @throws IllegalArgumentException
     *             if {@code  bound &lt; 2}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 2}
     * @author Lars Tennstedt
     * @see #nextRealComplexNumberVector
     * @since 1
     */
    public List&lt;RealComplexNumberVector&gt; nextRealComplexNumberVectors(final long bound, final int scale, final int size,
            final int howMany) {
<span class="fc bfc" id="L2790" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2791" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2792" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2793" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L2794">        final List&lt;RealComplexNumberVector&gt; vectors = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L2795" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L2796">            vectors.add(nextRealComplexNumberVector(bound, scale, size));</span>
        }
<span class="fc" id="L2798">        return vectors;</span>
    }

    /**
     * Returns a {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param rowSize
     *            the row size of the resulting {@link RealComplexNumberMatrix}
     * @param columnSize
     *            the column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @since 1
     */
    public RealComplexNumberMatrix nextRealComplexNumberMatrix(final long bound, final int scale, final int rowSize,
            final int columnSize) {
<span class="fc bfc" id="L2827" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2828" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2829" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L2830" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc" id="L2831">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(rowSize, columnSize);</span>
<span class="fc" id="L2832">        IntStream.rangeClosed(1, rowSize).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2833">            IntStream.rangeClosed(1, columnSize).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L2834">                builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
<span class="fc" id="L2835">            });</span>
<span class="fc" id="L2836">        });</span>
<span class="fc" id="L2837">        return builder.build();</span>
    }

    /**
     * Returns an upper triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random upper triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @see RealComplexNumberMatrix#upperTriangular
     * @since 1
     */
    public RealComplexNumberMatrix nextUpperTriangularRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2863" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2864" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2865" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2866">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2867">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2868">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2869" title="All 2 branches covered.">                if (rowIndex &lt;= columnIndex) {</span>
<span class="fc" id="L2870">                    builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                } else {
<span class="fc" id="L2872">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2874">            });</span>
<span class="fc" id="L2875">        });</span>
<span class="fc" id="L2876">        return builder.build();</span>
    }

    /**
     * Returns an lower triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random lower triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLong
     * @see RealComplexNumberMatrix#lowerTriangular
     * @since 1
     */
    public RealComplexNumberMatrix nextLowerTriangularRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2902" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2903" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2904" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2905">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2906">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2907">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2908" title="All 2 branches covered.">                if (rowIndex &gt;= columnIndex) {</span>
<span class="fc" id="L2909">                    builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                } else {
<span class="fc" id="L2911">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2913">            });</span>
<span class="fc" id="L2914">        });</span>
<span class="fc" id="L2915">        return builder.build();</span>
    }

    /**
     * Returns a triangular {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random triangular {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularRealComplexNumberMatrix
     * @see #nextLowerTriangularRealComplexNumberMatrix
     * @see RealComplexNumberMatrix#triangular
     * @since 1
     */
    public RealComplexNumberMatrix nextTriangularRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2942" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2943" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2944" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L2945" title="All 2 branches covered.">        if (random.nextBoolean()) {</span>
<span class="fc" id="L2946">            return nextLowerTriangularRealComplexNumberMatrix(bound, scale, size);</span>
        }
<span class="fc" id="L2948">        return nextUpperTriangularRealComplexNumberMatrix(bound, scale, size);</span>
    }

    /**
     * Returns a diagonal {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random diagonal {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see RealComplexNumberMatrix#diagonal
     * @since 1
     */
    public RealComplexNumberMatrix nextDiagonalRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L2973" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L2974" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L2975" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L2976">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L2977">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L2978">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L2979" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L2980">                    builder.put(rowIndex, columnIndex, nextRealComplexNumber(bound, scale));</span>
                } else {
<span class="fc" id="L2982">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L2984">            });</span>
<span class="fc" id="L2985">        });</span>
<span class="fc" id="L2986">        return builder.build();</span>
    }

    /**
     * Returns a symmetric {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random symmetric {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see RealComplexNumberMatrix#symmetric
     * @since 1
     */
    public RealComplexNumberMatrix nextSymmetricRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L3011" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3012" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3013" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L3014">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L3015">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L3016">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc" id="L3017">                final RealComplexNumber element = nextRealComplexNumber(bound, scale);</span>
<span class="fc bfc" id="L3018" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L3019">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L3020">                    builder.put(columnIndex, rowIndex, element);</span>
                }
<span class="fc bfc" id="L3022" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L3023">                    builder.put(rowIndex, columnIndex, element);</span>
                }
<span class="fc" id="L3025">            });</span>
<span class="fc" id="L3026">        });</span>
<span class="fc" id="L3027">        return builder.build();</span>
    }

    /**
     * Returns a skew-symmetric {@link RealComplexNumberMatrix}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link RealComplexNumberMatrix}
     * @return A pseudo random skew-symmetric {@link RealComplexNumberMatrix}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @author Lars Tennstedt
     * @see RealComplexNumberMatrix#skewSymmetric
     * @since 1
     */
    public RealComplexNumberMatrix nextSkewSymmetricRealComplexNumberMatrix(final long bound, final int scale,
            final int size) {
<span class="fc bfc" id="L3052" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3053" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3054" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc" id="L3055">        final RealComplexNumberMatrixBuilder builder = RealComplexNumberMatrix.builder(size, size);</span>
<span class="fc" id="L3056">        IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(rowIndex -&gt; {</span>
<span class="fc" id="L3057">            IntStream.rangeClosed(1, size).boxed().collect(Collectors.toList()).forEach(columnIndex -&gt; {</span>
<span class="fc bfc" id="L3058" title="All 2 branches covered.">                if (rowIndex &lt; columnIndex) {</span>
<span class="fc" id="L3059">                    final RealComplexNumber element = nextRealComplexNumber(bound, scale);</span>
<span class="fc" id="L3060">                    builder.put(rowIndex, columnIndex, element);</span>
<span class="fc" id="L3061">                    builder.put(columnIndex, rowIndex, element.negate());</span>
                }
<span class="fc bfc" id="L3063" title="All 2 branches covered.">                if (rowIndex.equals(columnIndex)) {</span>
<span class="fc" id="L3064">                    builder.put(rowIndex, columnIndex, RealComplexNumber.ZERO);</span>
                }
<span class="fc" id="L3066">            });</span>
<span class="fc" id="L3067">        });</span>
<span class="fc" id="L3068">        return builder.build();</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param rowSize
     *            the row size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param columnSize
     *            the column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code rowSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code columnSize &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextRealComplexNumberMatrices(final long bound, final int scale,
            final int rowSize, final int columnSize, final int howMany) {
<span class="fc bfc" id="L3102" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3103" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3104" title="All 2 branches covered.">        checkArgument(rowSize &gt; 0, &quot;expected rowSize &gt; 0 but actual %s&quot;, rowSize);</span>
<span class="fc bfc" id="L3105" title="All 2 branches covered.">        checkArgument(columnSize &gt; 0, &quot;expected columnSize &gt; 0 but actual %s&quot;, columnSize);</span>
<span class="fc bfc" id="L3106" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3107">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3108" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3109">            matrices.add(nextRealComplexNumberMatrix(bound, scale, rowSize, columnSize));</span>
        }
<span class="fc" id="L3111">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing upper triangular {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random upper triangular {@link RealComplexNumberMatrix
     *         RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextUpperTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextUpperTriangularRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3142" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3143" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3144" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3145" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3146">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3147" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3148">            matrices.add(nextUpperTriangularRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3150">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing lower triangular {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random lower triangular {@link RealComplexNumberMatrix
     *         RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextLowerTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextLowerTriangularRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3181" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3182" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3183" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3184" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3185">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3186" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3187">            matrices.add(nextLowerTriangularRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3189">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing triangular {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random triangular {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextTriangularRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextTriangularRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3219" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3220" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3221" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3222" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3223">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3224" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3225">            matrices.add(nextTriangularRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3227">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing diagonal {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random diagonal {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextDiagonalRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextDiagonalRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3257" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3258" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3259" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3260" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3261">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3262" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3263">            matrices.add(nextDiagonalRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3265">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing symmetric {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random symmetric {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSymmetricRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextSymmetricRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3295" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3296" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3297" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3298" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3299">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3300" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3301">            matrices.add(nextSymmetricRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3303">        return matrices;</span>
    }

    /**
     * Returns a {@link List} of the size of {@code howMany} containing skew-symmetric {@link RealComplexNumberMatrix
     * RealComplexNumberMatrices}
     *
     * @param bound
     *            the bound
     * @param scale
     *            the scale
     * @param size
     *            the row and column size of the resulting {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @param howMany
     *            the size of the resulting {@link List}
     * @return A {@link List} of pseudo random skew-symmetric {@link RealComplexNumberMatrix RealComplexNumberMatrices}
     * @throws IllegalArgumentException
     *             if {@code bound &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code scale &lt; 0}
     * @throws IllegalArgumentException
     *             if {@code size &lt; 1}
     * @throws IllegalArgumentException
     *             if {@code howMany &lt; 1}
     * @author Lars Tennstedt
     * @see #nextSkewSymmetricRealComplexNumberMatrix
     * @since 1
     */
    public List&lt;RealComplexNumberMatrix&gt; nextSkewSymmetricRealComplexNumberMatrices(final long bound, final int scale,
            final int size, final int howMany) {
<span class="fc bfc" id="L3333" title="All 2 branches covered.">        checkArgument(bound &gt; 0, &quot;expected bound &gt; 0 but actual %s&quot;, bound);</span>
<span class="fc bfc" id="L3334" title="All 2 branches covered.">        checkArgument(scale &gt; -1, &quot;expected scale &gt; -1 but actual %s&quot;, scale);</span>
<span class="fc bfc" id="L3335" title="All 2 branches covered.">        checkArgument(size &gt; 0, &quot;expected size &gt; 0 but actual %s&quot;, size);</span>
<span class="fc bfc" id="L3336" title="All 2 branches covered.">        checkArgument(howMany &gt; 0, &quot;expected howMany &gt; 0 but actual %s&quot;, howMany);</span>
<span class="fc" id="L3337">        final List&lt;RealComplexNumberMatrix&gt; matrices = new ArrayList&lt;&gt;(howMany);</span>
<span class="fc bfc" id="L3338" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L3339">            matrices.add(nextSkewSymmetricRealComplexNumberMatrix(bound, scale, size));</span>
        }
<span class="fc" id="L3341">        return matrices;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L3346">        return MoreObjects.toStringHelper(this).add(&quot;random&quot;, random).toString();</span>
    }

    @VisibleForTesting
    Random getRandom() {
<span class="fc" id="L3351">        return random;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>